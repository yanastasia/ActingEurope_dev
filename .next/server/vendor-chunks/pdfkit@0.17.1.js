"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfkit@0.17.1";
exports.ids = ["vendor-chunks/pdfkit@0.17.1"];
exports.modules = {

/***/ "(action-browser)/./node_modules/.pnpm/pdfkit@0.17.1/node_modules/pdfkit/js/pdfkit.es.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/pdfkit@0.17.1/node_modules/pdfkit/js/pdfkit.es.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PDFDocument)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto-js */ \"(action-browser)/./node_modules/.pnpm/crypto-js@4.2.0/node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fontkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fontkit */ \"(action-browser)/./node_modules/.pnpm/fontkit@2.0.4/node_modules/fontkit/dist/module.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var linebreak__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! linebreak */ \"(action-browser)/./node_modules/.pnpm/linebreak@1.1.0/node_modules/linebreak/dist/module.mjs\");\n/* harmony import */ var jpeg_exif__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jpeg-exif */ \"(action-browser)/./node_modules/.pnpm/jpeg-exif@1.1.4/node_modules/jpeg-exif/lib/index.js\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! png-js */ \"(action-browser)/./node_modules/.pnpm/png-js@1.0.0/node_modules/png-js/png-node.js\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(png_js__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\n\nclass PDFAbstractReference {\n  toString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\nclass PDFTree {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._items = {};\n    this.limits = typeof options.limits === 'boolean' ? options.limits : true;\n  }\n  add(key, val) {\n    return this._items[key] = val;\n  }\n  get(key) {\n    return this._items[key];\n  }\n  toString() {\n    const sortedKeys = Object.keys(this._items).sort((a, b) => this._compareKeys(a, b));\n    const out = ['<<'];\n    if (this.limits && sortedKeys.length > 1) {\n      const first = sortedKeys[0],\n        last = sortedKeys[sortedKeys.length - 1];\n      out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last)])}`);\n    }\n    out.push(`  /${this._keysName()} [`);\n    for (let key of sortedKeys) {\n      out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);\n    }\n    out.push(']');\n    out.push('>>');\n    return out.join('\\n');\n  }\n  _compareKeys() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  _keysName() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  _dataForKey() {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\nclass SpotColor {\n  constructor(doc, name, C, M, Y, K) {\n    this.id = 'CS' + Object.keys(doc.spotColors).length;\n    this.name = name;\n    this.values = [C, M, Y, K];\n    this.ref = doc.ref(['Separation', this.name, 'DeviceCMYK', {\n      Range: [0, 1, 0, 1, 0, 1, 0, 1],\n      C0: [0, 0, 0, 0],\n      C1: this.values.map(value => value / 100),\n      FunctionType: 2,\n      Domain: [0, 1],\n      N: 1\n    }]);\n    this.ref.end();\n  }\n  toString() {\n    return `${this.ref.id} 0 R`;\n  }\n}\n\nconst pad = (str, length) => (Array(length + 1).join('0') + str).slice(-length);\nconst escapableRe = /[\\n\\r\\t\\b\\f()\\\\]/g;\nconst escapable = {\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\\\': '\\\\\\\\',\n  '(': '\\\\(',\n  ')': '\\\\)'\n};\nconst swapBytes = function (buff) {\n  const l = buff.length;\n  if (l & 0x01) {\n    throw new Error('Buffer length must be even');\n  } else {\n    for (let i = 0, end = l - 1; i < end; i += 2) {\n      const a = buff[i];\n      buff[i] = buff[i + 1];\n      buff[i + 1] = a;\n    }\n  }\n  return buff;\n};\nclass PDFObject {\n  static convert(object) {\n    let encryptFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (typeof object === 'string') {\n      return `/${object}`;\n    } else if (object instanceof String) {\n      let string = object;\n      let isUnicode = false;\n      for (let i = 0, end = string.length; i < end; i++) {\n        if (string.charCodeAt(i) > 0x7f) {\n          isUnicode = true;\n          break;\n        }\n      }\n      let stringBuffer;\n      if (isUnicode) {\n        stringBuffer = swapBytes(Buffer.from(`\\ufeff${string}`, 'utf16le'));\n      } else {\n        stringBuffer = Buffer.from(string.valueOf(), 'ascii');\n      }\n      if (encryptFn) {\n        string = encryptFn(stringBuffer).toString('binary');\n      } else {\n        string = stringBuffer.toString('binary');\n      }\n      string = string.replace(escapableRe, c => escapable[c]);\n      return `(${string})`;\n    } else if (Buffer.isBuffer(object)) {\n      return `<${object.toString('hex')}>`;\n    } else if (object instanceof PDFAbstractReference || object instanceof PDFTree || object instanceof SpotColor) {\n      return object.toString();\n    } else if (object instanceof Date) {\n      let string = `D:${pad(object.getUTCFullYear(), 4)}` + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z';\n      if (encryptFn) {\n        string = encryptFn(Buffer.from(string, 'ascii')).toString('binary');\n        string = string.replace(escapableRe, c => escapable[c]);\n      }\n      return `(${string})`;\n    } else if (Array.isArray(object)) {\n      const items = object.map(e => PDFObject.convert(e, encryptFn)).join(' ');\n      return `[${items}]`;\n    } else if ({}.toString.call(object) === '[object Object]') {\n      const out = ['<<'];\n      for (let key in object) {\n        const val = object[key];\n        out.push(`/${key} ${PDFObject.convert(val, encryptFn)}`);\n      }\n      out.push('>>');\n      return out.join('\\n');\n    } else if (typeof object === 'number') {\n      return PDFObject.number(object);\n    } else {\n      return `${object}`;\n    }\n  }\n  static number(n) {\n    if (n > -1e21 && n < 1e21) {\n      return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n  }\n}\n\nclass PDFReference extends PDFAbstractReference {\n  constructor(document, id) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.document = document;\n    this.id = id;\n    this.data = data;\n    this.gen = 0;\n    this.compress = this.document.compress && !this.data.Filter;\n    this.uncompressedLength = 0;\n    this.buffer = [];\n  }\n  write(chunk) {\n    if (!(chunk instanceof Uint8Array)) {\n      chunk = Buffer.from(chunk + '\\n', 'binary');\n    }\n    this.uncompressedLength += chunk.length;\n    if (this.data.Length == null) {\n      this.data.Length = 0;\n    }\n    this.buffer.push(chunk);\n    this.data.Length += chunk.length;\n    if (this.compress) {\n      this.data.Filter = 'FlateDecode';\n    }\n  }\n  end(chunk) {\n    if (chunk) {\n      this.write(chunk);\n    }\n    this.finalize();\n  }\n  finalize() {\n    this.offset = this.document._offset;\n    const encryptFn = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null;\n    if (this.buffer.length) {\n      this.buffer = Buffer.concat(this.buffer);\n      if (this.compress) {\n        this.buffer = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(this.buffer);\n      }\n      if (encryptFn) {\n        this.buffer = encryptFn(this.buffer);\n      }\n      this.data.Length = this.buffer.length;\n    }\n    this.document._write(`${this.id} ${this.gen} obj`);\n    this.document._write(PDFObject.convert(this.data, encryptFn));\n    if (this.buffer.length) {\n      this.document._write('stream');\n      this.document._write(this.buffer);\n      this.buffer = [];\n      this.document._write('\\nendstream');\n    }\n    this.document._write('endobj');\n    this.document._refEnd(this);\n  }\n  toString() {\n    return `${this.id} ${this.gen} R`;\n  }\n}\n\nconst fArray = new Float32Array(1);\nconst uArray = new Uint32Array(fArray.buffer);\nfunction PDFNumber(n) {\n  const rounded = Math.fround(n);\n  if (rounded <= n) return rounded;\n  fArray[0] = n;\n  if (n <= 0) {\n    uArray[0] += 1;\n  } else {\n    uArray[0] -= 1;\n  }\n  return fArray[0];\n}\nfunction normalizeSides(sides) {\n  let defaultDefinition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let transformer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : v => v;\n  if (sides == null || typeof sides === 'object' && Object.keys(sides).length === 0) {\n    sides = defaultDefinition;\n  }\n  if (sides == null || typeof sides !== 'object') {\n    sides = {\n      top: sides,\n      right: sides,\n      bottom: sides,\n      left: sides\n    };\n  } else if (Array.isArray(sides)) {\n    if (sides.length === 2) {\n      sides = {\n        vertical: sides[0],\n        horizontal: sides[1]\n      };\n    } else {\n      sides = {\n        top: sides[0],\n        right: sides[1],\n        bottom: sides[2],\n        left: sides[3]\n      };\n    }\n  }\n  if ('vertical' in sides || 'horizontal' in sides) {\n    sides = {\n      top: sides.vertical,\n      right: sides.horizontal,\n      bottom: sides.vertical,\n      left: sides.horizontal\n    };\n  }\n  return {\n    top: transformer(sides.top),\n    right: transformer(sides.right),\n    bottom: transformer(sides.bottom),\n    left: transformer(sides.left)\n  };\n}\nconst MM_TO_CM = 1 / 10;\nconst CM_TO_IN = 1 / 2.54;\nconst PX_TO_IN = 1 / 96;\nconst IN_TO_PT = 72;\nconst PC_TO_PT = 12;\nfunction cosine(a) {\n  if (a === 0) return 1;\n  if (a === 90) return 0;\n  if (a === 180) return -1;\n  if (a === 270) return 0;\n  return Math.cos(a * Math.PI / 180);\n}\nfunction sine(a) {\n  if (a === 0) return 0;\n  if (a === 90) return 1;\n  if (a === 180) return 0;\n  if (a === 270) return -1;\n  return Math.sin(a * Math.PI / 180);\n}\n\nconst DEFAULT_MARGINS = {\n  top: 72,\n  left: 72,\n  bottom: 72,\n  right: 72\n};\nconst SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0]\n};\nclass PDFPage {\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.document = document;\n    this._options = options;\n    this.size = options.size || 'letter';\n    this.layout = options.layout || 'portrait';\n    const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];\n    this.width = dimensions[this.layout === 'portrait' ? 0 : 1];\n    this.height = dimensions[this.layout === 'portrait' ? 1 : 0];\n    this.content = this.document.ref();\n    if (options.font) document.font(options.font, options.fontFamily);\n    if (options.fontSize) document.fontSize(options.fontSize);\n    this.margins = normalizeSides(options.margin ?? options.margins, DEFAULT_MARGINS, x => document.sizeToPoint(x, 0, this));\n    this.resources = this.document.ref({\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI']\n    });\n    this.dictionary = this.document.ref({\n      Type: 'Page',\n      Parent: this.document._root.data.Pages,\n      MediaBox: [0, 0, this.width, this.height],\n      Contents: this.content,\n      Resources: this.resources\n    });\n    this.markings = [];\n  }\n  get fonts() {\n    const data = this.resources.data;\n    return data.Font != null ? data.Font : data.Font = {};\n  }\n  get xobjects() {\n    const data = this.resources.data;\n    return data.XObject != null ? data.XObject : data.XObject = {};\n  }\n  get ext_gstates() {\n    const data = this.resources.data;\n    return data.ExtGState != null ? data.ExtGState : data.ExtGState = {};\n  }\n  get patterns() {\n    const data = this.resources.data;\n    return data.Pattern != null ? data.Pattern : data.Pattern = {};\n  }\n  get colorSpaces() {\n    const data = this.resources.data;\n    return data.ColorSpace || (data.ColorSpace = {});\n  }\n  get annotations() {\n    const data = this.dictionary.data;\n    return data.Annots != null ? data.Annots : data.Annots = [];\n  }\n  get structParentTreeKey() {\n    const data = this.dictionary.data;\n    return data.StructParents != null ? data.StructParents : data.StructParents = this.document.createStructParentTreeNextKey();\n  }\n  get contentWidth() {\n    return this.width - this.margins.left - this.margins.right;\n  }\n  get contentHeight() {\n    return this.height - this.margins.top - this.margins.bottom;\n  }\n  maxY() {\n    return this.height - this.margins.bottom;\n  }\n  write(chunk) {\n    return this.content.write(chunk);\n  }\n  _setTabOrder() {\n    if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {\n      this.dictionary.data.Tabs = 'S';\n    }\n  }\n  end() {\n    this._setTabOrder();\n    this.dictionary.end();\n    this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};\n    for (let color of Object.values(this.document.spotColors)) {\n      this.resources.data.ColorSpace[color.id] = color;\n    }\n    this.resources.end();\n    return this.content.end();\n  }\n}\n\nclass PDFNameTree extends PDFTree {\n  _compareKeys(a, b) {\n    return a.localeCompare(b);\n  }\n  _keysName() {\n    return 'Names';\n  }\n  _dataForKey(k) {\n    return new String(k);\n  }\n}\n\nfunction inRange(value, rangeGroup) {\n  if (value < rangeGroup[0]) return false;\n  let startRange = 0;\n  let endRange = rangeGroup.length / 2;\n  while (startRange <= endRange) {\n    const middleRange = Math.floor((startRange + endRange) / 2);\n    const arrayIndex = middleRange * 2;\n    if (value >= rangeGroup[arrayIndex] && value <= rangeGroup[arrayIndex + 1]) {\n      return true;\n    }\n    if (value > rangeGroup[arrayIndex + 1]) {\n      startRange = middleRange + 1;\n    } else {\n      endRange = middleRange - 1;\n    }\n  }\n  return false;\n}\n\nconst unassigned_code_points = [0x0221, 0x0221, 0x0234, 0x024f, 0x02ae, 0x02af, 0x02ef, 0x02ff, 0x0350, 0x035f, 0x0370, 0x0373, 0x0376, 0x0379, 0x037b, 0x037d, 0x037f, 0x0383, 0x038b, 0x038b, 0x038d, 0x038d, 0x03a2, 0x03a2, 0x03cf, 0x03cf, 0x03f7, 0x03ff, 0x0487, 0x0487, 0x04cf, 0x04cf, 0x04f6, 0x04f7, 0x04fa, 0x04ff, 0x0510, 0x0530, 0x0557, 0x0558, 0x0560, 0x0560, 0x0588, 0x0588, 0x058b, 0x0590, 0x05a2, 0x05a2, 0x05ba, 0x05ba, 0x05c5, 0x05cf, 0x05eb, 0x05ef, 0x05f5, 0x060b, 0x060d, 0x061a, 0x061c, 0x061e, 0x0620, 0x0620, 0x063b, 0x063f, 0x0656, 0x065f, 0x06ee, 0x06ef, 0x06ff, 0x06ff, 0x070e, 0x070e, 0x072d, 0x072f, 0x074b, 0x077f, 0x07b2, 0x0900, 0x0904, 0x0904, 0x093a, 0x093b, 0x094e, 0x094f, 0x0955, 0x0957, 0x0971, 0x0980, 0x0984, 0x0984, 0x098d, 0x098e, 0x0991, 0x0992, 0x09a9, 0x09a9, 0x09b1, 0x09b1, 0x09b3, 0x09b5, 0x09ba, 0x09bb, 0x09bd, 0x09bd, 0x09c5, 0x09c6, 0x09c9, 0x09ca, 0x09ce, 0x09d6, 0x09d8, 0x09db, 0x09de, 0x09de, 0x09e4, 0x09e5, 0x09fb, 0x0a01, 0x0a03, 0x0a04, 0x0a0b, 0x0a0e, 0x0a11, 0x0a12, 0x0a29, 0x0a29, 0x0a31, 0x0a31, 0x0a34, 0x0a34, 0x0a37, 0x0a37, 0x0a3a, 0x0a3b, 0x0a3d, 0x0a3d, 0x0a43, 0x0a46, 0x0a49, 0x0a4a, 0x0a4e, 0x0a58, 0x0a5d, 0x0a5d, 0x0a5f, 0x0a65, 0x0a75, 0x0a80, 0x0a84, 0x0a84, 0x0a8c, 0x0a8c, 0x0a8e, 0x0a8e, 0x0a92, 0x0a92, 0x0aa9, 0x0aa9, 0x0ab1, 0x0ab1, 0x0ab4, 0x0ab4, 0x0aba, 0x0abb, 0x0ac6, 0x0ac6, 0x0aca, 0x0aca, 0x0ace, 0x0acf, 0x0ad1, 0x0adf, 0x0ae1, 0x0ae5, 0x0af0, 0x0b00, 0x0b04, 0x0b04, 0x0b0d, 0x0b0e, 0x0b11, 0x0b12, 0x0b29, 0x0b29, 0x0b31, 0x0b31, 0x0b34, 0x0b35, 0x0b3a, 0x0b3b, 0x0b44, 0x0b46, 0x0b49, 0x0b4a, 0x0b4e, 0x0b55, 0x0b58, 0x0b5b, 0x0b5e, 0x0b5e, 0x0b62, 0x0b65, 0x0b71, 0x0b81, 0x0b84, 0x0b84, 0x0b8b, 0x0b8d, 0x0b91, 0x0b91, 0x0b96, 0x0b98, 0x0b9b, 0x0b9b, 0x0b9d, 0x0b9d, 0x0ba0, 0x0ba2, 0x0ba5, 0x0ba7, 0x0bab, 0x0bad, 0x0bb6, 0x0bb6, 0x0bba, 0x0bbd, 0x0bc3, 0x0bc5, 0x0bc9, 0x0bc9, 0x0bce, 0x0bd6, 0x0bd8, 0x0be6, 0x0bf3, 0x0c00, 0x0c04, 0x0c04, 0x0c0d, 0x0c0d, 0x0c11, 0x0c11, 0x0c29, 0x0c29, 0x0c34, 0x0c34, 0x0c3a, 0x0c3d, 0x0c45, 0x0c45, 0x0c49, 0x0c49, 0x0c4e, 0x0c54, 0x0c57, 0x0c5f, 0x0c62, 0x0c65, 0x0c70, 0x0c81, 0x0c84, 0x0c84, 0x0c8d, 0x0c8d, 0x0c91, 0x0c91, 0x0ca9, 0x0ca9, 0x0cb4, 0x0cb4, 0x0cba, 0x0cbd, 0x0cc5, 0x0cc5, 0x0cc9, 0x0cc9, 0x0cce, 0x0cd4, 0x0cd7, 0x0cdd, 0x0cdf, 0x0cdf, 0x0ce2, 0x0ce5, 0x0cf0, 0x0d01, 0x0d04, 0x0d04, 0x0d0d, 0x0d0d, 0x0d11, 0x0d11, 0x0d29, 0x0d29, 0x0d3a, 0x0d3d, 0x0d44, 0x0d45, 0x0d49, 0x0d49, 0x0d4e, 0x0d56, 0x0d58, 0x0d5f, 0x0d62, 0x0d65, 0x0d70, 0x0d81, 0x0d84, 0x0d84, 0x0d97, 0x0d99, 0x0db2, 0x0db2, 0x0dbc, 0x0dbc, 0x0dbe, 0x0dbf, 0x0dc7, 0x0dc9, 0x0dcb, 0x0dce, 0x0dd5, 0x0dd5, 0x0dd7, 0x0dd7, 0x0de0, 0x0df1, 0x0df5, 0x0e00, 0x0e3b, 0x0e3e, 0x0e5c, 0x0e80, 0x0e83, 0x0e83, 0x0e85, 0x0e86, 0x0e89, 0x0e89, 0x0e8b, 0x0e8c, 0x0e8e, 0x0e93, 0x0e98, 0x0e98, 0x0ea0, 0x0ea0, 0x0ea4, 0x0ea4, 0x0ea6, 0x0ea6, 0x0ea8, 0x0ea9, 0x0eac, 0x0eac, 0x0eba, 0x0eba, 0x0ebe, 0x0ebf, 0x0ec5, 0x0ec5, 0x0ec7, 0x0ec7, 0x0ece, 0x0ecf, 0x0eda, 0x0edb, 0x0ede, 0x0eff, 0x0f48, 0x0f48, 0x0f6b, 0x0f70, 0x0f8c, 0x0f8f, 0x0f98, 0x0f98, 0x0fbd, 0x0fbd, 0x0fcd, 0x0fce, 0x0fd0, 0x0fff, 0x1022, 0x1022, 0x1028, 0x1028, 0x102b, 0x102b, 0x1033, 0x1035, 0x103a, 0x103f, 0x105a, 0x109f, 0x10c6, 0x10cf, 0x10f9, 0x10fa, 0x10fc, 0x10ff, 0x115a, 0x115e, 0x11a3, 0x11a7, 0x11fa, 0x11ff, 0x1207, 0x1207, 0x1247, 0x1247, 0x1249, 0x1249, 0x124e, 0x124f, 0x1257, 0x1257, 0x1259, 0x1259, 0x125e, 0x125f, 0x1287, 0x1287, 0x1289, 0x1289, 0x128e, 0x128f, 0x12af, 0x12af, 0x12b1, 0x12b1, 0x12b6, 0x12b7, 0x12bf, 0x12bf, 0x12c1, 0x12c1, 0x12c6, 0x12c7, 0x12cf, 0x12cf, 0x12d7, 0x12d7, 0x12ef, 0x12ef, 0x130f, 0x130f, 0x1311, 0x1311, 0x1316, 0x1317, 0x131f, 0x131f, 0x1347, 0x1347, 0x135b, 0x1360, 0x137d, 0x139f, 0x13f5, 0x1400, 0x1677, 0x167f, 0x169d, 0x169f, 0x16f1, 0x16ff, 0x170d, 0x170d, 0x1715, 0x171f, 0x1737, 0x173f, 0x1754, 0x175f, 0x176d, 0x176d, 0x1771, 0x1771, 0x1774, 0x177f, 0x17dd, 0x17df, 0x17ea, 0x17ff, 0x180f, 0x180f, 0x181a, 0x181f, 0x1878, 0x187f, 0x18aa, 0x1dff, 0x1e9c, 0x1e9f, 0x1efa, 0x1eff, 0x1f16, 0x1f17, 0x1f1e, 0x1f1f, 0x1f46, 0x1f47, 0x1f4e, 0x1f4f, 0x1f58, 0x1f58, 0x1f5a, 0x1f5a, 0x1f5c, 0x1f5c, 0x1f5e, 0x1f5e, 0x1f7e, 0x1f7f, 0x1fb5, 0x1fb5, 0x1fc5, 0x1fc5, 0x1fd4, 0x1fd5, 0x1fdc, 0x1fdc, 0x1ff0, 0x1ff1, 0x1ff5, 0x1ff5, 0x1fff, 0x1fff, 0x2053, 0x2056, 0x2058, 0x205e, 0x2064, 0x2069, 0x2072, 0x2073, 0x208f, 0x209f, 0x20b2, 0x20cf, 0x20eb, 0x20ff, 0x213b, 0x213c, 0x214c, 0x2152, 0x2184, 0x218f, 0x23cf, 0x23ff, 0x2427, 0x243f, 0x244b, 0x245f, 0x24ff, 0x24ff, 0x2614, 0x2615, 0x2618, 0x2618, 0x267e, 0x267f, 0x268a, 0x2700, 0x2705, 0x2705, 0x270a, 0x270b, 0x2728, 0x2728, 0x274c, 0x274c, 0x274e, 0x274e, 0x2753, 0x2755, 0x2757, 0x2757, 0x275f, 0x2760, 0x2795, 0x2797, 0x27b0, 0x27b0, 0x27bf, 0x27cf, 0x27ec, 0x27ef, 0x2b00, 0x2e7f, 0x2e9a, 0x2e9a, 0x2ef4, 0x2eff, 0x2fd6, 0x2fef, 0x2ffc, 0x2fff, 0x3040, 0x3040, 0x3097, 0x3098, 0x3100, 0x3104, 0x312d, 0x3130, 0x318f, 0x318f, 0x31b8, 0x31ef, 0x321d, 0x321f, 0x3244, 0x3250, 0x327c, 0x327e, 0x32cc, 0x32cf, 0x32ff, 0x32ff, 0x3377, 0x337a, 0x33de, 0x33df, 0x33ff, 0x33ff, 0x4db6, 0x4dff, 0x9fa6, 0x9fff, 0xa48d, 0xa48f, 0xa4c7, 0xabff, 0xd7a4, 0xd7ff, 0xfa2e, 0xfa2f, 0xfa6b, 0xfaff, 0xfb07, 0xfb12, 0xfb18, 0xfb1c, 0xfb37, 0xfb37, 0xfb3d, 0xfb3d, 0xfb3f, 0xfb3f, 0xfb42, 0xfb42, 0xfb45, 0xfb45, 0xfbb2, 0xfbd2, 0xfd40, 0xfd4f, 0xfd90, 0xfd91, 0xfdc8, 0xfdcf, 0xfdfd, 0xfdff, 0xfe10, 0xfe1f, 0xfe24, 0xfe2f, 0xfe47, 0xfe48, 0xfe53, 0xfe53, 0xfe67, 0xfe67, 0xfe6c, 0xfe6f, 0xfe75, 0xfe75, 0xfefd, 0xfefe, 0xff00, 0xff00, 0xffbf, 0xffc1, 0xffc8, 0xffc9, 0xffd0, 0xffd1, 0xffd8, 0xffd9, 0xffdd, 0xffdf, 0xffe7, 0xffe7, 0xffef, 0xfff8, 0x10000, 0x102ff, 0x1031f, 0x1031f, 0x10324, 0x1032f, 0x1034b, 0x103ff, 0x10426, 0x10427, 0x1044e, 0x1cfff, 0x1d0f6, 0x1d0ff, 0x1d127, 0x1d129, 0x1d1de, 0x1d3ff, 0x1d455, 0x1d455, 0x1d49d, 0x1d49d, 0x1d4a0, 0x1d4a1, 0x1d4a3, 0x1d4a4, 0x1d4a7, 0x1d4a8, 0x1d4ad, 0x1d4ad, 0x1d4ba, 0x1d4ba, 0x1d4bc, 0x1d4bc, 0x1d4c1, 0x1d4c1, 0x1d4c4, 0x1d4c4, 0x1d506, 0x1d506, 0x1d50b, 0x1d50c, 0x1d515, 0x1d515, 0x1d51d, 0x1d51d, 0x1d53a, 0x1d53a, 0x1d53f, 0x1d53f, 0x1d545, 0x1d545, 0x1d547, 0x1d549, 0x1d551, 0x1d551, 0x1d6a4, 0x1d6a7, 0x1d7ca, 0x1d7cd, 0x1d800, 0x1fffd, 0x2a6d7, 0x2f7ff, 0x2fa1e, 0x2fffd, 0x30000, 0x3fffd, 0x40000, 0x4fffd, 0x50000, 0x5fffd, 0x60000, 0x6fffd, 0x70000, 0x7fffd, 0x80000, 0x8fffd, 0x90000, 0x9fffd, 0xa0000, 0xafffd, 0xb0000, 0xbfffd, 0xc0000, 0xcfffd, 0xd0000, 0xdfffd, 0xe0000, 0xe0000, 0xe0002, 0xe001f, 0xe0080, 0xefffd];\nconst isUnassignedCodePoint = character => inRange(character, unassigned_code_points);\nconst commonly_mapped_to_nothing = [0x00ad, 0x00ad, 0x034f, 0x034f, 0x1806, 0x1806, 0x180b, 0x180b, 0x180c, 0x180c, 0x180d, 0x180d, 0x200b, 0x200b, 0x200c, 0x200c, 0x200d, 0x200d, 0x2060, 0x2060, 0xfe00, 0xfe00, 0xfe01, 0xfe01, 0xfe02, 0xfe02, 0xfe03, 0xfe03, 0xfe04, 0xfe04, 0xfe05, 0xfe05, 0xfe06, 0xfe06, 0xfe07, 0xfe07, 0xfe08, 0xfe08, 0xfe09, 0xfe09, 0xfe0a, 0xfe0a, 0xfe0b, 0xfe0b, 0xfe0c, 0xfe0c, 0xfe0d, 0xfe0d, 0xfe0e, 0xfe0e, 0xfe0f, 0xfe0f, 0xfeff, 0xfeff];\nconst isCommonlyMappedToNothing = character => inRange(character, commonly_mapped_to_nothing);\nconst non_ASCII_space_characters = [0x00a0, 0x00a0, 0x1680, 0x1680, 0x2000, 0x2000, 0x2001, 0x2001, 0x2002, 0x2002, 0x2003, 0x2003, 0x2004, 0x2004, 0x2005, 0x2005, 0x2006, 0x2006, 0x2007, 0x2007, 0x2008, 0x2008, 0x2009, 0x2009, 0x200a, 0x200a, 0x200b, 0x200b, 0x202f, 0x202f, 0x205f, 0x205f, 0x3000, 0x3000];\nconst isNonASCIISpaceCharacter = character => inRange(character, non_ASCII_space_characters);\nconst non_ASCII_controls_characters = [0x0080, 0x009f, 0x06dd, 0x06dd, 0x070f, 0x070f, 0x180e, 0x180e, 0x200c, 0x200c, 0x200d, 0x200d, 0x2028, 0x2028, 0x2029, 0x2029, 0x2060, 0x2060, 0x2061, 0x2061, 0x2062, 0x2062, 0x2063, 0x2063, 0x206a, 0x206f, 0xfeff, 0xfeff, 0xfff9, 0xfffc, 0x1d173, 0x1d17a];\nconst non_character_codepoints = [0xfdd0, 0xfdef, 0xfffe, 0xffff, 0x1fffe, 0x1ffff, 0x2fffe, 0x2ffff, 0x3fffe, 0x3ffff, 0x4fffe, 0x4ffff, 0x5fffe, 0x5ffff, 0x6fffe, 0x6ffff, 0x7fffe, 0x7ffff, 0x8fffe, 0x8ffff, 0x9fffe, 0x9ffff, 0xafffe, 0xaffff, 0xbfffe, 0xbffff, 0xcfffe, 0xcffff, 0xdfffe, 0xdffff, 0xefffe, 0xeffff, 0x10fffe, 0x10ffff];\nconst prohibited_characters = [0, 0x001f, 0x007f, 0x007f, 0x0340, 0x0340, 0x0341, 0x0341, 0x200e, 0x200e, 0x200f, 0x200f, 0x202a, 0x202a, 0x202b, 0x202b, 0x202c, 0x202c, 0x202d, 0x202d, 0x202e, 0x202e, 0x206a, 0x206a, 0x206b, 0x206b, 0x206c, 0x206c, 0x206d, 0x206d, 0x206e, 0x206e, 0x206f, 0x206f, 0x2ff0, 0x2ffb, 0xd800, 0xdfff, 0xe000, 0xf8ff, 0xfff9, 0xfff9, 0xfffa, 0xfffa, 0xfffb, 0xfffb, 0xfffc, 0xfffc, 0xfffd, 0xfffd, 0xe0001, 0xe0001, 0xe0020, 0xe007f, 0xf0000, 0xffffd, 0x100000, 0x10fffd];\nconst isProhibitedCharacter = character => inRange(character, non_ASCII_space_characters) || inRange(character, prohibited_characters) || inRange(character, non_ASCII_controls_characters) || inRange(character, non_character_codepoints);\nconst bidirectional_r_al = [0x05be, 0x05be, 0x05c0, 0x05c0, 0x05c3, 0x05c3, 0x05d0, 0x05ea, 0x05f0, 0x05f4, 0x061b, 0x061b, 0x061f, 0x061f, 0x0621, 0x063a, 0x0640, 0x064a, 0x066d, 0x066f, 0x0671, 0x06d5, 0x06dd, 0x06dd, 0x06e5, 0x06e6, 0x06fa, 0x06fe, 0x0700, 0x070d, 0x0710, 0x0710, 0x0712, 0x072c, 0x0780, 0x07a5, 0x07b1, 0x07b1, 0x200f, 0x200f, 0xfb1d, 0xfb1d, 0xfb1f, 0xfb28, 0xfb2a, 0xfb36, 0xfb38, 0xfb3c, 0xfb3e, 0xfb3e, 0xfb40, 0xfb41, 0xfb43, 0xfb44, 0xfb46, 0xfbb1, 0xfbd3, 0xfd3d, 0xfd50, 0xfd8f, 0xfd92, 0xfdc7, 0xfdf0, 0xfdfc, 0xfe70, 0xfe74, 0xfe76, 0xfefc];\nconst isBidirectionalRAL = character => inRange(character, bidirectional_r_al);\nconst bidirectional_l = [0x0041, 0x005a, 0x0061, 0x007a, 0x00aa, 0x00aa, 0x00b5, 0x00b5, 0x00ba, 0x00ba, 0x00c0, 0x00d6, 0x00d8, 0x00f6, 0x00f8, 0x0220, 0x0222, 0x0233, 0x0250, 0x02ad, 0x02b0, 0x02b8, 0x02bb, 0x02c1, 0x02d0, 0x02d1, 0x02e0, 0x02e4, 0x02ee, 0x02ee, 0x037a, 0x037a, 0x0386, 0x0386, 0x0388, 0x038a, 0x038c, 0x038c, 0x038e, 0x03a1, 0x03a3, 0x03ce, 0x03d0, 0x03f5, 0x0400, 0x0482, 0x048a, 0x04ce, 0x04d0, 0x04f5, 0x04f8, 0x04f9, 0x0500, 0x050f, 0x0531, 0x0556, 0x0559, 0x055f, 0x0561, 0x0587, 0x0589, 0x0589, 0x0903, 0x0903, 0x0905, 0x0939, 0x093d, 0x0940, 0x0949, 0x094c, 0x0950, 0x0950, 0x0958, 0x0961, 0x0964, 0x0970, 0x0982, 0x0983, 0x0985, 0x098c, 0x098f, 0x0990, 0x0993, 0x09a8, 0x09aa, 0x09b0, 0x09b2, 0x09b2, 0x09b6, 0x09b9, 0x09be, 0x09c0, 0x09c7, 0x09c8, 0x09cb, 0x09cc, 0x09d7, 0x09d7, 0x09dc, 0x09dd, 0x09df, 0x09e1, 0x09e6, 0x09f1, 0x09f4, 0x09fa, 0x0a05, 0x0a0a, 0x0a0f, 0x0a10, 0x0a13, 0x0a28, 0x0a2a, 0x0a30, 0x0a32, 0x0a33, 0x0a35, 0x0a36, 0x0a38, 0x0a39, 0x0a3e, 0x0a40, 0x0a59, 0x0a5c, 0x0a5e, 0x0a5e, 0x0a66, 0x0a6f, 0x0a72, 0x0a74, 0x0a83, 0x0a83, 0x0a85, 0x0a8b, 0x0a8d, 0x0a8d, 0x0a8f, 0x0a91, 0x0a93, 0x0aa8, 0x0aaa, 0x0ab0, 0x0ab2, 0x0ab3, 0x0ab5, 0x0ab9, 0x0abd, 0x0ac0, 0x0ac9, 0x0ac9, 0x0acb, 0x0acc, 0x0ad0, 0x0ad0, 0x0ae0, 0x0ae0, 0x0ae6, 0x0aef, 0x0b02, 0x0b03, 0x0b05, 0x0b0c, 0x0b0f, 0x0b10, 0x0b13, 0x0b28, 0x0b2a, 0x0b30, 0x0b32, 0x0b33, 0x0b36, 0x0b39, 0x0b3d, 0x0b3e, 0x0b40, 0x0b40, 0x0b47, 0x0b48, 0x0b4b, 0x0b4c, 0x0b57, 0x0b57, 0x0b5c, 0x0b5d, 0x0b5f, 0x0b61, 0x0b66, 0x0b70, 0x0b83, 0x0b83, 0x0b85, 0x0b8a, 0x0b8e, 0x0b90, 0x0b92, 0x0b95, 0x0b99, 0x0b9a, 0x0b9c, 0x0b9c, 0x0b9e, 0x0b9f, 0x0ba3, 0x0ba4, 0x0ba8, 0x0baa, 0x0bae, 0x0bb5, 0x0bb7, 0x0bb9, 0x0bbe, 0x0bbf, 0x0bc1, 0x0bc2, 0x0bc6, 0x0bc8, 0x0bca, 0x0bcc, 0x0bd7, 0x0bd7, 0x0be7, 0x0bf2, 0x0c01, 0x0c03, 0x0c05, 0x0c0c, 0x0c0e, 0x0c10, 0x0c12, 0x0c28, 0x0c2a, 0x0c33, 0x0c35, 0x0c39, 0x0c41, 0x0c44, 0x0c60, 0x0c61, 0x0c66, 0x0c6f, 0x0c82, 0x0c83, 0x0c85, 0x0c8c, 0x0c8e, 0x0c90, 0x0c92, 0x0ca8, 0x0caa, 0x0cb3, 0x0cb5, 0x0cb9, 0x0cbe, 0x0cbe, 0x0cc0, 0x0cc4, 0x0cc7, 0x0cc8, 0x0cca, 0x0ccb, 0x0cd5, 0x0cd6, 0x0cde, 0x0cde, 0x0ce0, 0x0ce1, 0x0ce6, 0x0cef, 0x0d02, 0x0d03, 0x0d05, 0x0d0c, 0x0d0e, 0x0d10, 0x0d12, 0x0d28, 0x0d2a, 0x0d39, 0x0d3e, 0x0d40, 0x0d46, 0x0d48, 0x0d4a, 0x0d4c, 0x0d57, 0x0d57, 0x0d60, 0x0d61, 0x0d66, 0x0d6f, 0x0d82, 0x0d83, 0x0d85, 0x0d96, 0x0d9a, 0x0db1, 0x0db3, 0x0dbb, 0x0dbd, 0x0dbd, 0x0dc0, 0x0dc6, 0x0dcf, 0x0dd1, 0x0dd8, 0x0ddf, 0x0df2, 0x0df4, 0x0e01, 0x0e30, 0x0e32, 0x0e33, 0x0e40, 0x0e46, 0x0e4f, 0x0e5b, 0x0e81, 0x0e82, 0x0e84, 0x0e84, 0x0e87, 0x0e88, 0x0e8a, 0x0e8a, 0x0e8d, 0x0e8d, 0x0e94, 0x0e97, 0x0e99, 0x0e9f, 0x0ea1, 0x0ea3, 0x0ea5, 0x0ea5, 0x0ea7, 0x0ea7, 0x0eaa, 0x0eab, 0x0ead, 0x0eb0, 0x0eb2, 0x0eb3, 0x0ebd, 0x0ebd, 0x0ec0, 0x0ec4, 0x0ec6, 0x0ec6, 0x0ed0, 0x0ed9, 0x0edc, 0x0edd, 0x0f00, 0x0f17, 0x0f1a, 0x0f34, 0x0f36, 0x0f36, 0x0f38, 0x0f38, 0x0f3e, 0x0f47, 0x0f49, 0x0f6a, 0x0f7f, 0x0f7f, 0x0f85, 0x0f85, 0x0f88, 0x0f8b, 0x0fbe, 0x0fc5, 0x0fc7, 0x0fcc, 0x0fcf, 0x0fcf, 0x1000, 0x1021, 0x1023, 0x1027, 0x1029, 0x102a, 0x102c, 0x102c, 0x1031, 0x1031, 0x1038, 0x1038, 0x1040, 0x1057, 0x10a0, 0x10c5, 0x10d0, 0x10f8, 0x10fb, 0x10fb, 0x1100, 0x1159, 0x115f, 0x11a2, 0x11a8, 0x11f9, 0x1200, 0x1206, 0x1208, 0x1246, 0x1248, 0x1248, 0x124a, 0x124d, 0x1250, 0x1256, 0x1258, 0x1258, 0x125a, 0x125d, 0x1260, 0x1286, 0x1288, 0x1288, 0x128a, 0x128d, 0x1290, 0x12ae, 0x12b0, 0x12b0, 0x12b2, 0x12b5, 0x12b8, 0x12be, 0x12c0, 0x12c0, 0x12c2, 0x12c5, 0x12c8, 0x12ce, 0x12d0, 0x12d6, 0x12d8, 0x12ee, 0x12f0, 0x130e, 0x1310, 0x1310, 0x1312, 0x1315, 0x1318, 0x131e, 0x1320, 0x1346, 0x1348, 0x135a, 0x1361, 0x137c, 0x13a0, 0x13f4, 0x1401, 0x1676, 0x1681, 0x169a, 0x16a0, 0x16f0, 0x1700, 0x170c, 0x170e, 0x1711, 0x1720, 0x1731, 0x1735, 0x1736, 0x1740, 0x1751, 0x1760, 0x176c, 0x176e, 0x1770, 0x1780, 0x17b6, 0x17be, 0x17c5, 0x17c7, 0x17c8, 0x17d4, 0x17da, 0x17dc, 0x17dc, 0x17e0, 0x17e9, 0x1810, 0x1819, 0x1820, 0x1877, 0x1880, 0x18a8, 0x1e00, 0x1e9b, 0x1ea0, 0x1ef9, 0x1f00, 0x1f15, 0x1f18, 0x1f1d, 0x1f20, 0x1f45, 0x1f48, 0x1f4d, 0x1f50, 0x1f57, 0x1f59, 0x1f59, 0x1f5b, 0x1f5b, 0x1f5d, 0x1f5d, 0x1f5f, 0x1f7d, 0x1f80, 0x1fb4, 0x1fb6, 0x1fbc, 0x1fbe, 0x1fbe, 0x1fc2, 0x1fc4, 0x1fc6, 0x1fcc, 0x1fd0, 0x1fd3, 0x1fd6, 0x1fdb, 0x1fe0, 0x1fec, 0x1ff2, 0x1ff4, 0x1ff6, 0x1ffc, 0x200e, 0x200e, 0x2071, 0x2071, 0x207f, 0x207f, 0x2102, 0x2102, 0x2107, 0x2107, 0x210a, 0x2113, 0x2115, 0x2115, 0x2119, 0x211d, 0x2124, 0x2124, 0x2126, 0x2126, 0x2128, 0x2128, 0x212a, 0x212d, 0x212f, 0x2131, 0x2133, 0x2139, 0x213d, 0x213f, 0x2145, 0x2149, 0x2160, 0x2183, 0x2336, 0x237a, 0x2395, 0x2395, 0x249c, 0x24e9, 0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035, 0x3038, 0x303c, 0x3041, 0x3096, 0x309d, 0x309f, 0x30a1, 0x30fa, 0x30fc, 0x30ff, 0x3105, 0x312c, 0x3131, 0x318e, 0x3190, 0x31b7, 0x31f0, 0x321c, 0x3220, 0x3243, 0x3260, 0x327b, 0x327f, 0x32b0, 0x32c0, 0x32cb, 0x32d0, 0x32fe, 0x3300, 0x3376, 0x337b, 0x33dd, 0x33e0, 0x33fe, 0x3400, 0x4db5, 0x4e00, 0x9fa5, 0xa000, 0xa48c, 0xac00, 0xd7a3, 0xd800, 0xfa2d, 0xfa30, 0xfa6a, 0xfb00, 0xfb06, 0xfb13, 0xfb17, 0xff21, 0xff3a, 0xff41, 0xff5a, 0xff66, 0xffbe, 0xffc2, 0xffc7, 0xffca, 0xffcf, 0xffd2, 0xffd7, 0xffda, 0xffdc, 0x10300, 0x1031e, 0x10320, 0x10323, 0x10330, 0x1034a, 0x10400, 0x10425, 0x10428, 0x1044d, 0x1d000, 0x1d0f5, 0x1d100, 0x1d126, 0x1d12a, 0x1d166, 0x1d16a, 0x1d172, 0x1d183, 0x1d184, 0x1d18c, 0x1d1a9, 0x1d1ae, 0x1d1dd, 0x1d400, 0x1d454, 0x1d456, 0x1d49c, 0x1d49e, 0x1d49f, 0x1d4a2, 0x1d4a2, 0x1d4a5, 0x1d4a6, 0x1d4a9, 0x1d4ac, 0x1d4ae, 0x1d4b9, 0x1d4bb, 0x1d4bb, 0x1d4bd, 0x1d4c0, 0x1d4c2, 0x1d4c3, 0x1d4c5, 0x1d505, 0x1d507, 0x1d50a, 0x1d50d, 0x1d514, 0x1d516, 0x1d51c, 0x1d51e, 0x1d539, 0x1d53b, 0x1d53e, 0x1d540, 0x1d544, 0x1d546, 0x1d546, 0x1d54a, 0x1d550, 0x1d552, 0x1d6a3, 0x1d6a8, 0x1d7c9, 0x20000, 0x2a6d6, 0x2f800, 0x2fa1d, 0xf0000, 0xffffd, 0x100000, 0x10fffd];\nconst isBidirectionalL = character => inRange(character, bidirectional_l);\n\nconst mapping2space = isNonASCIISpaceCharacter;\nconst mapping2nothing = isCommonlyMappedToNothing;\nconst getCodePoint = character => character.codePointAt(0);\nconst first = x => x[0];\nconst last = x => x[x.length - 1];\nfunction toCodePoints(input) {\n  const codepoints = [];\n  const size = input.length;\n  for (let i = 0; i < size; i += 1) {\n    const before = input.charCodeAt(i);\n    if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {\n      const next = input.charCodeAt(i + 1);\n      if (next >= 0xdc00 && next <= 0xdfff) {\n        codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);\n        i += 1;\n        continue;\n      }\n    }\n    codepoints.push(before);\n  }\n  return codepoints;\n}\nfunction saslprep(input) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected string.');\n  }\n  if (input.length === 0) {\n    return '';\n  }\n  const mapped_input = toCodePoints(input).map(character => mapping2space(character) ? 0x20 : character).filter(character => !mapping2nothing(character));\n  const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize('NFKC');\n  const normalized_map = toCodePoints(normalized_input);\n  const hasProhibited = normalized_map.some(isProhibitedCharacter);\n  if (hasProhibited) {\n    throw new Error('Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3');\n  }\n  if (opts.allowUnassigned !== true) {\n    const hasUnassigned = normalized_map.some(isUnassignedCodePoint);\n    if (hasUnassigned) {\n      throw new Error('Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5');\n    }\n  }\n  const hasBidiRAL = normalized_map.some(isBidirectionalRAL);\n  const hasBidiL = normalized_map.some(isBidirectionalL);\n  if (hasBidiRAL && hasBidiL) {\n    throw new Error('String must not contain RandALCat and LCat at the same time,' + ' see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n  const isFirstBidiRAL = isBidirectionalRAL(getCodePoint(first(normalized_input)));\n  const isLastBidiRAL = isBidirectionalRAL(getCodePoint(last(normalized_input)));\n  if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {\n    throw new Error('Bidirectional RandALCat character must be the first and the last' + ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n  return normalized_input;\n}\n\nclass PDFSecurity {\n  static generateFileID() {\n    let info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let infoStr = `${info.CreationDate.getTime()}\\n`;\n    for (let key in info) {\n      if (!info.hasOwnProperty(key)) {\n        continue;\n      }\n      infoStr += `${key}: ${info[key].valueOf()}\\n`;\n    }\n    return wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(infoStr));\n  }\n  static generateRandomWordArray(bytes) {\n    return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.random(bytes);\n  }\n  static create(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options.ownerPassword && !options.userPassword) {\n      return null;\n    }\n    return new PDFSecurity(document, options);\n  }\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options.ownerPassword && !options.userPassword) {\n      throw new Error('None of owner password and user password is defined.');\n    }\n    this.document = document;\n    this._setupEncryption(options);\n  }\n  _setupEncryption(options) {\n    switch (options.pdfVersion) {\n      case '1.4':\n      case '1.5':\n        this.version = 2;\n        break;\n      case '1.6':\n      case '1.7':\n        this.version = 4;\n        break;\n      case '1.7ext3':\n        this.version = 5;\n        break;\n      default:\n        this.version = 1;\n        break;\n    }\n    const encDict = {\n      Filter: 'Standard'\n    };\n    switch (this.version) {\n      case 1:\n      case 2:\n      case 4:\n        this._setupEncryptionV1V2V4(this.version, encDict, options);\n        break;\n      case 5:\n        this._setupEncryptionV5(encDict, options);\n        break;\n    }\n    this.dictionary = this.document.ref(encDict);\n  }\n  _setupEncryptionV1V2V4(v, encDict, options) {\n    let r, permissions;\n    switch (v) {\n      case 1:\n        r = 2;\n        this.keyBits = 40;\n        permissions = getPermissionsR2(options.permissions);\n        break;\n      case 2:\n        r = 3;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n      case 4:\n        r = 4;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n    }\n    const paddedUserPassword = processPasswordR2R3R4(options.userPassword);\n    const paddedOwnerPassword = options.ownerPassword ? processPasswordR2R3R4(options.ownerPassword) : paddedUserPassword;\n    const ownerPasswordEntry = getOwnerPasswordR2R3R4(r, this.keyBits, paddedUserPassword, paddedOwnerPassword);\n    this.encryptionKey = getEncryptionKeyR2R3R4(r, this.keyBits, this.document._id, paddedUserPassword, ownerPasswordEntry, permissions);\n    let userPasswordEntry;\n    if (r === 2) {\n      userPasswordEntry = getUserPasswordR2(this.encryptionKey);\n    } else {\n      userPasswordEntry = getUserPasswordR3R4(this.document._id, this.encryptionKey);\n    }\n    encDict.V = v;\n    if (v >= 2) {\n      encDict.Length = this.keyBits;\n    }\n    if (v === 4) {\n      encDict.CF = {\n        StdCF: {\n          AuthEvent: 'DocOpen',\n          CFM: 'AESV2',\n          Length: this.keyBits / 8\n        }\n      };\n      encDict.StmF = 'StdCF';\n      encDict.StrF = 'StdCF';\n    }\n    encDict.R = r;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.P = permissions;\n  }\n  _setupEncryptionV5(encDict, options) {\n    this.keyBits = 256;\n    const permissions = getPermissionsR3(options.permissions);\n    const processedUserPassword = processPasswordR5(options.userPassword);\n    const processedOwnerPassword = options.ownerPassword ? processPasswordR5(options.ownerPassword) : processedUserPassword;\n    this.encryptionKey = getEncryptionKeyR5(PDFSecurity.generateRandomWordArray);\n    const userPasswordEntry = getUserPasswordR5(processedUserPassword, PDFSecurity.generateRandomWordArray);\n    const userKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(userPasswordEntry.words.slice(10, 12), 8);\n    const userEncryptionKeyEntry = getUserEncryptionKeyR5(processedUserPassword, userKeySalt, this.encryptionKey);\n    const ownerPasswordEntry = getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, PDFSecurity.generateRandomWordArray);\n    const ownerKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(ownerPasswordEntry.words.slice(10, 12), 8);\n    const ownerEncryptionKeyEntry = getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, this.encryptionKey);\n    const permsEntry = getEncryptedPermissionsR5(permissions, this.encryptionKey, PDFSecurity.generateRandomWordArray);\n    encDict.V = 5;\n    encDict.Length = this.keyBits;\n    encDict.CF = {\n      StdCF: {\n        AuthEvent: 'DocOpen',\n        CFM: 'AESV3',\n        Length: this.keyBits / 8\n      }\n    };\n    encDict.StmF = 'StdCF';\n    encDict.StrF = 'StdCF';\n    encDict.R = 5;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.OE = wordArrayToBuffer(ownerEncryptionKeyEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.UE = wordArrayToBuffer(userEncryptionKeyEntry);\n    encDict.P = permissions;\n    encDict.Perms = wordArrayToBuffer(permsEntry);\n  }\n  getEncryptFn(obj, gen) {\n    let digest;\n    if (this.version < 5) {\n      digest = this.encryptionKey.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([(obj & 0xff) << 24 | (obj & 0xff00) << 8 | obj >> 8 & 0xff00 | gen & 0xff, (gen & 0xff00) << 16], 5));\n    }\n    if (this.version === 1 || this.version === 2) {\n      let key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest);\n      key.sigBytes = Math.min(16, this.keyBits / 8 + 5);\n      return buffer => wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(buffer), key).ciphertext);\n    }\n    let key;\n    if (this.version === 4) {\n      key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest.concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([0x73416c54], 4)));\n    } else {\n      key = this.encryptionKey;\n    }\n    const iv = PDFSecurity.generateRandomWordArray(16);\n    const options = {\n      mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n      padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).Pkcs7,\n      iv\n    };\n    return buffer => wordArrayToBuffer(iv.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(buffer), key, options).ciphertext));\n  }\n  end() {\n    this.dictionary.end();\n  }\n}\nfunction getPermissionsR2() {\n  let permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let permissions = 0xffffffc0 >> 0;\n  if (permissionObject.printing) {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  return permissions;\n}\nfunction getPermissionsR3() {\n  let permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let permissions = 0xfffff0c0 >> 0;\n  if (permissionObject.printing === 'lowResolution') {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.printing === 'highResolution') {\n    permissions |= 0b100000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  if (permissionObject.fillingForms) {\n    permissions |= 0b000100000000;\n  }\n  if (permissionObject.contentAccessibility) {\n    permissions |= 0b001000000000;\n  }\n  if (permissionObject.documentAssembly) {\n    permissions |= 0b010000000000;\n  }\n  return permissions;\n}\nfunction getUserPasswordR2(encryptionKey) {\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(processPasswordR2R3R4(), encryptionKey).ciphertext;\n}\nfunction getUserPasswordR3R4(documentId, encryptionKey) {\n  const key = encryptionKey.clone();\n  let cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(processPasswordR2R3R4().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(documentId)));\n  for (let i = 0; i < 20; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] = encryptionKey.words[j] ^ (i | i << 8 | i << 16 | i << 24);\n    }\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher.concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16));\n}\nfunction getOwnerPasswordR2R3R4(r, keyBits, paddedUserPassword, paddedOwnerPassword) {\n  let digest = paddedOwnerPassword;\n  let round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    digest = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest);\n  }\n  const key = digest.clone();\n  key.sigBytes = keyBits / 8;\n  let cipher = paddedUserPassword;\n  round = r >= 3 ? 20 : 1;\n  for (let i = 0; i < round; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] = digest.words[j] ^ (i | i << 8 | i << 16 | i << 24);\n    }\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher;\n}\nfunction getEncryptionKeyR2R3R4(r, keyBits, documentId, paddedUserPassword, ownerPasswordEntry, permissions) {\n  let key = paddedUserPassword.clone().concat(ownerPasswordEntry).concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([lsbFirstWord(permissions)], 4)).concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(documentId));\n  const round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(key);\n    key.sigBytes = keyBits / 8;\n  }\n  return key;\n}\nfunction getUserPasswordR5(processedUserPassword, generateRandomWordArray) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedUserPassword.clone().concat(validationSalt)).concat(validationSalt).concat(keySalt);\n}\nfunction getUserEncryptionKeyR5(processedUserPassword, userKeySalt, encryptionKey) {\n  const key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedUserPassword.clone().concat(userKeySalt));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\nfunction getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, generateRandomWordArray) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedOwnerPassword.clone().concat(validationSalt).concat(userPasswordEntry)).concat(validationSalt).concat(keySalt);\n}\nfunction getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, encryptionKey) {\n  const key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedOwnerPassword.clone().concat(ownerKeySalt).concat(userPasswordEntry));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\nfunction getEncryptionKeyR5(generateRandomWordArray) {\n  return generateRandomWordArray(32);\n}\nfunction getEncryptedPermissionsR5(permissions, encryptionKey, generateRandomWordArray) {\n  const cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([lsbFirstWord(permissions), 0xffffffff, 0x54616462], 12).concat(generateRandomWordArray(4));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).ECB,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(cipher, encryptionKey, options).ciphertext;\n}\nfunction processPasswordR2R3R4() {\n  let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  const out = Buffer.alloc(32);\n  const length = password.length;\n  let index = 0;\n  while (index < length && index < 32) {\n    const code = password.charCodeAt(index);\n    if (code > 0xff) {\n      throw new Error('Password contains one or more invalid characters.');\n    }\n    out[index] = code;\n    index++;\n  }\n  while (index < 32) {\n    out[index] = PASSWORD_PADDING[index - length];\n    index++;\n  }\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(out);\n}\nfunction processPasswordR5() {\n  let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  password = unescape(encodeURIComponent(saslprep(password)));\n  const length = Math.min(127, password.length);\n  const out = Buffer.alloc(length);\n  for (let i = 0; i < length; i++) {\n    out[i] = password.charCodeAt(i);\n  }\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(out);\n}\nfunction lsbFirstWord(data) {\n  return (data & 0xff) << 24 | (data & 0xff00) << 8 | data >> 8 & 0xff00 | data >> 24 & 0xff;\n}\nfunction wordArrayToBuffer(wordArray) {\n  const byteArray = [];\n  for (let i = 0; i < wordArray.sigBytes; i++) {\n    byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 0xff);\n  }\n  return Buffer.from(byteArray);\n}\nconst PASSWORD_PADDING = [0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a];\n\nconst {\n  number: number$2\n} = PDFObject;\nclass PDFGradient$1 {\n  constructor(doc) {\n    this.doc = doc;\n    this.stops = [];\n    this.embedded = false;\n    this.transform = [1, 0, 0, 1, 0, 0];\n  }\n  stop(pos, color, opacity) {\n    if (opacity == null) {\n      opacity = 1;\n    }\n    color = this.doc._normalizeColor(color);\n    if (this.stops.length === 0) {\n      if (color.length === 3) {\n        this._colorSpace = 'DeviceRGB';\n      } else if (color.length === 4) {\n        this._colorSpace = 'DeviceCMYK';\n      } else if (color.length === 1) {\n        this._colorSpace = 'DeviceGray';\n      } else {\n        throw new Error('Unknown color space');\n      }\n    } else if (this._colorSpace === 'DeviceRGB' && color.length !== 3 || this._colorSpace === 'DeviceCMYK' && color.length !== 4 || this._colorSpace === 'DeviceGray' && color.length !== 1) {\n      throw new Error('All gradient stops must use the same color space');\n    }\n    opacity = Math.max(0, Math.min(1, opacity));\n    this.stops.push([pos, color, opacity]);\n    return this;\n  }\n  setTransform(m11, m12, m21, m22, dx, dy) {\n    this.transform = [m11, m12, m21, m22, dx, dy];\n    return this;\n  }\n  embed(m) {\n    let fn;\n    const stopsLength = this.stops.length;\n    if (stopsLength === 0) {\n      return;\n    }\n    this.embedded = true;\n    this.matrix = m;\n    const last = this.stops[stopsLength - 1];\n    if (last[0] < 1) {\n      this.stops.push([1, last[1], last[2]]);\n    }\n    const bounds = [];\n    const encode = [];\n    const stops = [];\n    for (let i = 0; i < stopsLength - 1; i++) {\n      encode.push(0, 1);\n      if (i + 2 !== stopsLength) {\n        bounds.push(this.stops[i + 1][0]);\n      }\n      fn = this.doc.ref({\n        FunctionType: 2,\n        Domain: [0, 1],\n        C0: this.stops[i + 0][1],\n        C1: this.stops[i + 1][1],\n        N: 1\n      });\n      stops.push(fn);\n      fn.end();\n    }\n    if (stopsLength === 1) {\n      fn = stops[0];\n    } else {\n      fn = this.doc.ref({\n        FunctionType: 3,\n        Domain: [0, 1],\n        Functions: stops,\n        Bounds: bounds,\n        Encode: encode\n      });\n      fn.end();\n    }\n    this.id = `Sh${++this.doc._gradCount}`;\n    const shader = this.shader(fn);\n    shader.end();\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 2,\n      Shading: shader,\n      Matrix: this.matrix.map(number$2)\n    });\n    pattern.end();\n    if (this.stops.some(stop => stop[2] < 1)) {\n      let grad = this.opacityGradient();\n      grad._colorSpace = 'DeviceGray';\n      for (let stop of this.stops) {\n        grad.stop(stop[0], [stop[2]]);\n      }\n      grad = grad.embed(this.matrix);\n      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];\n      const form = this.doc.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        FormType: 1,\n        BBox: pageBBox,\n        Group: {\n          Type: 'Group',\n          S: 'Transparency',\n          CS: 'DeviceGray'\n        },\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: grad\n          }\n        }\n      });\n      form.write('/Pattern cs /Sh1 scn');\n      form.end(`${pageBBox.join(' ')} re f`);\n      const gstate = this.doc.ref({\n        Type: 'ExtGState',\n        SMask: {\n          Type: 'Mask',\n          S: 'Luminosity',\n          G: form\n        }\n      });\n      gstate.end();\n      const opacityPattern = this.doc.ref({\n        Type: 'Pattern',\n        PatternType: 1,\n        PaintType: 1,\n        TilingType: 2,\n        BBox: pageBBox,\n        XStep: pageBBox[2],\n        YStep: pageBBox[3],\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: pattern\n          },\n          ExtGState: {\n            Gs1: gstate\n          }\n        }\n      });\n      opacityPattern.write('/Gs1 gs /Pattern cs /Sh1 scn');\n      opacityPattern.end(`${pageBBox.join(' ')} re f`);\n      this.doc.page.patterns[this.id] = opacityPattern;\n    } else {\n      this.doc.page.patterns[this.id] = pattern;\n    }\n    return pattern;\n  }\n  apply(stroke) {\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = this.transform;\n    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n    if (!this.embedded || m.join(' ') !== this.matrix.join(' ')) {\n      this.embed(m);\n    }\n    this.doc._setColorSpace('Pattern', stroke);\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(`/${this.id} ${op}`);\n  }\n}\nclass PDFLinearGradient$1 extends PDFGradient$1 {\n  constructor(doc, x1, y1, x2, y2) {\n    super(doc);\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 2,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.x2, this.y2],\n      Function: fn,\n      Extend: [true, true]\n    });\n  }\n  opacityGradient() {\n    return new PDFLinearGradient$1(this.doc, this.x1, this.y1, this.x2, this.y2);\n  }\n}\nclass PDFRadialGradient$1 extends PDFGradient$1 {\n  constructor(doc, x1, y1, r1, x2, y2, r2) {\n    super(doc);\n    this.doc = doc;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.r1 = r1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.r2 = r2;\n  }\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 3,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],\n      Function: fn,\n      Extend: [true, true]\n    });\n  }\n  opacityGradient() {\n    return new PDFRadialGradient$1(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);\n  }\n}\nvar Gradient = {\n  PDFGradient: PDFGradient$1,\n  PDFLinearGradient: PDFLinearGradient$1,\n  PDFRadialGradient: PDFRadialGradient$1\n};\n\nconst underlyingColorSpaces = ['DeviceCMYK', 'DeviceRGB'];\nclass PDFTilingPattern$1 {\n  constructor(doc, bBox, xStep, yStep, stream) {\n    this.doc = doc;\n    this.bBox = bBox;\n    this.xStep = xStep;\n    this.yStep = yStep;\n    this.stream = stream;\n  }\n  createPattern() {\n    const resources = this.doc.ref();\n    resources.end();\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];\n    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 1,\n      PaintType: 2,\n      TilingType: 2,\n      BBox: this.bBox,\n      XStep: this.xStep,\n      YStep: this.yStep,\n      Matrix: m.map(v => +v.toFixed(5)),\n      Resources: resources\n    });\n    pattern.end(this.stream);\n    return pattern;\n  }\n  embedPatternColorSpaces() {\n    underlyingColorSpaces.forEach(csName => {\n      const csId = this.getPatternColorSpaceId(csName);\n      if (this.doc.page.colorSpaces[csId]) return;\n      const cs = this.doc.ref(['Pattern', csName]);\n      cs.end();\n      this.doc.page.colorSpaces[csId] = cs;\n    });\n  }\n  getPatternColorSpaceId(underlyingColorspace) {\n    return `CsP${underlyingColorspace}`;\n  }\n  embed() {\n    if (!this.id) {\n      this.doc._patternCount = this.doc._patternCount + 1;\n      this.id = 'P' + this.doc._patternCount;\n      this.pattern = this.createPattern();\n    }\n    if (!this.doc.page.patterns[this.id]) {\n      this.doc.page.patterns[this.id] = this.pattern;\n    }\n  }\n  apply(stroke, patternColor) {\n    this.embedPatternColorSpaces();\n    this.embed();\n    const normalizedColor = this.doc._normalizeColor(patternColor);\n    if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);\n    const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));\n    this.doc._setColorSpace(csId, stroke);\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(`${normalizedColor.join(' ')} /${this.id} ${op}`);\n  }\n}\nvar pattern = {\n  PDFTilingPattern: PDFTilingPattern$1\n};\n\nconst {\n  PDFGradient,\n  PDFLinearGradient,\n  PDFRadialGradient\n} = Gradient;\nconst {\n  PDFTilingPattern\n} = pattern;\nvar ColorMixin = {\n  initColor() {\n    this.spotColors = {};\n    this._opacityRegistry = {};\n    this._opacityCount = 0;\n    this._patternCount = 0;\n    this._gradCount = 0;\n  },\n  _normalizeColor(color) {\n    if (typeof color === 'string') {\n      if (color.charAt(0) === '#') {\n        if (color.length === 4) {\n          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, '#$1$1$2$2$3$3');\n        }\n        const hex = parseInt(color.slice(1), 16);\n        color = [hex >> 16, hex >> 8 & 0xff, hex & 0xff];\n      } else if (namedColors[color]) {\n        color = namedColors[color];\n      } else if (this.spotColors[color]) {\n        return this.spotColors[color];\n      }\n    }\n    if (Array.isArray(color)) {\n      if (color.length === 3) {\n        color = color.map(part => part / 255);\n      } else if (color.length === 4) {\n        color = color.map(part => part / 100);\n      }\n      return color;\n    }\n    return null;\n  },\n  _setColor(color, stroke) {\n    if (color instanceof PDFGradient) {\n      color.apply(stroke);\n      return true;\n    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern) {\n      color[0].apply(stroke, color[1]);\n      return true;\n    }\n    return this._setColorCore(color, stroke);\n  },\n  _setColorCore(color, stroke) {\n    color = this._normalizeColor(color);\n    if (!color) {\n      return false;\n    }\n    const op = stroke ? 'SCN' : 'scn';\n    const space = this._getColorSpace(color);\n    this._setColorSpace(space, stroke);\n    if (color instanceof SpotColor) {\n      this.page.colorSpaces[color.id] = color.ref;\n      this.addContent(`1 ${op}`);\n    } else {\n      this.addContent(`${color.join(' ')} ${op}`);\n    }\n    return true;\n  },\n  _setColorSpace(space, stroke) {\n    const op = stroke ? 'CS' : 'cs';\n    return this.addContent(`/${space} ${op}`);\n  },\n  _getColorSpace(color) {\n    if (color instanceof SpotColor) {\n      return color.id;\n    }\n    return color.length === 4 ? 'DeviceCMYK' : 'DeviceRGB';\n  },\n  fillColor(color, opacity) {\n    const set = this._setColor(color, false);\n    if (set) {\n      this.fillOpacity(opacity);\n    }\n    this._fillColor = [color, opacity];\n    return this;\n  },\n  strokeColor(color, opacity) {\n    const set = this._setColor(color, true);\n    if (set) {\n      this.strokeOpacity(opacity);\n    }\n    return this;\n  },\n  opacity(opacity) {\n    this._doOpacity(opacity, opacity);\n    return this;\n  },\n  fillOpacity(opacity) {\n    this._doOpacity(opacity, null);\n    return this;\n  },\n  strokeOpacity(opacity) {\n    this._doOpacity(null, opacity);\n    return this;\n  },\n  _doOpacity(fillOpacity, strokeOpacity) {\n    let dictionary, name;\n    if (fillOpacity == null && strokeOpacity == null) {\n      return;\n    }\n    if (fillOpacity != null) {\n      fillOpacity = Math.max(0, Math.min(1, fillOpacity));\n    }\n    if (strokeOpacity != null) {\n      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));\n    }\n    const key = `${fillOpacity}_${strokeOpacity}`;\n    if (this._opacityRegistry[key]) {\n      [dictionary, name] = this._opacityRegistry[key];\n    } else {\n      dictionary = {\n        Type: 'ExtGState'\n      };\n      if (fillOpacity != null) {\n        dictionary.ca = fillOpacity;\n      }\n      if (strokeOpacity != null) {\n        dictionary.CA = strokeOpacity;\n      }\n      dictionary = this.ref(dictionary);\n      dictionary.end();\n      const id = ++this._opacityCount;\n      name = `Gs${id}`;\n      this._opacityRegistry[key] = [dictionary, name];\n    }\n    this.page.ext_gstates[name] = dictionary;\n    return this.addContent(`/${name} gs`);\n  },\n  linearGradient(x1, y1, x2, y2) {\n    return new PDFLinearGradient(this, x1, y1, x2, y2);\n  },\n  radialGradient(x1, y1, r1, x2, y2, r2) {\n    return new PDFRadialGradient(this, x1, y1, r1, x2, y2, r2);\n  },\n  pattern(bbox, xStep, yStep, stream) {\n    return new PDFTilingPattern(this, bbox, xStep, yStep, stream);\n  },\n  addSpotColor(name, C, M, Y, K) {\n    const color = new SpotColor(this, name, C, M, Y, K);\n    this.spotColors[name] = color;\n    return this;\n  }\n};\nvar namedColors = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\n\nlet cx, cy, px, py, sx, sy;\ncx = cy = px = py = sx = sy = 0;\nconst parameters = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\nconst parse = function (path) {\n  let cmd;\n  const ret = [];\n  let args = [];\n  let curArg = '';\n  let foundDecimal = false;\n  let params = 0;\n  for (let c of path) {\n    if (parameters[c] != null) {\n      params = parameters[c];\n      if (cmd) {\n        if (curArg.length > 0) {\n          args[args.length] = +curArg;\n        }\n        ret[ret.length] = {\n          cmd,\n          args\n        };\n        args = [];\n        curArg = '';\n        foundDecimal = false;\n      }\n      cmd = c;\n    } else if ([' ', ','].includes(c) || c === '-' && curArg.length > 0 && curArg[curArg.length - 1] !== 'e' || c === '.' && foundDecimal) {\n      if (curArg.length === 0) {\n        continue;\n      }\n      if (args.length === params) {\n        ret[ret.length] = {\n          cmd,\n          args\n        };\n        args = [+curArg];\n        if (cmd === 'M') {\n          cmd = 'L';\n        }\n        if (cmd === 'm') {\n          cmd = 'l';\n        }\n      } else {\n        args[args.length] = +curArg;\n      }\n      foundDecimal = c === '.';\n      curArg = ['-', '.'].includes(c) ? c : '';\n    } else {\n      curArg += c;\n      if (c === '.') {\n        foundDecimal = true;\n      }\n    }\n  }\n  if (curArg.length > 0) {\n    if (args.length === params) {\n      ret[ret.length] = {\n        cmd,\n        args\n      };\n      args = [+curArg];\n      if (cmd === 'M') {\n        cmd = 'L';\n      }\n      if (cmd === 'm') {\n        cmd = 'l';\n      }\n    } else {\n      args[args.length] = +curArg;\n    }\n  }\n  ret[ret.length] = {\n    cmd,\n    args\n  };\n  return ret;\n};\nconst apply = function (commands, doc) {\n  cx = cy = px = py = sx = sy = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const c = commands[i];\n    if (typeof runners[c.cmd] === 'function') {\n      runners[c.cmd](doc, c.args);\n    }\n  }\n};\nconst runners = {\n  M(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  m(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  C(doc, a) {\n    cx = a[4];\n    cy = a[5];\n    px = a[2];\n    py = a[3];\n    return doc.bezierCurveTo(...a);\n  },\n  c(doc, a) {\n    doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);\n    px = cx + a[2];\n    py = cy + a[3];\n    cx += a[4];\n    return cy += a[5];\n  },\n  S(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    return cy = a[3];\n  },\n  s(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  Q(doc, a) {\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    cy = a[3];\n    return doc.quadraticCurveTo(a[0], a[1], cx, cy);\n  },\n  q(doc, a) {\n    doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  T(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n    doc.quadraticCurveTo(px, py, a[0], a[1]);\n    px = cx - (px - cx);\n    py = cy - (py - cy);\n    cx = a[0];\n    return cy = a[1];\n  },\n  t(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n    doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);\n    cx += a[0];\n    return cy += a[1];\n  },\n  A(doc, a) {\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return cy = a[6];\n  },\n  a(doc, a) {\n    a[5] += cx;\n    a[6] += cy;\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return cy = a[6];\n  },\n  L(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  l(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  H(doc, a) {\n    cx = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  h(doc, a) {\n    cx += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  V(doc, a) {\n    cy = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  v(doc, a) {\n    cy += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  Z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  },\n  z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  }\n};\nconst solveArc = function (doc, x, y, coords) {\n  const [rx, ry, rot, large, sweep, ex, ey] = coords;\n  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (let seg of segs) {\n    const bez = segmentToBezier(...seg);\n    doc.bezierCurveTo(...bez);\n  }\n};\nconst arcToSegments = function (x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const th = rotateX * (Math.PI / 180);\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) {\n    sfactor_sq = 0;\n  }\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep === large) {\n    sfactor = -sfactor;\n  }\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  const result = [];\n  for (let i = 0; i < segments; i++) {\n    const th2 = th0 + i * th_arc / segments;\n    const th3 = th0 + (i + 1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n  return result;\n};\nconst segmentToBezier = function (cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const th_half = 0.5 * (th1 - th0);\n  const t = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);\n  const x1 = cx + Math.cos(th0) - t * Math.sin(th0);\n  const y1 = cy + Math.sin(th0) + t * Math.cos(th0);\n  const x3 = cx + Math.cos(th1);\n  const y3 = cy + Math.sin(th1);\n  const x2 = x3 + t * Math.sin(th1);\n  const y2 = y3 - t * Math.cos(th1);\n  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n};\nclass SVGPath {\n  static apply(doc, path) {\n    const commands = parse(path);\n    apply(commands, doc);\n  }\n}\n\nconst {\n  number: number$1\n} = PDFObject;\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar VectorMixin = {\n  initVector() {\n    this._ctm = [1, 0, 0, 1, 0, 0];\n    this._ctmStack = [];\n  },\n  save() {\n    this._ctmStack.push(this._ctm.slice());\n    return this.addContent('q');\n  },\n  restore() {\n    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];\n    return this.addContent('Q');\n  },\n  closePath() {\n    return this.addContent('h');\n  },\n  lineWidth(w) {\n    return this.addContent(`${number$1(w)} w`);\n  },\n  _CAP_STYLES: {\n    BUTT: 0,\n    ROUND: 1,\n    SQUARE: 2\n  },\n  lineCap(c) {\n    if (typeof c === 'string') {\n      c = this._CAP_STYLES[c.toUpperCase()];\n    }\n    return this.addContent(`${c} J`);\n  },\n  _JOIN_STYLES: {\n    MITER: 0,\n    ROUND: 1,\n    BEVEL: 2\n  },\n  lineJoin(j) {\n    if (typeof j === 'string') {\n      j = this._JOIN_STYLES[j.toUpperCase()];\n    }\n    return this.addContent(`${j} j`);\n  },\n  miterLimit(m) {\n    return this.addContent(`${number$1(m)} M`);\n  },\n  dash(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const originalLength = length;\n    if (!Array.isArray(length)) {\n      length = [length, options.space || length];\n    }\n    const valid = length.every(x => Number.isFinite(x) && x > 0);\n    if (!valid) {\n      throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);\n    }\n    length = length.map(number$1).join(' ');\n    return this.addContent(`[${length}] ${number$1(options.phase || 0)} d`);\n  },\n  undash() {\n    return this.addContent('[] 0 d');\n  },\n  moveTo(x, y) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} m`);\n  },\n  lineTo(x, y) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} l`);\n  },\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y)} c`);\n  },\n  quadraticCurveTo(cpx, cpy, x, y) {\n    return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y)} v`);\n  },\n  rect(x, y, w, h) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} ${number$1(w)} ${number$1(h)} re`);\n  },\n  roundedRect(x, y, w, h, r) {\n    if (r == null) {\n      r = 0;\n    }\n    r = Math.min(r, 0.5 * w, 0.5 * h);\n    const c = r * (1.0 - KAPPA);\n    this.moveTo(x + r, y);\n    this.lineTo(x + w - r, y);\n    this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);\n    this.lineTo(x + w, y + h - r);\n    this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);\n    this.lineTo(x + r, y + h);\n    this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);\n    this.lineTo(x, y + r);\n    this.bezierCurveTo(x, y + c, x + c, y, x + r, y);\n    return this.closePath();\n  },\n  ellipse(x, y, r1, r2) {\n    if (r2 == null) {\n      r2 = r1;\n    }\n    x -= r1;\n    y -= r2;\n    const ox = r1 * KAPPA;\n    const oy = r2 * KAPPA;\n    const xe = x + r1 * 2;\n    const ye = y + r2 * 2;\n    const xm = x + r1;\n    const ym = y + r2;\n    this.moveTo(x, ym);\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    return this.closePath();\n  },\n  circle(x, y, radius) {\n    return this.ellipse(x, y, radius);\n  },\n  arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise == null) {\n      anticlockwise = false;\n    }\n    const TWO_PI = 2.0 * Math.PI;\n    const HALF_PI = 0.5 * Math.PI;\n    let deltaAng = endAngle - startAngle;\n    if (Math.abs(deltaAng) > TWO_PI) {\n      deltaAng = TWO_PI;\n    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {\n      const dir = anticlockwise ? -1 : 1;\n      deltaAng = dir * TWO_PI + deltaAng;\n    }\n    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);\n    const segAng = deltaAng / numSegs;\n    const handleLen = segAng / HALF_PI * KAPPA * radius;\n    let curAng = startAngle;\n    let deltaCx = -Math.sin(curAng) * handleLen;\n    let deltaCy = Math.cos(curAng) * handleLen;\n    let ax = x + Math.cos(curAng) * radius;\n    let ay = y + Math.sin(curAng) * radius;\n    this.moveTo(ax, ay);\n    for (let segIdx = 0; segIdx < numSegs; segIdx++) {\n      const cp1x = ax + deltaCx;\n      const cp1y = ay + deltaCy;\n      curAng += segAng;\n      ax = x + Math.cos(curAng) * radius;\n      ay = y + Math.sin(curAng) * radius;\n      deltaCx = -Math.sin(curAng) * handleLen;\n      deltaCy = Math.cos(curAng) * handleLen;\n      const cp2x = ax - deltaCx;\n      const cp2y = ay - deltaCy;\n      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);\n    }\n    return this;\n  },\n  polygon() {\n    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {\n      points[_key] = arguments[_key];\n    }\n    this.moveTo(...(points.shift() || []));\n    for (let point of points) {\n      this.lineTo(...(point || []));\n    }\n    return this.closePath();\n  },\n  path(path) {\n    SVGPath.apply(this, path);\n    return this;\n  },\n  _windingRule(rule) {\n    if (/even-?odd/.test(rule)) {\n      return '*';\n    }\n    return '';\n  },\n  fill(color, rule) {\n    if (/(even-?odd)|(non-?zero)/.test(color)) {\n      rule = color;\n      color = null;\n    }\n    if (color) {\n      this.fillColor(color);\n    }\n    return this.addContent(`f${this._windingRule(rule)}`);\n  },\n  stroke(color) {\n    if (color) {\n      this.strokeColor(color);\n    }\n    return this.addContent('S');\n  },\n  fillAndStroke(fillColor, strokeColor, rule) {\n    if (strokeColor == null) {\n      strokeColor = fillColor;\n    }\n    const isFillRule = /(even-?odd)|(non-?zero)/;\n    if (isFillRule.test(fillColor)) {\n      rule = fillColor;\n      fillColor = null;\n    }\n    if (isFillRule.test(strokeColor)) {\n      rule = strokeColor;\n      strokeColor = fillColor;\n    }\n    if (fillColor) {\n      this.fillColor(fillColor);\n      this.strokeColor(strokeColor);\n    }\n    return this.addContent(`B${this._windingRule(rule)}`);\n  },\n  clip(rule) {\n    return this.addContent(`W${this._windingRule(rule)} n`);\n  },\n  transform(m11, m12, m21, m22, dx, dy) {\n    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {\n      return this;\n    }\n    const m = this._ctm;\n    const [m0, m1, m2, m3, m4, m5] = m;\n    m[0] = m0 * m11 + m2 * m12;\n    m[1] = m1 * m11 + m3 * m12;\n    m[2] = m0 * m21 + m2 * m22;\n    m[3] = m1 * m21 + m3 * m22;\n    m[4] = m0 * dx + m2 * dy + m4;\n    m[5] = m1 * dx + m3 * dy + m5;\n    const values = [m11, m12, m21, m22, dx, dy].map(v => number$1(v)).join(' ');\n    return this.addContent(`${values} cm`);\n  },\n  translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  },\n  rotate(angle) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let y;\n    const rad = angle * Math.PI / 180;\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    let x = y = 0;\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      const x1 = x * cos - y * sin;\n      const y1 = x * sin + y * cos;\n      x -= x1;\n      y -= y1;\n    }\n    return this.transform(cos, sin, -sin, cos, x, y);\n  },\n  scale(xFactor, yFactor) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let y;\n    if (yFactor == null) {\n      yFactor = xFactor;\n    }\n    if (typeof yFactor === 'object') {\n      options = yFactor;\n      yFactor = xFactor;\n    }\n    let x = y = 0;\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      x -= xFactor * x;\n      y -= yFactor * y;\n    }\n    return this.transform(xFactor, 0, 0, yFactor, x, y);\n  }\n};\n\nconst WIN_ANSI_MAP = {\n  402: 131,\n  8211: 150,\n  8212: 151,\n  8216: 145,\n  8217: 146,\n  8218: 130,\n  8220: 147,\n  8221: 148,\n  8222: 132,\n  8224: 134,\n  8225: 135,\n  8226: 149,\n  8230: 133,\n  8364: 128,\n  8240: 137,\n  8249: 139,\n  8250: 155,\n  710: 136,\n  8482: 153,\n  338: 140,\n  339: 156,\n  732: 152,\n  352: 138,\n  353: 154,\n  376: 159,\n  381: 142,\n  382: 158\n};\nconst characters = `\\\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n  \nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n  \nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n  \ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n  \nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n  \nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n  \nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n  \nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis\\\n`.split(/\\s+/);\nclass AFMFont {\n  constructor(contents) {\n    this.attributes = {};\n    this.glyphWidths = {};\n    this.boundingBoxes = {};\n    this.kernPairs = {};\n    this.parse(contents);\n    this.bbox = this.attributes['FontBBox'].split(/\\s+/).map(e => +e);\n    this.ascender = +(this.attributes['Ascender'] || 0);\n    this.descender = +(this.attributes['Descender'] || 0);\n    this.xHeight = +(this.attributes['XHeight'] || 0);\n    this.capHeight = +(this.attributes['CapHeight'] || 0);\n    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);\n  }\n  parse(contents) {\n    let section = '';\n    for (let line of contents.split('\\n')) {\n      var match;\n      var a;\n      if (match = line.match(/^Start(\\w+)/)) {\n        section = match[1];\n        continue;\n      } else if (match = line.match(/^End(\\w+)/)) {\n        section = '';\n        continue;\n      }\n      switch (section) {\n        case 'FontMetrics':\n          match = line.match(/(^\\w+)\\s+(.*)/);\n          var key = match[1];\n          var value = match[2];\n          if (a = this.attributes[key]) {\n            if (!Array.isArray(a)) {\n              a = this.attributes[key] = [a];\n            }\n            a.push(value);\n          } else {\n            this.attributes[key] = value;\n          }\n          break;\n        case 'CharMetrics':\n          if (!/^CH?\\s/.test(line)) {\n            continue;\n          }\n          var name = line.match(/\\bN\\s+(\\.?\\w+)\\s*;/)[1];\n          this.glyphWidths[name] = +line.match(/\\bWX\\s+(\\d+)\\s*;/)[1];\n          break;\n        case 'KernPairs':\n          match = line.match(/^KPX\\s+(\\.?\\w+)\\s+(\\.?\\w+)\\s+(-?\\d+)/);\n          if (match) {\n            this.kernPairs[match[1] + '\\0' + match[2]] = parseInt(match[3]);\n          }\n          break;\n      }\n    }\n  }\n  encodeText(text) {\n    const res = [];\n    for (let i = 0, len = text.length; i < len; i++) {\n      let char = text.charCodeAt(i);\n      char = WIN_ANSI_MAP[char] || char;\n      res.push(char.toString(16));\n    }\n    return res;\n  }\n  glyphsForString(string) {\n    const glyphs = [];\n    for (let i = 0, len = string.length; i < len; i++) {\n      const charCode = string.charCodeAt(i);\n      glyphs.push(this.characterToGlyph(charCode));\n    }\n    return glyphs;\n  }\n  characterToGlyph(character) {\n    return characters[WIN_ANSI_MAP[character] || character] || '.notdef';\n  }\n  widthOfGlyph(glyph) {\n    return this.glyphWidths[glyph] || 0;\n  }\n  getKernPair(left, right) {\n    return this.kernPairs[left + '\\0' + right] || 0;\n  }\n  advancesForGlyphs(glyphs) {\n    const advances = [];\n    for (let index = 0; index < glyphs.length; index++) {\n      const left = glyphs[index];\n      const right = glyphs[index + 1];\n      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));\n    }\n    return advances;\n  }\n}\n\nclass PDFFont {\n  constructor() {}\n  encode() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  widthOfString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  ref() {\n    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();\n  }\n  finalize() {\n    if (this.embedded || this.dictionary == null) {\n      return;\n    }\n    this.embed();\n    this.embedded = true;\n  }\n  embed() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  lineHeight(size) {\n    let includeGap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const gap = includeGap ? this.lineGap : 0;\n    return (this.ascender + gap - this.descender) / 1000 * size;\n  }\n}\n\nconst STANDARD_FONTS = {\n  Courier() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier.afm', 'utf8');\n  },\n  'Courier-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-Bold.afm', 'utf8');\n  },\n  'Courier-Oblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-Oblique.afm', 'utf8');\n  },\n  'Courier-BoldOblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-BoldOblique.afm', 'utf8');\n  },\n  Helvetica() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica.afm', 'utf8');\n  },\n  'Helvetica-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-Bold.afm', 'utf8');\n  },\n  'Helvetica-Oblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-Oblique.afm', 'utf8');\n  },\n  'Helvetica-BoldOblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-BoldOblique.afm', 'utf8');\n  },\n  'Times-Roman'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Roman.afm', 'utf8');\n  },\n  'Times-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Bold.afm', 'utf8');\n  },\n  'Times-Italic'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Italic.afm', 'utf8');\n  },\n  'Times-BoldItalic'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-BoldItalic.afm', 'utf8');\n  },\n  Symbol() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Symbol.afm', 'utf8');\n  },\n  ZapfDingbats() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/ZapfDingbats.afm', 'utf8');\n  }\n};\nclass StandardFont extends PDFFont {\n  constructor(document, name, id) {\n    super();\n    this.document = document;\n    this.name = name;\n    this.id = id;\n    this.font = new AFMFont(STANDARD_FONTS[this.name]());\n    ({\n      ascender: this.ascender,\n      descender: this.descender,\n      bbox: this.bbox,\n      lineGap: this.lineGap,\n      xHeight: this.xHeight,\n      capHeight: this.capHeight\n    } = this.font);\n  }\n  embed() {\n    this.dictionary.data = {\n      Type: 'Font',\n      BaseFont: this.name,\n      Subtype: 'Type1',\n      Encoding: 'WinAnsiEncoding'\n    };\n    return this.dictionary.end();\n  }\n  encode(text) {\n    const encoded = this.font.encodeText(text);\n    const glyphs = this.font.glyphsForString(`${text}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n    const positions = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      positions.push({\n        xAdvance: advances[i],\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n        advanceWidth: this.font.widthOfGlyph(glyph)\n      });\n    }\n    return [encoded, positions];\n  }\n  widthOfString(string, size) {\n    const glyphs = this.font.glyphsForString(`${string}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n    let width = 0;\n    for (let advance of advances) {\n      width += advance;\n    }\n    const scale = size / 1000;\n    return width * scale;\n  }\n  static isStandardFont(name) {\n    return name in STANDARD_FONTS;\n  }\n}\n\nconst toHex = function (num) {\n  return `0000${num.toString(16)}`.slice(-4);\n};\nclass EmbeddedFont extends PDFFont {\n  constructor(document, font, id) {\n    super();\n    this.document = document;\n    this.font = font;\n    this.id = id;\n    this.subset = this.font.createSubset();\n    this.unicode = [[0]];\n    this.widths = [this.font.getGlyph(0).advanceWidth];\n    this.name = this.font.postscriptName;\n    this.scale = 1000 / this.font.unitsPerEm;\n    this.ascender = this.font.ascent * this.scale;\n    this.descender = this.font.descent * this.scale;\n    this.xHeight = this.font.xHeight * this.scale;\n    this.capHeight = this.font.capHeight * this.scale;\n    this.lineGap = this.font.lineGap * this.scale;\n    this.bbox = this.font.bbox;\n    if (document.options.fontLayoutCache !== false) {\n      this.layoutCache = Object.create(null);\n    }\n  }\n  layoutRun(text, features) {\n    const run = this.font.layout(text, features);\n    for (let i = 0; i < run.positions.length; i++) {\n      const position = run.positions[i];\n      for (let key in position) {\n        position[key] *= this.scale;\n      }\n      position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;\n    }\n    return run;\n  }\n  layoutCached(text) {\n    if (!this.layoutCache) {\n      return this.layoutRun(text);\n    }\n    let cached;\n    if (cached = this.layoutCache[text]) {\n      return cached;\n    }\n    const run = this.layoutRun(text);\n    this.layoutCache[text] = run;\n    return run;\n  }\n  layout(text, features, onlyWidth) {\n    if (features) {\n      return this.layoutRun(text, features);\n    }\n    let glyphs = onlyWidth ? null : [];\n    let positions = onlyWidth ? null : [];\n    let advanceWidth = 0;\n    let last = 0;\n    let index = 0;\n    while (index <= text.length) {\n      var needle;\n      if (index === text.length && last < index || (needle = text.charAt(index), [' ', '\\t'].includes(needle))) {\n        const run = this.layoutCached(text.slice(last, ++index));\n        if (!onlyWidth) {\n          glyphs = glyphs.concat(run.glyphs);\n          positions = positions.concat(run.positions);\n        }\n        advanceWidth += run.advanceWidth;\n        last = index;\n      } else {\n        index++;\n      }\n    }\n    return {\n      glyphs,\n      positions,\n      advanceWidth\n    };\n  }\n  encode(text, features) {\n    const {\n      glyphs,\n      positions\n    } = this.layout(text, features);\n    const res = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      const gid = this.subset.includeGlyph(glyph.id);\n      res.push(`0000${gid.toString(16)}`.slice(-4));\n      if (this.widths[gid] == null) {\n        this.widths[gid] = glyph.advanceWidth * this.scale;\n      }\n      if (this.unicode[gid] == null) {\n        this.unicode[gid] = glyph.codePoints;\n      }\n    }\n    return [res, positions];\n  }\n  widthOfString(string, size, features) {\n    const width = this.layout(string, features, true).advanceWidth;\n    const scale = size / 1000;\n    return width * scale;\n  }\n  embed() {\n    const isCFF = this.subset.cff != null;\n    const fontFile = this.document.ref();\n    if (isCFF) {\n      fontFile.data.Subtype = 'CIDFontType0C';\n    }\n    fontFile.end(this.subset.encode());\n    const familyClass = ((this.font['OS/2'] != null ? this.font['OS/2'].sFamilyClass : undefined) || 0) >> 8;\n    let flags = 0;\n    if (this.font.post.isFixedPitch) {\n      flags |= 1 << 0;\n    }\n    if (1 <= familyClass && familyClass <= 7) {\n      flags |= 1 << 1;\n    }\n    flags |= 1 << 2;\n    if (familyClass === 10) {\n      flags |= 1 << 3;\n    }\n    if (this.font.head.macStyle.italic) {\n      flags |= 1 << 6;\n    }\n    const tag = [1, 2, 3, 4, 5, 6].map(i => String.fromCharCode((this.id.charCodeAt(i) || 73) + 17)).join('');\n    const name = tag + '+' + this.font.postscriptName?.replaceAll(' ', '_');\n    const {\n      bbox\n    } = this.font;\n    const descriptor = this.document.ref({\n      Type: 'FontDescriptor',\n      FontName: name,\n      Flags: flags,\n      FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],\n      ItalicAngle: this.font.italicAngle,\n      Ascent: this.ascender,\n      Descent: this.descender,\n      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,\n      XHeight: (this.font.xHeight || 0) * this.scale,\n      StemV: 0\n    });\n    if (isCFF) {\n      descriptor.data.FontFile3 = fontFile;\n    } else {\n      descriptor.data.FontFile2 = fontFile;\n    }\n    if (this.document.subset && this.document.subset === 1) {\n      const CIDSet = Buffer.from('FFFFFFFFC0', 'hex');\n      const CIDSetRef = this.document.ref();\n      CIDSetRef.write(CIDSet);\n      CIDSetRef.end();\n      descriptor.data.CIDSet = CIDSetRef;\n    }\n    descriptor.end();\n    const descendantFontData = {\n      Type: 'Font',\n      Subtype: 'CIDFontType0',\n      BaseFont: name,\n      CIDSystemInfo: {\n        Registry: new String('Adobe'),\n        Ordering: new String('Identity'),\n        Supplement: 0\n      },\n      FontDescriptor: descriptor,\n      W: [0, this.widths]\n    };\n    if (!isCFF) {\n      descendantFontData.Subtype = 'CIDFontType2';\n      descendantFontData.CIDToGIDMap = 'Identity';\n    }\n    const descendantFont = this.document.ref(descendantFontData);\n    descendantFont.end();\n    this.dictionary.data = {\n      Type: 'Font',\n      Subtype: 'Type0',\n      BaseFont: name,\n      Encoding: 'Identity-H',\n      DescendantFonts: [descendantFont],\n      ToUnicode: this.toUnicodeCmap()\n    };\n    return this.dictionary.end();\n  }\n  toUnicodeCmap() {\n    const cmap = this.document.ref();\n    const entries = [];\n    for (let codePoints of this.unicode) {\n      const encoded = [];\n      for (let value of codePoints) {\n        if (value > 0xffff) {\n          value -= 0x10000;\n          encoded.push(toHex(value >>> 10 & 0x3ff | 0xd800));\n          value = 0xdc00 | value & 0x3ff;\n        }\n        encoded.push(toHex(value));\n      }\n      entries.push(`<${encoded.join(' ')}>`);\n    }\n    const chunkSize = 256;\n    const chunks = Math.ceil(entries.length / chunkSize);\n    const ranges = [];\n    for (let i = 0; i < chunks; i++) {\n      const start = i * chunkSize;\n      const end = Math.min((i + 1) * chunkSize, entries.length);\n      ranges.push(`<${toHex(start)}> <${toHex(end - 1)}> [${entries.slice(start, end).join(' ')}]`);\n    }\n    cmap.end(`\\\n/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n${ranges.join('\\n')}\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\\\n`);\n    return cmap;\n  }\n}\n\nclass PDFFontFactory {\n  static open(document, src, family, id) {\n    let font;\n    if (typeof src === 'string') {\n      if (StandardFont.isStandardFont(src)) {\n        return new StandardFont(document, src, id);\n      }\n      src = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n    }\n    if (src instanceof Uint8Array) {\n      font = fontkit__WEBPACK_IMPORTED_MODULE_4__.create(src, family);\n    } else if (src instanceof ArrayBuffer) {\n      font = fontkit__WEBPACK_IMPORTED_MODULE_4__.create(new Uint8Array(src), family);\n    }\n    if (font == null) {\n      throw new Error('Not a supported font format or standard PDF font.');\n    }\n    return new EmbeddedFont(document, font, id);\n  }\n}\n\nconst isEqualFont = (font1, font2) => {\n  if (font1.font._tables?.head?.checkSumAdjustment !== font2.font._tables?.head?.checkSumAdjustment) {\n    return false;\n  }\n  if (JSON.stringify(font1.font._tables?.name?.records) !== JSON.stringify(font2.font._tables?.name?.records)) {\n    return false;\n  }\n  return true;\n};\nvar FontsMixin = {\n  initFonts() {\n    let defaultFont = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Helvetica';\n    let defaultFontFamily = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let defaultFontSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;\n    this._fontFamilies = {};\n    this._fontCount = 0;\n    this._fontSource = defaultFont;\n    this._fontFamily = defaultFontFamily;\n    this._fontSize = defaultFontSize;\n    this._font = null;\n    this._remSize = defaultFontSize;\n    this._registeredFonts = {};\n    if (defaultFont) {\n      this.font(defaultFont, defaultFontFamily);\n    }\n  },\n  font(src, family, size) {\n    let cacheKey, font;\n    if (typeof family === 'number') {\n      size = family;\n      family = null;\n    }\n    if (typeof src === 'string' && this._registeredFonts[src]) {\n      cacheKey = src;\n      ({\n        src,\n        family\n      } = this._registeredFonts[src]);\n    } else {\n      cacheKey = family || src;\n      if (typeof cacheKey !== 'string') {\n        cacheKey = null;\n      }\n    }\n    this._fontSource = src;\n    this._fontFamily = family;\n    if (size != null) {\n      this.fontSize(size);\n    }\n    if (font = this._fontFamilies[cacheKey]) {\n      this._font = font;\n      return this;\n    }\n    const id = `F${++this._fontCount}`;\n    this._font = PDFFontFactory.open(this, src, family, id);\n    if ((font = this._fontFamilies[this._font.name]) && isEqualFont(this._font, font)) {\n      this._font = font;\n      return this;\n    }\n    if (cacheKey) {\n      this._fontFamilies[cacheKey] = this._font;\n    }\n    if (this._font.name) {\n      this._fontFamilies[this._font.name] = this._font;\n    }\n    return this;\n  },\n  fontSize(_fontSize) {\n    this._fontSize = this.sizeToPoint(_fontSize);\n    return this;\n  },\n  currentLineHeight(includeGap) {\n    return this._font.lineHeight(this._fontSize, includeGap);\n  },\n  registerFont(name, src, family) {\n    this._registeredFonts[name] = {\n      src,\n      family\n    };\n    return this;\n  },\n  sizeToPoint(size) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let page = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.page;\n    let percentageWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    if (!percentageWidth) percentageWidth = this._fontSize;\n    if (typeof defaultValue !== 'number') defaultValue = this.sizeToPoint(defaultValue);\n    if (size === undefined) return defaultValue;\n    if (typeof size === 'number') return size;\n    if (typeof size === 'boolean') return Number(size);\n    const match = String(size).match(/((\\d+)?(\\.\\d+)?)(em|in|px|cm|mm|pc|ex|ch|rem|vw|vh|vmin|vmax|%|pt)?/);\n    if (!match) throw new Error(`Unsupported size '${size}'`);\n    let multiplier;\n    switch (match[4]) {\n      case 'em':\n        multiplier = this._fontSize;\n        break;\n      case 'in':\n        multiplier = IN_TO_PT;\n        break;\n      case 'px':\n        multiplier = PX_TO_IN * IN_TO_PT;\n        break;\n      case 'cm':\n        multiplier = CM_TO_IN * IN_TO_PT;\n        break;\n      case 'mm':\n        multiplier = MM_TO_CM * CM_TO_IN * IN_TO_PT;\n        break;\n      case 'pc':\n        multiplier = PC_TO_PT;\n        break;\n      case 'ex':\n        multiplier = this.currentLineHeight();\n        break;\n      case 'ch':\n        multiplier = this.widthOfString('0');\n        break;\n      case 'rem':\n        multiplier = this._remSize;\n        break;\n      case 'vw':\n        multiplier = page.width / 100;\n        break;\n      case 'vh':\n        multiplier = page.height / 100;\n        break;\n      case 'vmin':\n        multiplier = Math.min(page.width, page.height) / 100;\n        break;\n      case 'vmax':\n        multiplier = Math.max(page.width, page.height) / 100;\n        break;\n      case '%':\n        multiplier = percentageWidth / 100;\n        break;\n      case 'pt':\n      default:\n        multiplier = 1;\n    }\n    return multiplier * Number(match[1]);\n  }\n};\n\nconst SOFT_HYPHEN = '\\u00AD';\nconst HYPHEN = '-';\nclass LineWrapper extends events__WEBPACK_IMPORTED_MODULE_5__.EventEmitter {\n  constructor(document, options) {\n    super();\n    this.document = document;\n    this.horizontalScaling = options.horizontalScaling || 100;\n    this.indent = (options.indent || 0) * this.horizontalScaling / 100;\n    this.characterSpacing = (options.characterSpacing || 0) * this.horizontalScaling / 100;\n    this.wordSpacing = (options.wordSpacing === 0) * this.horizontalScaling / 100;\n    this.columns = options.columns || 1;\n    this.columnGap = (options.columnGap != null ? options.columnGap : 18) * this.horizontalScaling / 100;\n    this.lineWidth = (options.width * this.horizontalScaling / 100 - this.columnGap * (this.columns - 1)) / this.columns;\n    this.spaceLeft = this.lineWidth;\n    this.startX = this.document.x;\n    this.startY = this.document.y;\n    this.column = 1;\n    this.ellipsis = options.ellipsis;\n    this.continuedX = 0;\n    this.features = options.features;\n    if (options.height != null) {\n      this.height = options.height;\n      this.maxY = PDFNumber(this.startY + options.height);\n    } else {\n      this.maxY = PDFNumber(this.document.page.maxY());\n    }\n    this.on('firstLine', options => {\n      const indent = this.continuedX || this.indent;\n      this.document.x += indent;\n      this.lineWidth -= indent;\n      if (options.indentAllLines) {\n        return;\n      }\n      this.once('line', () => {\n        this.document.x -= indent;\n        this.lineWidth += indent;\n        if (options.continued && !this.continuedX) {\n          this.continuedX = this.indent;\n        }\n        if (!options.continued) {\n          this.continuedX = 0;\n        }\n      });\n    });\n    this.on('lastLine', options => {\n      const {\n        align\n      } = options;\n      if (align === 'justify') {\n        options.align = 'left';\n      }\n      this.lastLine = true;\n      this.once('line', () => {\n        this.document.y += options.paragraphGap || 0;\n        options.align = align;\n        return this.lastLine = false;\n      });\n    });\n  }\n  wordWidth(word) {\n    return PDFNumber(this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing);\n  }\n  canFit(word, w) {\n    if (word[word.length - 1] != SOFT_HYPHEN) {\n      return w <= this.spaceLeft;\n    }\n    return w + this.wordWidth(HYPHEN) <= this.spaceLeft;\n  }\n  eachWord(text, fn) {\n    let bk;\n    const breaker = new linebreak__WEBPACK_IMPORTED_MODULE_6__[\"default\"](text);\n    let last = null;\n    const wordWidths = Object.create(null);\n    while (bk = breaker.nextBreak()) {\n      var shouldContinue;\n      let word = text.slice((last != null ? last.position : undefined) || 0, bk.position);\n      let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);\n      if (w > this.lineWidth + this.continuedX) {\n        let lbk = last;\n        const fbk = {};\n        while (word.length) {\n          var l, mightGrow;\n          if (w > this.spaceLeft) {\n            l = Math.ceil(this.spaceLeft / (w / word.length));\n            w = this.wordWidth(word.slice(0, l));\n            mightGrow = w <= this.spaceLeft && l < word.length;\n          } else {\n            l = word.length;\n          }\n          let mustShrink = w > this.spaceLeft && l > 0;\n          while (mustShrink || mightGrow) {\n            if (mustShrink) {\n              w = this.wordWidth(word.slice(0, --l));\n              mustShrink = w > this.spaceLeft && l > 0;\n            } else {\n              w = this.wordWidth(word.slice(0, ++l));\n              mustShrink = w > this.spaceLeft && l > 0;\n              mightGrow = w <= this.spaceLeft && l < word.length;\n            }\n          }\n          if (l === 0 && this.spaceLeft === this.lineWidth) {\n            l = 1;\n          }\n          fbk.required = bk.required || l < word.length;\n          shouldContinue = fn(word.slice(0, l), w, fbk, lbk);\n          lbk = {\n            required: false\n          };\n          word = word.slice(l);\n          w = this.wordWidth(word);\n          if (shouldContinue === false) {\n            break;\n          }\n        }\n      } else {\n        shouldContinue = fn(word, w, bk, last);\n      }\n      if (shouldContinue === false) {\n        break;\n      }\n      last = bk;\n    }\n  }\n  wrap(text, options) {\n    this.horizontalScaling = options.horizontalScaling || 100;\n    if (options.indent != null) {\n      this.indent = options.indent * this.horizontalScaling / 100;\n    }\n    if (options.characterSpacing != null) {\n      this.characterSpacing = options.characterSpacing * this.horizontalScaling / 100;\n    }\n    if (options.wordSpacing != null) {\n      this.wordSpacing = options.wordSpacing * this.horizontalScaling / 100;\n    }\n    if (options.ellipsis != null) {\n      this.ellipsis = options.ellipsis;\n    }\n    const nextY = this.document.y + this.document.currentLineHeight(true);\n    if (this.document.y > this.maxY || nextY > this.maxY) {\n      this.nextSection();\n    }\n    let buffer = '';\n    let textWidth = 0;\n    let wc = 0;\n    let lc = 0;\n    let {\n      y\n    } = this.document;\n    const emitLine = () => {\n      options.textWidth = textWidth + this.wordSpacing * (wc - 1);\n      options.wordCount = wc;\n      options.lineWidth = this.lineWidth;\n      ({\n        y\n      } = this.document);\n      this.emit('line', buffer, options, this);\n      return lc++;\n    };\n    this.emit('sectionStart', options, this);\n    this.eachWord(text, (word, w, bk, last) => {\n      if (last == null || last.required) {\n        this.emit('firstLine', options, this);\n        this.spaceLeft = this.lineWidth;\n      }\n      if (this.canFit(word, w)) {\n        buffer += word;\n        textWidth += w;\n        wc++;\n      }\n      if (bk.required || !this.canFit(word, w)) {\n        const lh = this.document.currentLineHeight(true);\n        if (this.height != null && this.ellipsis && PDFNumber(this.document.y + lh * 2) > this.maxY && this.column >= this.columns) {\n          if (this.ellipsis === true) {\n            this.ellipsis = '…';\n          }\n          buffer = buffer.replace(/\\s+$/, '');\n          textWidth = this.wordWidth(buffer + this.ellipsis);\n          while (buffer && textWidth > this.lineWidth) {\n            buffer = buffer.slice(0, -1).replace(/\\s+$/, '');\n            textWidth = this.wordWidth(buffer + this.ellipsis);\n          }\n          if (textWidth <= this.lineWidth) {\n            buffer = buffer + this.ellipsis;\n          }\n          textWidth = this.wordWidth(buffer);\n        }\n        if (bk.required) {\n          if (w > this.spaceLeft) {\n            emitLine();\n            buffer = word;\n            textWidth = w;\n            wc = 1;\n          }\n          this.emit('lastLine', options, this);\n        }\n        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {\n          buffer = buffer.slice(0, -1) + HYPHEN;\n          this.spaceLeft -= this.wordWidth(HYPHEN);\n        }\n        emitLine();\n        if (PDFNumber(this.document.y + lh) > this.maxY) {\n          const shouldContinue = this.nextSection();\n          if (!shouldContinue) {\n            wc = 0;\n            buffer = '';\n            return false;\n          }\n        }\n        if (bk.required) {\n          this.spaceLeft = this.lineWidth;\n          buffer = '';\n          textWidth = 0;\n          return wc = 0;\n        } else {\n          this.spaceLeft = this.lineWidth - w;\n          buffer = word;\n          textWidth = w;\n          return wc = 1;\n        }\n      } else {\n        return this.spaceLeft -= w;\n      }\n    });\n    if (wc > 0) {\n      this.emit('lastLine', options, this);\n      emitLine();\n    }\n    this.emit('sectionEnd', options, this);\n    if (options.continued === true) {\n      if (lc > 1) {\n        this.continuedX = 0;\n      }\n      this.continuedX += options.textWidth || 0;\n      this.document.y = y;\n    } else {\n      this.document.x = this.startX;\n    }\n  }\n  nextSection(options) {\n    this.emit('sectionEnd', options, this);\n    if (++this.column > this.columns) {\n      if (this.height != null) {\n        return false;\n      }\n      this.document.continueOnNewPage();\n      this.column = 1;\n      this.startY = this.document.page.margins.top;\n      this.maxY = this.document.page.maxY();\n      this.document.x = this.startX;\n      if (this.document._fillColor) {\n        this.document.fillColor(...this.document._fillColor);\n      }\n      this.emit('pageBreak', options, this);\n    } else {\n      this.document.x += this.lineWidth + this.columnGap;\n      this.document.y = this.startY;\n      this.emit('columnBreak', options, this);\n    }\n    this.emit('sectionStart', options, this);\n    return true;\n  }\n}\n\nconst {\n  number\n} = PDFObject;\nvar TextMixin = {\n  initText() {\n    this._line = this._line.bind(this);\n    this.x = 0;\n    this.y = 0;\n    this._lineGap = 0;\n  },\n  lineGap(_lineGap) {\n    this._lineGap = _lineGap;\n    return this;\n  },\n  moveDown(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y += this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  moveUp(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y -= this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  _text(text, x, y, options, lineCallback) {\n    options = this._initOptions(x, y, options);\n    text = text == null ? '' : `${text}`;\n    if (options.wordSpacing) {\n      text = text.replace(/\\s{2,}/g, ' ');\n    }\n    const addStructure = () => {\n      if (options.structParent) {\n        options.structParent.add(this.struct(options.structType || 'P', [this.markStructureContent(options.structType || 'P')]));\n      }\n    };\n    if (options.rotation !== 0) {\n      this.save();\n      this.rotate(-options.rotation, {\n        origin: [this.x, this.y]\n      });\n    }\n    if (options.width) {\n      let wrapper = this._wrapper;\n      if (!wrapper) {\n        wrapper = new LineWrapper(this, options);\n        wrapper.on('line', lineCallback);\n        wrapper.on('firstLine', addStructure);\n      }\n      this._wrapper = options.continued ? wrapper : null;\n      this._textOptions = options.continued ? options : null;\n      wrapper.wrap(text, options);\n    } else {\n      for (let line of text.split('\\n')) {\n        addStructure();\n        lineCallback(line, options);\n      }\n    }\n    if (options.rotation !== 0) this.restore();\n    return this;\n  },\n  text(text, x, y, options) {\n    return this._text(text, x, y, options, this._line);\n  },\n  widthOfString(string) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const horizontalScaling = options.horizontalScaling || 100;\n    return (this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1)) * horizontalScaling / 100;\n  },\n  boundsOfString(string, x, y, options) {\n    options = this._initOptions(x, y, options);\n    ({\n      x,\n      y\n    } = this);\n    const lineGap = options.lineGap ?? this._lineGap ?? 0;\n    const lineHeight = this.currentLineHeight(true) + lineGap;\n    let contentWidth = 0;\n    string = String(string ?? '');\n    if (options.wordSpacing) {\n      string = string.replace(/\\s{2,}/g, ' ');\n    }\n    if (options.width) {\n      let wrapper = new LineWrapper(this, options);\n      wrapper.on('line', (text, options) => {\n        this.y += lineHeight;\n        text = text.replace(/\\n/g, '');\n        if (text.length) {\n          let wordSpacing = options.wordSpacing ?? 0;\n          const characterSpacing = options.characterSpacing ?? 0;\n          if (options.width && options.align === 'justify') {\n            const words = text.trim().split(/\\s+/);\n            const textWidth = this.widthOfString(text.replace(/\\s+/g, ''), options);\n            const spaceWidth = this.widthOfString(' ') + characterSpacing;\n            wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);\n          }\n          contentWidth = Math.max(contentWidth, options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1));\n        }\n      });\n      wrapper.wrap(string, options);\n    } else {\n      for (let line of string.split('\\n')) {\n        const lineWidth = this.widthOfString(line, options);\n        this.y += lineHeight;\n        contentWidth = Math.max(contentWidth, lineWidth);\n      }\n    }\n    let contentHeight = this.y - y;\n    if (options.height) contentHeight = Math.min(contentHeight, options.height);\n    this.x = x;\n    this.y = y;\n    if (options.rotation === 0) {\n      return {\n        x,\n        y,\n        width: contentWidth,\n        height: contentHeight\n      };\n    } else if (options.rotation === 90) {\n      return {\n        x: x,\n        y: y - contentWidth,\n        width: contentHeight,\n        height: contentWidth\n      };\n    } else if (options.rotation === 180) {\n      return {\n        x: x - contentWidth,\n        y: y - contentHeight,\n        width: contentWidth,\n        height: contentHeight\n      };\n    } else if (options.rotation === 270) {\n      return {\n        x: x - contentHeight,\n        y: y,\n        width: contentHeight,\n        height: contentWidth\n      };\n    }\n    const cos = cosine(options.rotation);\n    const sin = sine(options.rotation);\n    const x1 = x;\n    const y1 = y;\n    const x2 = x + contentWidth * cos;\n    const y2 = y - contentWidth * sin;\n    const x3 = x + contentWidth * cos + contentHeight * sin;\n    const y3 = y - contentWidth * sin + contentHeight * cos;\n    const x4 = x + contentHeight * sin;\n    const y4 = y + contentHeight * cos;\n    const xMin = Math.min(x1, x2, x3, x4);\n    const xMax = Math.max(x1, x2, x3, x4);\n    const yMin = Math.min(y1, y2, y3, y4);\n    const yMax = Math.max(y1, y2, y3, y4);\n    return {\n      x: xMin,\n      y: yMin,\n      width: xMax - xMin,\n      height: yMax - yMin\n    };\n  },\n  heightOfString(text, options) {\n    const {\n      x,\n      y\n    } = this;\n    options = this._initOptions(options);\n    options.height = Infinity;\n    const lineGap = options.lineGap || this._lineGap || 0;\n    this._text(text, this.x, this.y, options, () => {\n      this.y += this.currentLineHeight(true) + lineGap;\n    });\n    const height = this.y - y;\n    this.x = x;\n    this.y = y;\n    return height;\n  },\n  list(list, x, y, options, wrapper) {\n    options = this._initOptions(x, y, options);\n    const listType = options.listType || 'bullet';\n    const unit = Math.round(this._font.ascender / 1000 * this._fontSize);\n    const midLine = unit / 2;\n    const r = options.bulletRadius || unit / 3;\n    const indent = options.textIndent || (listType === 'bullet' ? r * 5 : unit * 2);\n    const itemIndent = options.bulletIndent || (listType === 'bullet' ? r * 8 : unit * 2);\n    let level = 1;\n    const items = [];\n    const levels = [];\n    const numbers = [];\n    var flatten = function (list) {\n      let n = 1;\n      for (let i = 0; i < list.length; i++) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n          level++;\n          flatten(item);\n          level--;\n        } else {\n          items.push(item);\n          levels.push(level);\n          if (listType !== 'bullet') {\n            numbers.push(n++);\n          }\n        }\n      }\n    };\n    flatten(list);\n    const label = function (n) {\n      switch (listType) {\n        case 'numbered':\n          return `${n}.`;\n        case 'lettered':\n          var letter = String.fromCharCode((n - 1) % 26 + 65);\n          var times = Math.floor((n - 1) / 26 + 1);\n          var text = Array(times + 1).join(letter);\n          return `${text}.`;\n      }\n    };\n    const drawListItem = function (listItem, i) {\n      wrapper = new LineWrapper(this, options);\n      wrapper.on('line', this._line);\n      level = 1;\n      wrapper.once('firstLine', () => {\n        let item, itemType, labelType, bodyType;\n        if (options.structParent) {\n          if (options.structTypes) {\n            [itemType, labelType, bodyType] = options.structTypes;\n          } else {\n            [itemType, labelType, bodyType] = ['LI', 'Lbl', 'LBody'];\n          }\n        }\n        if (itemType) {\n          item = this.struct(itemType);\n          options.structParent.add(item);\n        } else if (options.structParent) {\n          item = options.structParent;\n        }\n        let l;\n        if ((l = levels[i++]) !== level) {\n          const diff = itemIndent * (l - level);\n          this.x += diff;\n          wrapper.lineWidth -= diff;\n          level = l;\n        }\n        if (item && (labelType || bodyType)) {\n          item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));\n        }\n        switch (listType) {\n          case 'bullet':\n            this.circle(this.x - indent + r, this.y + midLine, r);\n            this.fill();\n            break;\n          case 'numbered':\n          case 'lettered':\n            var text = label(numbers[i - 1]);\n            this._fragment(text, this.x - indent, this.y, options);\n            break;\n        }\n        if (item && labelType && bodyType) {\n          item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));\n        }\n        if (item && item !== options.structParent) {\n          item.end();\n        }\n      });\n      wrapper.on('sectionStart', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x += pos;\n        wrapper.lineWidth -= pos;\n      });\n      wrapper.on('sectionEnd', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x -= pos;\n        wrapper.lineWidth += pos;\n      });\n      wrapper.wrap(listItem, options);\n    };\n    for (let i = 0; i < items.length; i++) {\n      drawListItem.call(this, items[i], i);\n    }\n    return this;\n  },\n  _initOptions() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let y = arguments.length > 1 ? arguments[1] : undefined;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n    const result = Object.assign({}, options);\n    if (this._textOptions) {\n      for (let key in this._textOptions) {\n        const val = this._textOptions[key];\n        if (key !== 'continued') {\n          if (result[key] === undefined) {\n            result[key] = val;\n          }\n        }\n      }\n    }\n    if (x != null) {\n      this.x = x;\n    }\n    if (y != null) {\n      this.y = y;\n    }\n    if (result.lineBreak !== false) {\n      if (result.width == null) {\n        result.width = this.page.width - this.x - this.page.margins.right;\n      }\n      result.width = Math.max(result.width, 0);\n    }\n    if (!result.columns) {\n      result.columns = 0;\n    }\n    if (result.columnGap == null) {\n      result.columnGap = 18;\n    }\n    result.rotation = Number(options.rotation ?? 0) % 360;\n    if (result.rotation < 0) result.rotation += 360;\n    return result;\n  },\n  _line(text) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let wrapper = arguments.length > 2 ? arguments[2] : undefined;\n    this._fragment(text, this.x, this.y, options);\n    const lineGap = options.lineGap || this._lineGap || 0;\n    if (!wrapper) {\n      this.x += this.widthOfString(text, options);\n    } else {\n      this.y += this.currentLineHeight(true) + lineGap;\n    }\n  },\n  _fragment(text, x, y, options) {\n    let dy, encoded, i, positions, textWidth, words;\n    text = `${text}`.replace(/\\n/g, '');\n    if (text.length === 0) {\n      return;\n    }\n    const align = options.align || 'left';\n    let wordSpacing = options.wordSpacing || 0;\n    const characterSpacing = options.characterSpacing || 0;\n    const horizontalScaling = options.horizontalScaling || 100;\n    if (options.width) {\n      switch (align) {\n        case 'right':\n          textWidth = this.widthOfString(text.replace(/\\s+$/, ''), options);\n          x += options.lineWidth - textWidth;\n          break;\n        case 'center':\n          x += options.lineWidth / 2 - options.textWidth / 2;\n          break;\n        case 'justify':\n          words = text.trim().split(/\\s+/);\n          textWidth = this.widthOfString(text.replace(/\\s+/g, ''), options);\n          var spaceWidth = this.widthOfString(' ') + characterSpacing;\n          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);\n          break;\n      }\n    }\n    if (typeof options.baseline === 'number') {\n      dy = -options.baseline;\n    } else {\n      switch (options.baseline) {\n        case 'svg-middle':\n          dy = 0.5 * this._font.xHeight;\n          break;\n        case 'middle':\n        case 'svg-central':\n          dy = 0.5 * (this._font.descender + this._font.ascender);\n          break;\n        case 'bottom':\n        case 'ideographic':\n          dy = this._font.descender;\n          break;\n        case 'alphabetic':\n          dy = 0;\n          break;\n        case 'mathematical':\n          dy = 0.5 * this._font.ascender;\n          break;\n        case 'hanging':\n          dy = 0.8 * this._font.ascender;\n          break;\n        case 'top':\n          dy = this._font.ascender;\n          break;\n        default:\n          dy = this._font.ascender;\n      }\n      dy = dy / 1000 * this._fontSize;\n    }\n    const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);\n    if (options.link != null) {\n      this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n    if (options.underline) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n      let lineY = y + this.currentLineHeight() - lineWidth;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n    if (options.strike) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n      let lineY = y + this.currentLineHeight() / 2;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n    this.save();\n    if (options.oblique) {\n      let skew;\n      if (typeof options.oblique === 'number') {\n        skew = -Math.tan(options.oblique * Math.PI / 180);\n      } else {\n        skew = -0.25;\n      }\n      this.transform(1, 0, 0, 1, x, y);\n      this.transform(1, 0, skew, 1, -skew * dy, 0);\n      this.transform(1, 0, 0, 1, -x, -y);\n    }\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    y = this.page.height - y - dy;\n    if (this.page.fonts[this._font.id] == null) {\n      this.page.fonts[this._font.id] = this._font.ref();\n    }\n    this.addContent('BT');\n    this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n    this.addContent(`/${this._font.id} ${number(this._fontSize)} Tf`);\n    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;\n    if (mode) {\n      this.addContent(`${mode} Tr`);\n    }\n    if (characterSpacing) {\n      this.addContent(`${number(characterSpacing)} Tc`);\n    }\n    if (horizontalScaling !== 100) {\n      this.addContent(`${horizontalScaling} Tz`);\n    }\n    if (wordSpacing) {\n      words = text.trim().split(/\\s+/);\n      wordSpacing += this.widthOfString(' ') + characterSpacing;\n      wordSpacing *= 1000 / this._fontSize;\n      encoded = [];\n      positions = [];\n      for (let word of words) {\n        const [encodedWord, positionsWord] = this._font.encode(word, options.features);\n        encoded = encoded.concat(encodedWord);\n        positions = positions.concat(positionsWord);\n        const space = {};\n        const object = positions[positions.length - 1];\n        for (let key in object) {\n          const val = object[key];\n          space[key] = val;\n        }\n        space.xAdvance += wordSpacing;\n        positions[positions.length - 1] = space;\n      }\n    } else {\n      [encoded, positions] = this._font.encode(text, options.features);\n    }\n    const scale = this._fontSize / 1000;\n    const commands = [];\n    let last = 0;\n    let hadOffset = false;\n    const addSegment = cur => {\n      if (last < cur) {\n        const hex = encoded.slice(last, cur).join('');\n        const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n        commands.push(`<${hex}> ${number(-advance)}`);\n      }\n      last = cur;\n    };\n    const flush = i => {\n      addSegment(i);\n      if (commands.length > 0) {\n        this.addContent(`[${commands.join(' ')}] TJ`);\n        commands.length = 0;\n      }\n    };\n    for (i = 0; i < positions.length; i++) {\n      const pos = positions[i];\n      if (pos.xOffset || pos.yOffset) {\n        flush(i);\n        this.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n        flush(i + 1);\n        hadOffset = true;\n      } else {\n        if (hadOffset) {\n          this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n          hadOffset = false;\n        }\n        if (pos.xAdvance - pos.advanceWidth !== 0) {\n          addSegment(i + 1);\n        }\n      }\n      x += pos.xAdvance * scale;\n    }\n    flush(i);\n    this.addContent('ET');\n    this.restore();\n  }\n};\n\nconst MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\nconst COLOR_SPACE_MAP = {\n  1: 'DeviceGray',\n  3: 'DeviceRGB',\n  4: 'DeviceCMYK'\n};\nclass JPEG {\n  constructor(data, label) {\n    let marker;\n    this.data = data;\n    this.label = label;\n    if (this.data.readUInt16BE(0) !== 0xffd8) {\n      throw 'SOI not found in JPEG';\n    }\n    this.orientation = jpeg_exif__WEBPACK_IMPORTED_MODULE_7__.fromBuffer(this.data).Orientation || 1;\n    let pos = 2;\n    while (pos < this.data.length) {\n      marker = this.data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += this.data.readUInt16BE(pos);\n    }\n    if (!MARKERS.includes(marker)) {\n      throw 'Invalid JPEG.';\n    }\n    pos += 2;\n    this.bits = this.data[pos++];\n    this.height = this.data.readUInt16BE(pos);\n    pos += 2;\n    this.width = this.data.readUInt16BE(pos);\n    pos += 2;\n    const channels = this.data[pos++];\n    this.colorSpace = COLOR_SPACE_MAP[channels];\n    this.obj = null;\n  }\n  embed(document) {\n    if (this.obj) {\n      return;\n    }\n    this.obj = document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: this.bits,\n      Width: this.width,\n      Height: this.height,\n      ColorSpace: this.colorSpace,\n      Filter: 'DCTDecode'\n    });\n    if (this.colorSpace === 'DeviceCMYK') {\n      this.obj.data['Decode'] = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];\n    }\n    this.obj.end(this.data);\n    return this.data = null;\n  }\n}\n\nclass PNGImage {\n  constructor(data, label) {\n    this.label = label;\n    this.image = new (png_js__WEBPACK_IMPORTED_MODULE_8___default())(data);\n    this.width = this.image.width;\n    this.height = this.image.height;\n    this.imgData = this.image.imgData;\n    this.obj = null;\n  }\n  embed(document) {\n    let dataDecoded = false;\n    this.document = document;\n    if (this.obj) {\n      return;\n    }\n    const hasAlphaChannel = this.image.hasAlphaChannel;\n    const isInterlaced = this.image.interlaceMethod === 1;\n    this.obj = this.document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,\n      Width: this.width,\n      Height: this.height,\n      Filter: 'FlateDecode'\n    });\n    if (!hasAlphaChannel) {\n      const params = this.document.ref({\n        Predictor: isInterlaced ? 1 : 15,\n        Colors: this.image.colors,\n        BitsPerComponent: this.image.bits,\n        Columns: this.width\n      });\n      this.obj.data['DecodeParms'] = params;\n      params.end();\n    }\n    if (this.image.palette.length === 0) {\n      this.obj.data['ColorSpace'] = this.image.colorSpace;\n    } else {\n      const palette = this.document.ref();\n      palette.end(Buffer.from(this.image.palette));\n      this.obj.data['ColorSpace'] = ['Indexed', 'DeviceRGB', this.image.palette.length / 3 - 1, palette];\n    }\n    if (this.image.transparency.grayscale != null) {\n      const val = this.image.transparency.grayscale;\n      this.obj.data['Mask'] = [val, val];\n    } else if (this.image.transparency.rgb) {\n      const {\n        rgb\n      } = this.image.transparency;\n      const mask = [];\n      for (let x of rgb) {\n        mask.push(x, x);\n      }\n      this.obj.data['Mask'] = mask;\n    } else if (this.image.transparency.indexed) {\n      dataDecoded = true;\n      return this.loadIndexedAlphaChannel();\n    } else if (hasAlphaChannel) {\n      dataDecoded = true;\n      return this.splitAlphaChannel();\n    }\n    if (isInterlaced && !dataDecoded) {\n      return this.decodeData();\n    }\n    this.finalize();\n  }\n  finalize() {\n    if (this.alphaChannel) {\n      const sMask = this.document.ref({\n        Type: 'XObject',\n        Subtype: 'Image',\n        Height: this.height,\n        Width: this.width,\n        BitsPerComponent: 8,\n        Filter: 'FlateDecode',\n        ColorSpace: 'DeviceGray',\n        Decode: [0, 1]\n      });\n      sMask.end(this.alphaChannel);\n      this.obj.data['SMask'] = sMask;\n    }\n    this.obj.end(this.imgData);\n    this.image = null;\n    return this.imgData = null;\n  }\n  splitAlphaChannel() {\n    return this.image.decodePixels(pixels => {\n      let a, p;\n      const colorCount = this.image.colors;\n      const pixelCount = this.width * this.height;\n      const imgData = Buffer.alloc(pixelCount * colorCount);\n      const alphaChannel = Buffer.alloc(pixelCount);\n      let i = p = a = 0;\n      const len = pixels.length;\n      const skipByteCount = this.image.bits === 16 ? 1 : 0;\n      while (i < len) {\n        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {\n          imgData[p++] = pixels[i++];\n          i += skipByteCount;\n        }\n        alphaChannel[a++] = pixels[i++];\n        i += skipByteCount;\n      }\n      this.imgData = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(imgData);\n      this.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n  loadIndexedAlphaChannel() {\n    const transparency = this.image.transparency.indexed;\n    return this.image.decodePixels(pixels => {\n      const alphaChannel = Buffer.alloc(this.width * this.height);\n      let i = 0;\n      for (let j = 0, end = pixels.length; j < end; j++) {\n        alphaChannel[i++] = transparency[pixels[j]];\n      }\n      this.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n  decodeData() {\n    this.image.decodePixels(pixels => {\n      this.imgData = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(pixels);\n      this.finalize();\n    });\n  }\n}\n\nclass PDFImage {\n  static open(src, label) {\n    let data;\n    if (Buffer.isBuffer(src)) {\n      data = src;\n    } else if (src instanceof ArrayBuffer) {\n      data = Buffer.from(new Uint8Array(src));\n    } else {\n      const match = /^data:.+?;base64,(.*)$/.exec(src);\n      if (match) {\n        data = Buffer.from(match[1], 'base64');\n      } else {\n        data = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n        if (!data) {\n          return;\n        }\n      }\n    }\n    if (data[0] === 0xff && data[1] === 0xd8) {\n      return new JPEG(data, label);\n    } else if (data[0] === 0x89 && data.toString('ascii', 1, 4) === 'PNG') {\n      return new PNGImage(data, label);\n    } else {\n      throw new Error('Unknown image format.');\n    }\n  }\n}\n\nvar ImagesMixin = {\n  initImages() {\n    this._imageRegistry = {};\n    this._imageCount = 0;\n  },\n  image(src, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let bh, bp, bw, image, ip, left, left1, originX, originY;\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n    const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;\n    const inDocumentFlow = typeof y !== 'number';\n    x = (left = x != null ? x : options.x) != null ? left : this.x;\n    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n    if (!image) {\n      if (src.width && src.height) {\n        image = src;\n      } else {\n        image = this.openImage(src);\n      }\n    }\n    if (!image.obj) {\n      image.embed(this);\n    }\n    if (this.page.xobjects[image.label] == null) {\n      this.page.xobjects[image.label] = image.obj;\n    }\n    let {\n      width,\n      height\n    } = image;\n    if (!ignoreOrientation && image.orientation > 4) {\n      [width, height] = [height, width];\n    }\n    let w = options.width || width;\n    let h = options.height || height;\n    if (options.width && !options.height) {\n      const wp = w / width;\n      w = width * wp;\n      h = height * wp;\n    } else if (options.height && !options.width) {\n      const hp = h / height;\n      w = width * hp;\n      h = height * hp;\n    } else if (options.scale) {\n      w = width * options.scale;\n      h = height * options.scale;\n    } else if (options.fit) {\n      [bw, bh] = options.fit;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        w = bw;\n        h = bw / ip;\n      } else {\n        h = bh;\n        w = bh * ip;\n      }\n    } else if (options.cover) {\n      [bw, bh] = options.cover;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        h = bh;\n        w = bh * ip;\n      } else {\n        w = bw;\n        h = bw / ip;\n      }\n    }\n    if (options.fit || options.cover) {\n      if (options.align === 'center') {\n        x = x + bw / 2 - w / 2;\n      } else if (options.align === 'right') {\n        x = x + bw - w;\n      }\n      if (options.valign === 'center') {\n        y = y + bh / 2 - h / 2;\n      } else if (options.valign === 'bottom') {\n        y = y + bh - h;\n      }\n    }\n    let rotateAngle = 0;\n    let xTransform = x;\n    let yTransform = y;\n    let hTransform = h;\n    let wTransform = w;\n    if (!ignoreOrientation) {\n      switch (image.orientation) {\n        default:\n        case 1:\n          hTransform = -h;\n          yTransform += h;\n          break;\n        case 2:\n          wTransform = -w;\n          hTransform = -h;\n          xTransform += w;\n          yTransform += h;\n          break;\n        case 3:\n          originX = x;\n          originY = y;\n          hTransform = -h;\n          xTransform -= w;\n          rotateAngle = 180;\n          break;\n        case 4:\n          break;\n        case 5:\n          originX = x;\n          originY = y;\n          wTransform = h;\n          hTransform = w;\n          yTransform -= hTransform;\n          rotateAngle = 90;\n          break;\n        case 6:\n          originX = x;\n          originY = y;\n          wTransform = h;\n          hTransform = -w;\n          rotateAngle = 90;\n          break;\n        case 7:\n          originX = x;\n          originY = y;\n          hTransform = -w;\n          wTransform = -h;\n          xTransform += h;\n          rotateAngle = 90;\n          break;\n        case 8:\n          originX = x;\n          originY = y;\n          wTransform = h;\n          hTransform = -w;\n          xTransform -= h;\n          yTransform += w;\n          rotateAngle = -90;\n          break;\n      }\n    } else {\n      hTransform = -h;\n      yTransform += h;\n    }\n    if (options.link != null) {\n      this.link(x, y, w, h, options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, w, h, options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n    if (inDocumentFlow) {\n      this.y += h;\n    }\n    this.save();\n    if (rotateAngle) {\n      this.rotate(rotateAngle, {\n        origin: [originX, originY]\n      });\n    }\n    this.transform(wTransform, 0, 0, hTransform, xTransform, yTransform);\n    this.addContent(`/${image.label} Do`);\n    this.restore();\n    return this;\n  },\n  openImage(src) {\n    let image;\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n    if (!image) {\n      image = PDFImage.open(src, `I${++this._imageCount}`);\n      if (typeof src === 'string') {\n        this._imageRegistry[src] = image;\n      }\n    }\n    return image;\n  }\n};\n\nvar AnnotationsMixin = {\n  annotate(x, y, w, h, options) {\n    options.Type = 'Annot';\n    options.Rect = this._convertRect(x, y, w, h);\n    options.Border = [0, 0, 0];\n    if (options.Subtype === 'Link' && typeof options.F === 'undefined') {\n      options.F = 1 << 2;\n    }\n    if (options.Subtype !== 'Link') {\n      if (options.C == null) {\n        options.C = this._normalizeColor(options.color || [0, 0, 0]);\n      }\n    }\n    delete options.color;\n    if (typeof options.Dest === 'string') {\n      options.Dest = new String(options.Dest);\n    }\n    for (let key in options) {\n      const val = options[key];\n      options[key[0].toUpperCase() + key.slice(1)] = val;\n    }\n    const ref = this.ref(options);\n    this.page.annotations.push(ref);\n    ref.end();\n    return this;\n  },\n  note(x, y, w, h, contents) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Text';\n    options.Contents = new String(contents);\n    if (options.Name == null) {\n      options.Name = 'Comment';\n    }\n    if (options.color == null) {\n      options.color = [243, 223, 92];\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  goTo(x, y, w, h, name) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n    options.A = this.ref({\n      S: 'GoTo',\n      D: new String(name)\n    });\n    options.A.end();\n    return this.annotate(x, y, w, h, options);\n  },\n  link(x, y, w, h, url) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n    if (typeof url === 'number') {\n      const pages = this._root.data.Pages.data;\n      if (url >= 0 && url < pages.Kids.length) {\n        options.A = this.ref({\n          S: 'GoTo',\n          D: [pages.Kids[url], 'XYZ', null, null, null]\n        });\n        options.A.end();\n      } else {\n        throw new Error(`The document has no page ${url}`);\n      }\n    } else {\n      options.A = this.ref({\n        S: 'URI',\n        URI: new String(url)\n      });\n      options.A.end();\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  _markup(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const [x1, y1, x2, y2] = this._convertRect(x, y, w, h);\n    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  highlight(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Highlight';\n    if (options.color == null) {\n      options.color = [241, 238, 148];\n    }\n    return this._markup(x, y, w, h, options);\n  },\n  underline(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Underline';\n    return this._markup(x, y, w, h, options);\n  },\n  strike(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'StrikeOut';\n    return this._markup(x, y, w, h, options);\n  },\n  lineAnnotation(x1, y1, x2, y2) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Line';\n    options.Contents = new String();\n    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];\n    return this.annotate(x1, y1, x2, y2, options);\n  },\n  rectAnnotation(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Square';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  ellipseAnnotation(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Circle';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  textAnnotation(x, y, w, h, text) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'FreeText';\n    options.Contents = new String(text);\n    options.DA = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  fileAnnotation(x, y, w, h) {\n    let file = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const filespec = this.file(file.src, Object.assign({\n      hidden: true\n    }, file));\n    options.Subtype = 'FileAttachment';\n    options.FS = filespec;\n    if (options.Contents) {\n      options.Contents = new String(options.Contents);\n    } else if (filespec.data.Desc) {\n      options.Contents = filespec.data.Desc;\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  _convertRect(x1, y1, w, h) {\n    let y2 = y1;\n    y1 += h;\n    let x2 = x1 + w;\n    const [m0, m1, m2, m3, m4, m5] = this._ctm;\n    x1 = m0 * x1 + m2 * y1 + m4;\n    y1 = m1 * x1 + m3 * y1 + m5;\n    x2 = m0 * x2 + m2 * y2 + m4;\n    y2 = m1 * x2 + m3 * y2 + m5;\n    return [x1, y1, x2, y2];\n  }\n};\n\nclass PDFOutline {\n  constructor(document, parent, title, dest) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      expanded: false\n    };\n    this.document = document;\n    this.options = options;\n    this.outlineData = {};\n    if (dest !== null) {\n      this.outlineData['Dest'] = [dest.dictionary, 'Fit'];\n    }\n    if (parent !== null) {\n      this.outlineData['Parent'] = parent;\n    }\n    if (title !== null) {\n      this.outlineData['Title'] = new String(title);\n    }\n    this.dictionary = this.document.ref(this.outlineData);\n    this.children = [];\n  }\n  addItem(title) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      expanded: false\n    };\n    const result = new PDFOutline(this.document, this.dictionary, title, this.document.page, options);\n    this.children.push(result);\n    return result;\n  }\n  endOutline() {\n    if (this.children.length > 0) {\n      if (this.options.expanded) {\n        this.outlineData.Count = this.children.length;\n      }\n      const first = this.children[0],\n        last = this.children[this.children.length - 1];\n      this.outlineData.First = first.dictionary;\n      this.outlineData.Last = last.dictionary;\n      for (let i = 0, len = this.children.length; i < len; i++) {\n        const child = this.children[i];\n        if (i > 0) {\n          child.outlineData.Prev = this.children[i - 1].dictionary;\n        }\n        if (i < this.children.length - 1) {\n          child.outlineData.Next = this.children[i + 1].dictionary;\n        }\n        child.endOutline();\n      }\n    }\n    return this.dictionary.end();\n  }\n}\n\nvar OutlineMixin = {\n  initOutline() {\n    this.outline = new PDFOutline(this, null, null, null);\n  },\n  endOutline() {\n    this.outline.endOutline();\n    if (this.outline.children.length > 0) {\n      this._root.data.Outlines = this.outline.dictionary;\n      return this._root.data.PageMode = 'UseOutlines';\n    }\n  }\n};\n\nclass PDFStructureContent {\n  constructor(pageRef, mcid) {\n    this.refs = [{\n      pageRef,\n      mcid\n    }];\n  }\n  push(structContent) {\n    structContent.refs.forEach(ref => this.refs.push(ref));\n  }\n}\n\nclass PDFStructureElement {\n  constructor(document, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.document = document;\n    this._attached = false;\n    this._ended = false;\n    this._flushed = false;\n    this.dictionary = document.ref({\n      S: type\n    });\n    const data = this.dictionary.data;\n    if (Array.isArray(options) || this._isValidChild(options)) {\n      children = options;\n      options = {};\n    }\n    if (typeof options.title !== 'undefined') {\n      data.T = new String(options.title);\n    }\n    if (typeof options.lang !== 'undefined') {\n      data.Lang = new String(options.lang);\n    }\n    if (typeof options.alt !== 'undefined') {\n      data.Alt = new String(options.alt);\n    }\n    if (typeof options.expanded !== 'undefined') {\n      data.E = new String(options.expanded);\n    }\n    if (typeof options.actual !== 'undefined') {\n      data.ActualText = new String(options.actual);\n    }\n    this._children = [];\n    if (children) {\n      if (!Array.isArray(children)) {\n        children = [children];\n      }\n      children.forEach(child => this.add(child));\n      this.end();\n    }\n  }\n  add(child) {\n    if (this._ended) {\n      throw new Error(`Cannot add child to already-ended structure element`);\n    }\n    if (!this._isValidChild(child)) {\n      throw new Error(`Invalid structure element child`);\n    }\n    if (child instanceof PDFStructureElement) {\n      child.setParent(this.dictionary);\n      if (this._attached) {\n        child.setAttached();\n      }\n    }\n    if (child instanceof PDFStructureContent) {\n      this._addContentToParentTree(child);\n    }\n    if (typeof child === 'function' && this._attached) {\n      child = this._contentForClosure(child);\n    }\n    this._children.push(child);\n    return this;\n  }\n  _addContentToParentTree(content) {\n    content.refs.forEach(_ref => {\n      let {\n        pageRef,\n        mcid\n      } = _ref;\n      const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);\n      pageStructParents[mcid] = this.dictionary;\n    });\n  }\n  setParent(parentRef) {\n    if (this.dictionary.data.P) {\n      throw new Error(`Structure element added to more than one parent`);\n    }\n    this.dictionary.data.P = parentRef;\n    this._flush();\n  }\n  setAttached() {\n    if (this._attached) {\n      return;\n    }\n    this._children.forEach((child, index) => {\n      if (child instanceof PDFStructureElement) {\n        child.setAttached();\n      }\n      if (typeof child === 'function') {\n        this._children[index] = this._contentForClosure(child);\n      }\n    });\n    this._attached = true;\n    this._flush();\n  }\n  end() {\n    if (this._ended) {\n      return;\n    }\n    this._children.filter(child => child instanceof PDFStructureElement).forEach(child => child.end());\n    this._ended = true;\n    this._flush();\n  }\n  _isValidChild(child) {\n    return child instanceof PDFStructureElement || child instanceof PDFStructureContent || typeof child === 'function';\n  }\n  _contentForClosure(closure) {\n    const content = this.document.markStructureContent(this.dictionary.data.S);\n    closure();\n    this.document.endMarkedContent();\n    this._addContentToParentTree(content);\n    return content;\n  }\n  _isFlushable() {\n    if (!this.dictionary.data.P || !this._ended) {\n      return false;\n    }\n    return this._children.every(child => {\n      if (typeof child === 'function') {\n        return false;\n      }\n      if (child instanceof PDFStructureElement) {\n        return child._isFlushable();\n      }\n      return true;\n    });\n  }\n  _flush() {\n    if (this._flushed || !this._isFlushable()) {\n      return;\n    }\n    this.dictionary.data.K = [];\n    this._children.forEach(child => this._flushChild(child));\n    this.dictionary.end();\n    this._children = [];\n    this.dictionary.data.K = null;\n    this._flushed = true;\n  }\n  _flushChild(child) {\n    if (child instanceof PDFStructureElement) {\n      this.dictionary.data.K.push(child.dictionary);\n    }\n    if (child instanceof PDFStructureContent) {\n      child.refs.forEach(_ref2 => {\n        let {\n          pageRef,\n          mcid\n        } = _ref2;\n        if (!this.dictionary.data.Pg) {\n          this.dictionary.data.Pg = pageRef;\n        }\n        if (this.dictionary.data.Pg === pageRef) {\n          this.dictionary.data.K.push(mcid);\n        } else {\n          this.dictionary.data.K.push({\n            Type: 'MCR',\n            Pg: pageRef,\n            MCID: mcid\n          });\n        }\n      });\n    }\n  }\n}\n\nclass PDFNumberTree extends PDFTree {\n  _compareKeys(a, b) {\n    return parseInt(a) - parseInt(b);\n  }\n  _keysName() {\n    return 'Nums';\n  }\n  _dataForKey(k) {\n    return parseInt(k);\n  }\n}\n\nvar MarkingsMixin = {\n  initMarkings(options) {\n    this.structChildren = [];\n    if (options.tagged) {\n      this.getMarkInfoDictionary().data.Marked = true;\n      this.getStructTreeRoot();\n    }\n  },\n  markContent(tag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (tag === 'Artifact' || options && options.mcid) {\n      let toClose = 0;\n      this.page.markings.forEach(marking => {\n        if (toClose || marking.structContent || marking.tag === 'Artifact') {\n          toClose++;\n        }\n      });\n      while (toClose--) {\n        this.endMarkedContent();\n      }\n    }\n    if (!options) {\n      this.page.markings.push({\n        tag\n      });\n      this.addContent(`/${tag} BMC`);\n      return this;\n    }\n    this.page.markings.push({\n      tag,\n      options\n    });\n    const dictionary = {};\n    if (typeof options.mcid !== 'undefined') {\n      dictionary.MCID = options.mcid;\n    }\n    if (tag === 'Artifact') {\n      if (typeof options.type === 'string') {\n        dictionary.Type = options.type;\n      }\n      if (Array.isArray(options.bbox)) {\n        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];\n      }\n      if (Array.isArray(options.attached) && options.attached.every(val => typeof val === 'string')) {\n        dictionary.Attached = options.attached;\n      }\n    }\n    if (tag === 'Span') {\n      if (options.lang) {\n        dictionary.Lang = new String(options.lang);\n      }\n      if (options.alt) {\n        dictionary.Alt = new String(options.alt);\n      }\n      if (options.expanded) {\n        dictionary.E = new String(options.expanded);\n      }\n      if (options.actual) {\n        dictionary.ActualText = new String(options.actual);\n      }\n    }\n    this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);\n    return this;\n  },\n  markStructureContent(tag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);\n    const mcid = pageStructParents.length;\n    pageStructParents.push(null);\n    this.markContent(tag, {\n      ...options,\n      mcid\n    });\n    const structContent = new PDFStructureContent(this.page.dictionary, mcid);\n    this.page.markings.slice(-1)[0].structContent = structContent;\n    return structContent;\n  },\n  endMarkedContent() {\n    this.page.markings.pop();\n    this.addContent('EMC');\n    return this;\n  },\n  struct(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return new PDFStructureElement(this, type, options, children);\n  },\n  addStructure(structElem) {\n    const structTreeRoot = this.getStructTreeRoot();\n    structElem.setParent(structTreeRoot);\n    structElem.setAttached();\n    this.structChildren.push(structElem);\n    if (!structTreeRoot.data.K) {\n      structTreeRoot.data.K = [];\n    }\n    structTreeRoot.data.K.push(structElem.dictionary);\n    return this;\n  },\n  initPageMarkings(pageMarkings) {\n    pageMarkings.forEach(marking => {\n      if (marking.structContent) {\n        const structContent = marking.structContent;\n        const newStructContent = this.markStructureContent(marking.tag, marking.options);\n        structContent.push(newStructContent);\n        this.page.markings.slice(-1)[0].structContent = structContent;\n      } else {\n        this.markContent(marking.tag, marking.options);\n      }\n    });\n  },\n  endPageMarkings(page) {\n    const pageMarkings = page.markings;\n    pageMarkings.forEach(() => page.write('EMC'));\n    page.markings = [];\n    return pageMarkings;\n  },\n  getMarkInfoDictionary() {\n    if (!this._root.data.MarkInfo) {\n      this._root.data.MarkInfo = this.ref({});\n    }\n    return this._root.data.MarkInfo;\n  },\n  hasMarkInfoDictionary() {\n    return !!this._root.data.MarkInfo;\n  },\n  getStructTreeRoot() {\n    if (!this._root.data.StructTreeRoot) {\n      this._root.data.StructTreeRoot = this.ref({\n        Type: 'StructTreeRoot',\n        ParentTree: new PDFNumberTree(),\n        ParentTreeNextKey: 0\n      });\n    }\n    return this._root.data.StructTreeRoot;\n  },\n  getStructParentTree() {\n    return this.getStructTreeRoot().data.ParentTree;\n  },\n  createStructParentTreeNextKey() {\n    this.getMarkInfoDictionary();\n    const structTreeRoot = this.getStructTreeRoot();\n    const key = structTreeRoot.data.ParentTreeNextKey++;\n    structTreeRoot.data.ParentTree.add(key, []);\n    return key;\n  },\n  endMarkings() {\n    const structTreeRoot = this._root.data.StructTreeRoot;\n    if (structTreeRoot) {\n      structTreeRoot.end();\n      this.structChildren.forEach(structElem => structElem.end());\n    }\n    if (this._root.data.MarkInfo) {\n      this._root.data.MarkInfo.end();\n    }\n  }\n};\n\nconst FIELD_FLAGS = {\n  readOnly: 1,\n  required: 2,\n  noExport: 4,\n  multiline: 0x1000,\n  password: 0x2000,\n  toggleToOffButton: 0x4000,\n  radioButton: 0x8000,\n  pushButton: 0x10000,\n  combo: 0x20000,\n  edit: 0x40000,\n  sort: 0x80000,\n  multiSelect: 0x200000,\n  noSpell: 0x400000\n};\nconst FIELD_JUSTIFY = {\n  left: 0,\n  center: 1,\n  right: 2\n};\nconst VALUE_MAP = {\n  value: 'V',\n  defaultValue: 'DV'\n};\nconst FORMAT_SPECIAL = {\n  zip: '0',\n  zipPlus4: '1',\n  zip4: '1',\n  phone: '2',\n  ssn: '3'\n};\nconst FORMAT_DEFAULT = {\n  number: {\n    nDec: 0,\n    sepComma: false,\n    negStyle: 'MinusBlack',\n    currency: '',\n    currencyPrepend: true\n  },\n  percent: {\n    nDec: 0,\n    sepComma: false\n  }\n};\nvar AcroFormMixin = {\n  initForm() {\n    if (!this._font) {\n      throw new Error('Must set a font before calling initForm method');\n    }\n    this._acroform = {\n      fonts: {},\n      defaultFont: this._font.name\n    };\n    this._acroform.fonts[this._font.id] = this._font.ref();\n    let data = {\n      Fields: [],\n      NeedAppearances: true,\n      DA: new String(`/${this._font.id} 0 Tf 0 g`),\n      DR: {\n        Font: {}\n      }\n    };\n    data.DR.Font[this._font.id] = this._font.ref();\n    const AcroForm = this.ref(data);\n    this._root.data.AcroForm = AcroForm;\n    return this;\n  },\n  endAcroForm() {\n    if (this._root.data.AcroForm) {\n      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {\n        throw new Error('No fonts specified for PDF form');\n      }\n      let fontDict = this._root.data.AcroForm.data.DR.Font;\n      Object.keys(this._acroform.fonts).forEach(name => {\n        fontDict[name] = this._acroform.fonts[name];\n      });\n      this._root.data.AcroForm.data.Fields.forEach(fieldRef => {\n        this._endChild(fieldRef);\n      });\n      this._root.data.AcroForm.end();\n    }\n    return this;\n  },\n  _endChild(ref) {\n    if (Array.isArray(ref.data.Kids)) {\n      ref.data.Kids.forEach(childRef => {\n        this._endChild(childRef);\n      });\n      ref.end();\n    }\n    return this;\n  },\n  formField(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fieldDict = this._fieldDict(name, null, options);\n    let fieldRef = this.ref(fieldDict);\n    this._addToParent(fieldRef);\n    return fieldRef;\n  },\n  formAnnotation(name, type, x, y, w, h) {\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    let fieldDict = this._fieldDict(name, type, options);\n    fieldDict.Subtype = 'Widget';\n    if (fieldDict.F === undefined) {\n      fieldDict.F = 4;\n    }\n    this.annotate(x, y, w, h, fieldDict);\n    let annotRef = this.page.annotations[this.page.annotations.length - 1];\n    return this._addToParent(annotRef);\n  },\n  formText(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'text', x, y, w, h, options);\n  },\n  formPushButton(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'pushButton', x, y, w, h, options);\n  },\n  formCombo(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'combo', x, y, w, h, options);\n  },\n  formList(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'list', x, y, w, h, options);\n  },\n  formRadioButton(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'radioButton', x, y, w, h, options);\n  },\n  formCheckbox(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'checkbox', x, y, w, h, options);\n  },\n  _addToParent(fieldRef) {\n    let parent = fieldRef.data.Parent;\n    if (parent) {\n      if (!parent.data.Kids) {\n        parent.data.Kids = [];\n      }\n      parent.data.Kids.push(fieldRef);\n    } else {\n      this._root.data.AcroForm.data.Fields.push(fieldRef);\n    }\n    return this;\n  },\n  _fieldDict(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!this._acroform) {\n      throw new Error('Call document.initForm() method before adding form elements to document');\n    }\n    let opts = Object.assign({}, options);\n    if (type !== null) {\n      opts = this._resolveType(type, options);\n    }\n    opts = this._resolveFlags(opts);\n    opts = this._resolveJustify(opts);\n    opts = this._resolveFont(opts);\n    opts = this._resolveStrings(opts);\n    opts = this._resolveColors(opts);\n    opts = this._resolveFormat(opts);\n    opts.T = new String(name);\n    if (opts.parent) {\n      opts.Parent = opts.parent;\n      delete opts.parent;\n    }\n    return opts;\n  },\n  _resolveType(type, opts) {\n    if (type === 'text') {\n      opts.FT = 'Tx';\n    } else if (type === 'pushButton') {\n      opts.FT = 'Btn';\n      opts.pushButton = true;\n    } else if (type === 'radioButton') {\n      opts.FT = 'Btn';\n      opts.radioButton = true;\n    } else if (type === 'checkbox') {\n      opts.FT = 'Btn';\n    } else if (type === 'combo') {\n      opts.FT = 'Ch';\n      opts.combo = true;\n    } else if (type === 'list') {\n      opts.FT = 'Ch';\n    } else {\n      throw new Error(`Invalid form annotation type '${type}'`);\n    }\n    return opts;\n  },\n  _resolveFormat(opts) {\n    const f = opts.format;\n    if (f && f.type) {\n      let fnKeystroke;\n      let fnFormat;\n      let params = '';\n      if (FORMAT_SPECIAL[f.type] !== undefined) {\n        fnKeystroke = `AFSpecial_Keystroke`;\n        fnFormat = `AFSpecial_Format`;\n        params = FORMAT_SPECIAL[f.type];\n      } else {\n        let format = f.type.charAt(0).toUpperCase() + f.type.slice(1);\n        fnKeystroke = `AF${format}_Keystroke`;\n        fnFormat = `AF${format}_Format`;\n        if (f.type === 'date') {\n          fnKeystroke += 'Ex';\n          params = String(f.param);\n        } else if (f.type === 'time') {\n          params = String(f.param);\n        } else if (f.type === 'number') {\n          let p = Object.assign({}, FORMAT_DEFAULT.number, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1', '\"' + p.negStyle + '\"', 'null', '\"' + p.currency + '\"', String(p.currencyPrepend)].join(','));\n        } else if (f.type === 'percent') {\n          let p = Object.assign({}, FORMAT_DEFAULT.percent, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1'].join(','));\n        }\n      }\n      opts.AA = opts.AA ? opts.AA : {};\n      opts.AA.K = {\n        S: 'JavaScript',\n        JS: new String(`${fnKeystroke}(${params});`)\n      };\n      opts.AA.F = {\n        S: 'JavaScript',\n        JS: new String(`${fnFormat}(${params});`)\n      };\n    }\n    delete opts.format;\n    return opts;\n  },\n  _resolveColors(opts) {\n    let color = this._normalizeColor(opts.backgroundColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BG = color;\n    }\n    color = this._normalizeColor(opts.borderColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BC = color;\n    }\n    delete opts.backgroundColor;\n    delete opts.borderColor;\n    return opts;\n  },\n  _resolveFlags(options) {\n    let result = 0;\n    Object.keys(options).forEach(key => {\n      if (FIELD_FLAGS[key]) {\n        if (options[key]) {\n          result |= FIELD_FLAGS[key];\n        }\n        delete options[key];\n      }\n    });\n    if (result !== 0) {\n      options.Ff = options.Ff ? options.Ff : 0;\n      options.Ff |= result;\n    }\n    return options;\n  },\n  _resolveJustify(options) {\n    let result = 0;\n    if (options.align !== undefined) {\n      if (typeof FIELD_JUSTIFY[options.align] === 'number') {\n        result = FIELD_JUSTIFY[options.align];\n      }\n      delete options.align;\n    }\n    if (result !== 0) {\n      options.Q = result;\n    }\n    return options;\n  },\n  _resolveFont(options) {\n    if (this._acroform.fonts[this._font.id] == null) {\n      this._acroform.fonts[this._font.id] = this._font.ref();\n    }\n    if (this._acroform.defaultFont !== this._font.name) {\n      options.DR = {\n        Font: {}\n      };\n      const fontSize = options.fontSize || 0;\n      options.DR.Font[this._font.id] = this._font.ref();\n      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);\n    }\n    return options;\n  },\n  _resolveStrings(options) {\n    let select = [];\n    function appendChoices(a) {\n      if (Array.isArray(a)) {\n        for (let idx = 0; idx < a.length; idx++) {\n          if (typeof a[idx] === 'string') {\n            select.push(new String(a[idx]));\n          } else {\n            select.push(a[idx]);\n          }\n        }\n      }\n    }\n    appendChoices(options.Opt);\n    if (options.select) {\n      appendChoices(options.select);\n      delete options.select;\n    }\n    if (select.length) {\n      options.Opt = select;\n    }\n    Object.keys(VALUE_MAP).forEach(key => {\n      if (options[key] !== undefined) {\n        options[VALUE_MAP[key]] = options[key];\n        delete options[key];\n      }\n    });\n    ['V', 'DV'].forEach(key => {\n      if (typeof options[key] === 'string') {\n        options[key] = new String(options[key]);\n      }\n    });\n    if (options.MK && options.MK.CA) {\n      options.MK.CA = new String(options.MK.CA);\n    }\n    if (options.label) {\n      options.MK = options.MK ? options.MK : {};\n      options.MK.CA = new String(options.label);\n      delete options.label;\n    }\n    return options;\n  }\n};\n\nvar AttachmentsMixin = {\n  file(src) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.name = options.name || src;\n    options.relationship = options.relationship || 'Unspecified';\n    const refBody = {\n      Type: 'EmbeddedFile',\n      Params: {}\n    };\n    let data;\n    if (!src) {\n      throw new Error('No src specified');\n    }\n    if (Buffer.isBuffer(src)) {\n      data = src;\n    } else if (src instanceof ArrayBuffer) {\n      data = Buffer.from(new Uint8Array(src));\n    } else {\n      const match = /^data:(.*?);base64,(.*)$/.exec(src);\n      if (match) {\n        if (match[1]) {\n          refBody.Subtype = match[1].replace('/', '#2F');\n        }\n        data = Buffer.from(match[2], 'base64');\n      } else {\n        data = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n        if (!data) {\n          throw new Error(`Could not read contents of file at filepath ${src}`);\n        }\n        const {\n          birthtime,\n          ctime\n        } = fs__WEBPACK_IMPORTED_MODULE_3___default().statSync(src);\n        refBody.Params.CreationDate = birthtime;\n        refBody.Params.ModDate = ctime;\n      }\n    }\n    if (options.creationDate instanceof Date) {\n      refBody.Params.CreationDate = options.creationDate;\n    }\n    if (options.modifiedDate instanceof Date) {\n      refBody.Params.ModDate = options.modifiedDate;\n    }\n    if (options.type) {\n      refBody.Subtype = options.type.replace('/', '#2F');\n    }\n    const checksum = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(new Uint8Array(data)));\n    refBody.Params.CheckSum = new String(checksum);\n    refBody.Params.Size = data.byteLength;\n    let ref;\n    if (!this._fileRegistry) this._fileRegistry = {};\n    let file = this._fileRegistry[options.name];\n    if (file && isEqual(refBody, file)) {\n      ref = file.ref;\n    } else {\n      ref = this.ref(refBody);\n      ref.end(data);\n      this._fileRegistry[options.name] = {\n        ...refBody,\n        ref\n      };\n    }\n    const fileSpecBody = {\n      Type: 'Filespec',\n      AFRelationship: options.relationship,\n      F: new String(options.name),\n      EF: {\n        F: ref\n      },\n      UF: new String(options.name)\n    };\n    if (options.description) {\n      fileSpecBody.Desc = new String(options.description);\n    }\n    const filespec = this.ref(fileSpecBody);\n    filespec.end();\n    if (!options.hidden) {\n      this.addNamedEmbeddedFile(options.name, filespec);\n    }\n    if (this._root.data.AF) {\n      this._root.data.AF.push(filespec);\n    } else {\n      this._root.data.AF = [filespec];\n    }\n    return filespec;\n  }\n};\nfunction isEqual(a, b) {\n  return a.Subtype === b.Subtype && a.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a.Params.Size === b.Params.Size && a.Params.CreationDate.getTime() === b.Params.CreationDate.getTime() && (a.Params.ModDate === undefined && b.Params.ModDate === undefined || a.Params.ModDate.getTime() === b.Params.ModDate.getTime());\n}\n\nvar PDFA = {\n  initPDFA(pSubset) {\n    if (pSubset.charAt(pSubset.length - 3) === '-') {\n      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));\n    } else {\n      this.subset_conformance = 'B';\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));\n    }\n  },\n  endSubset() {\n    this._addPdfaMetadata();\n    this._addColorOutputIntent();\n  },\n  _addColorOutputIntent() {\n    const iccProfile = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(`${__dirname}/data/sRGB_IEC61966_2_1.icc`);\n    const colorProfileRef = this.ref({\n      Length: iccProfile.length,\n      N: 3\n    });\n    colorProfileRef.write(iccProfile);\n    colorProfileRef.end();\n    const intentRef = this.ref({\n      Type: 'OutputIntent',\n      S: 'GTS_PDFA1',\n      Info: new String('sRGB IEC61966-2.1'),\n      OutputConditionIdentifier: new String('sRGB IEC61966-2.1'),\n      DestOutputProfile: colorProfileRef\n    });\n    intentRef.end();\n    this._root.data.OutputIntents = [intentRef];\n  },\n  _getPdfaid() {\n    return `\n        <rdf:Description xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\" rdf:about=\"\">\n            <pdfaid:part>${this.subset}</pdfaid:part>\n            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>\n        </rdf:Description>\n        `;\n  },\n  _addPdfaMetadata() {\n    this.appendXML(this._getPdfaid());\n  }\n};\n\nvar PDFUA = {\n  initPDFUA() {\n    this.subset = 1;\n  },\n  endSubset() {\n    this._addPdfuaMetadata();\n  },\n  _addPdfuaMetadata() {\n    this.appendXML(this._getPdfuaid());\n  },\n  _getPdfuaid() {\n    return `\n        <rdf:Description xmlns:pdfuaid=\"http://www.aiim.org/pdfua/ns/id/\" rdf:about=\"\">\n            <pdfuaid:part>${this.subset}</pdfuaid:part>\n        </rdf:Description>\n        `;\n  }\n};\n\nvar SubsetMixin = {\n  _importSubset(subset) {\n    Object.assign(this, subset);\n  },\n  initSubset(options) {\n    switch (options.subset) {\n      case 'PDF/A-1':\n      case 'PDF/A-1a':\n      case 'PDF/A-1b':\n      case 'PDF/A-2':\n      case 'PDF/A-2a':\n      case 'PDF/A-2b':\n      case 'PDF/A-3':\n      case 'PDF/A-3a':\n      case 'PDF/A-3b':\n        this._importSubset(PDFA);\n        this.initPDFA(options.subset);\n        break;\n      case 'PDF/UA':\n        this._importSubset(PDFUA);\n        this.initPDFUA();\n        break;\n    }\n  }\n};\n\nconst ROW_FIELDS = ['height', 'minHeight', 'maxHeight'];\nconst COLUMN_FIELDS = ['width', 'minWidth', 'maxWidth'];\nfunction memoize(fn, maxSize) {\n  const cache = new Map();\n  return function () {\n    const key = arguments.length <= 0 ? undefined : arguments[0];\n    if (!cache.has(key)) {\n      cache.set(key, fn(...arguments));\n      if (cache.size > maxSize) cache.delete(cache.keys().next());\n    }\n    return cache.get(key);\n  };\n}\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction deepMerge(target) {\n  if (!isObject(target)) return target;\n  target = deepClone(target);\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  for (const source of sources) {\n    if (isObject(source)) {\n      for (const key in source) {\n        if (isObject(source[key])) {\n          if (!(key in target)) target[key] = {};\n          target[key] = deepMerge(target[key], source[key]);\n        } else if (source[key] !== undefined) {\n          target[key] = deepClone(source[key]);\n        }\n      }\n    }\n  }\n  return target;\n}\nfunction deepClone(obj) {\n  let result = obj;\n  if (obj && typeof obj == 'object') {\n    result = Array.isArray(obj) ? [] : {};\n    for (const key in obj) result[key] = deepClone(obj[key]);\n  }\n  return result;\n}\n\nfunction normalizedDefaultStyle(defaultStyleInternal) {\n  let defaultStyle = defaultStyleInternal;\n  if (typeof defaultStyle !== 'object') defaultStyle = {\n    text: defaultStyle\n  };\n  const defaultRowStyle = Object.fromEntries(Object.entries(defaultStyle).filter(_ref => {\n    let [k] = _ref;\n    return ROW_FIELDS.includes(k);\n  }));\n  const defaultColStyle = Object.fromEntries(Object.entries(defaultStyle).filter(_ref2 => {\n    let [k] = _ref2;\n    return COLUMN_FIELDS.includes(k);\n  }));\n  defaultStyle.padding = normalizeSides(defaultStyle.padding);\n  defaultStyle.border = normalizeSides(defaultStyle.border);\n  defaultStyle.borderColor = normalizeSides(defaultStyle.borderColor);\n  defaultStyle.align = normalizeAlignment(defaultStyle.align);\n  return {\n    defaultStyle,\n    defaultRowStyle,\n    defaultColStyle\n  };\n}\nfunction normalizedRowStyle(defaultRowStyle, rowStyleInternal, i) {\n  let rowStyle = rowStyleInternal(i);\n  if (rowStyle == null || typeof rowStyle !== 'object') {\n    rowStyle = {\n      height: rowStyle\n    };\n  }\n  rowStyle.padding = normalizeSides(rowStyle.padding);\n  rowStyle.border = normalizeSides(rowStyle.border);\n  rowStyle.borderColor = normalizeSides(rowStyle.borderColor);\n  rowStyle.align = normalizeAlignment(rowStyle.align);\n  rowStyle = deepMerge(defaultRowStyle, rowStyle);\n  const document = this.document;\n  const page = document.page;\n  const contentHeight = page.contentHeight;\n  if (rowStyle.height == null || rowStyle.height === 'auto') {\n    rowStyle.height = 'auto';\n  } else {\n    rowStyle.height = document.sizeToPoint(rowStyle.height, 0, page, contentHeight);\n  }\n  rowStyle.minHeight = document.sizeToPoint(rowStyle.minHeight, 0, page, contentHeight);\n  rowStyle.maxHeight = document.sizeToPoint(rowStyle.maxHeight, 0, page, contentHeight);\n  return rowStyle;\n}\nfunction normalizedColumnStyle(defaultColStyle, colStyleInternal, i) {\n  let colStyle = colStyleInternal(i);\n  if (colStyle == null || typeof colStyle !== 'object') {\n    colStyle = {\n      width: colStyle\n    };\n  }\n  colStyle.padding = normalizeSides(colStyle.padding);\n  colStyle.border = normalizeSides(colStyle.border);\n  colStyle.borderColor = normalizeSides(colStyle.borderColor);\n  colStyle.align = normalizeAlignment(colStyle.align);\n  colStyle = deepMerge(defaultColStyle, colStyle);\n  if (colStyle.width == null || colStyle.width === '*') {\n    colStyle.width = '*';\n  } else {\n    colStyle.width = this.document.sizeToPoint(colStyle.width, 0, this.document.page, this._maxWidth);\n  }\n  colStyle.minWidth = this.document.sizeToPoint(colStyle.minWidth, 0, this.document.page, this._maxWidth);\n  colStyle.maxWidth = this.document.sizeToPoint(colStyle.maxWidth, 0, this.document.page, this._maxWidth);\n  return colStyle;\n}\nfunction normalizeAlignment(align) {\n  return align == null || typeof align === 'string' ? {\n    x: align,\n    y: align\n  } : align;\n}\n\nfunction normalizeTable() {\n  const doc = this.document;\n  const opts = this.opts;\n  let index = doc._tableIndex++;\n  this._id = new String(opts.id ?? `table-${index}`);\n  this._position = {\n    x: doc.sizeToPoint(opts.position?.x, doc.x),\n    y: doc.sizeToPoint(opts.position?.y, doc.y)\n  };\n  this._maxWidth = doc.sizeToPoint(opts.maxWidth, doc.page.width - doc.page.margins.right - this._position.x);\n  const {\n    defaultStyle,\n    defaultColStyle,\n    defaultRowStyle\n  } = normalizedDefaultStyle(opts.defaultStyle);\n  this._defaultStyle = defaultStyle;\n  let colStyle;\n  if (opts.columnStyles) {\n    if (Array.isArray(opts.columnStyles)) {\n      colStyle = i => opts.columnStyles[i];\n    } else if (typeof opts.columnStyles === 'function') {\n      colStyle = memoize(i => opts.columnStyles(i), Infinity);\n    } else if (typeof opts.columnStyles === 'object') {\n      colStyle = () => opts.columnStyles;\n    }\n  }\n  if (!colStyle) colStyle = () => ({});\n  this._colStyle = normalizedColumnStyle.bind(this, defaultColStyle, colStyle);\n  let rowStyle;\n  if (opts.rowStyles) {\n    if (Array.isArray(opts.rowStyles)) {\n      rowStyle = i => opts.rowStyles[i];\n    } else if (typeof opts.rowStyles === 'function') {\n      rowStyle = memoize(i => opts.rowStyles(i), 10);\n    } else if (typeof opts.rowStyles === 'object') {\n      rowStyle = () => opts.rowStyles;\n    }\n  }\n  if (!rowStyle) rowStyle = () => ({});\n  this._rowStyle = normalizedRowStyle.bind(this, defaultRowStyle, rowStyle);\n}\nfunction normalizeText(text) {\n  if (text != null) text = `${text}`;\n  return text;\n}\nfunction normalizeCell(cell, rowIndex, colIndex) {\n  const colStyle = this._colStyle(colIndex);\n  let rowStyle = this._rowStyle(rowIndex);\n  const font = deepMerge({}, colStyle.font, rowStyle.font, cell.font);\n  const customFont = Object.values(font).filter(v => v != null).length > 0;\n  const doc = this.document;\n  const rollbackFont = doc._fontSource;\n  const rollbackFontSize = doc._fontSize;\n  const rollbackFontFamily = doc._fontFamily;\n  if (customFont) {\n    if (font.src) doc.font(font.src, font.family);\n    if (font.size) doc.fontSize(font.size);\n    rowStyle = this._rowStyle(rowIndex);\n  }\n  cell.padding = normalizeSides(cell.padding);\n  cell.border = normalizeSides(cell.border);\n  cell.borderColor = normalizeSides(cell.borderColor);\n  const config = deepMerge(this._defaultStyle, colStyle, rowStyle, cell);\n  config.rowIndex = rowIndex;\n  config.colIndex = colIndex;\n  config.font = font ?? {};\n  config.customFont = customFont;\n  config.text = normalizeText(config.text);\n  config.rowSpan = config.rowSpan ?? 1;\n  config.colSpan = config.colSpan ?? 1;\n  config.padding = normalizeSides(config.padding, '0.25em', x => doc.sizeToPoint(x, '0.25em'));\n  config.border = normalizeSides(config.border, 1, x => doc.sizeToPoint(x, 1));\n  config.borderColor = normalizeSides(config.borderColor, 'black', x => x ?? 'black');\n  config.align = normalizeAlignment(config.align);\n  config.align.x = config.align.x ?? 'left';\n  config.align.y = config.align.y ?? 'top';\n  config.textStroke = doc.sizeToPoint(config.textStroke, 0);\n  config.textStrokeColor = config.textStrokeColor ?? 'black';\n  config.textColor = config.textColor ?? 'black';\n  config.textOptions = config.textOptions ?? {};\n  config.id = new String(config.id ?? `${this._id}-${rowIndex}-${colIndex}`);\n  config.type = config.type?.toUpperCase() === 'TH' ? 'TH' : 'TD';\n  if (config.scope) {\n    config.scope = config.scope.toLowerCase();\n    if (config.scope === 'row') config.scope = 'Row';else if (config.scope === 'both') config.scope = 'Both';else if (config.scope === 'column') config.scope = 'Column';\n  }\n  if (typeof this.opts.debug === 'boolean') config.debug = this.opts.debug;\n  if (customFont) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n  return config;\n}\nfunction normalizeRow(row, rowIndex) {\n  if (!this._cellClaim) this._cellClaim = new Set();\n  let colIndex = 0;\n  return row.map(cell => {\n    if (cell == null || typeof cell !== 'object') cell = {\n      text: cell\n    };\n    while (this._cellClaim.has(`${rowIndex},${colIndex}`)) {\n      colIndex++;\n    }\n    cell = normalizeCell.call(this, cell, rowIndex, colIndex);\n    for (let i = 0; i < cell.rowSpan; i++) {\n      for (let j = 0; j < cell.colSpan; j++) {\n        this._cellClaim.add(`${rowIndex + i},${colIndex + j}`);\n      }\n    }\n    colIndex += cell.colSpan;\n    return cell;\n  });\n}\n\nfunction ensure(row) {\n  this._columnWidths = [];\n  ensureColumnWidths.call(this, row.reduce((a, cell) => a + cell.colSpan, 0));\n  this._rowHeights = [];\n  this._rowYPos = [this._position.y];\n  this._rowBuffer = new Set();\n}\nfunction ensureColumnWidths(numCols) {\n  let starColumnIndexes = [];\n  let starMinAcc = 0;\n  let unclaimedWidth = this._maxWidth;\n  for (let i = 0; i < numCols; i++) {\n    let col = this._colStyle(i);\n    if (col.width === '*') {\n      starColumnIndexes[i] = col;\n      starMinAcc += col.minWidth;\n    } else {\n      unclaimedWidth -= col.width;\n      this._columnWidths[i] = col.width;\n    }\n  }\n  let starColCount = starColumnIndexes.reduce(x => x + 1, 0);\n  if (starMinAcc >= unclaimedWidth) {\n    starColumnIndexes.forEach((cell, i) => {\n      this._columnWidths[i] = cell.minWidth;\n    });\n  } else if (starColCount > 0) {\n    starColumnIndexes.forEach((col, i) => {\n      let starSize = unclaimedWidth / starColCount;\n      this._columnWidths[i] = Math.max(starSize, col.minWidth);\n      if (col.maxWidth > 0) {\n        this._columnWidths[i] = Math.min(this._columnWidths[i], col.maxWidth);\n      }\n      unclaimedWidth -= this._columnWidths[i];\n      starColCount--;\n    });\n  }\n  let tempX = this._position.x;\n  this._columnXPos = Array.from(this._columnWidths, v => {\n    const t = tempX;\n    tempX += v;\n    return t;\n  });\n}\nfunction measure(row, rowIndex) {\n  row.forEach(cell => this._rowBuffer.add(cell));\n  if (rowIndex > 0) {\n    this._rowYPos[rowIndex] = this._rowYPos[rowIndex - 1] + this._rowHeights[rowIndex - 1];\n  }\n  const rowStyle = this._rowStyle(rowIndex);\n  let toRender = [];\n  this._rowBuffer.forEach(cell => {\n    if (cell.rowIndex + cell.rowSpan - 1 === rowIndex) {\n      toRender.push(measureCell.call(this, cell, rowStyle.height));\n      this._rowBuffer.delete(cell);\n    }\n  });\n  let rowHeight = rowStyle.height;\n  if (rowHeight === 'auto') {\n    rowHeight = toRender.reduce((acc, cell) => {\n      let minHeight = cell.textBounds.height + cell.padding.top + cell.padding.bottom;\n      for (let i = 0; i < cell.rowSpan - 1; i++) {\n        minHeight -= this._rowHeights[cell.rowIndex + i];\n      }\n      return Math.max(acc, minHeight);\n    }, 0);\n  }\n  rowHeight = Math.max(rowHeight, rowStyle.minHeight);\n  if (rowStyle.maxHeight > 0) {\n    rowHeight = Math.min(rowHeight, rowStyle.maxHeight);\n  }\n  this._rowHeights[rowIndex] = rowHeight;\n  let newPage = false;\n  if (rowHeight > this.document.page.contentHeight) {\n    console.warn(new Error(`Row ${rowIndex} requested more than the safe page height, row has been clamped`).stack.slice(7));\n    this._rowHeights[rowIndex] = this.document.page.maxY() - this._rowYPos[rowIndex];\n  } else if (this._rowYPos[rowIndex] + rowHeight >= this.document.page.maxY()) {\n    this._rowYPos[rowIndex] = this.document.page.margins.top;\n    newPage = true;\n  }\n  return {\n    newPage,\n    toRender: toRender.map(cell => measureCell.call(this, cell, rowHeight))\n  };\n}\nfunction measureCell(cell, rowHeight) {\n  let cellWidth = 0;\n  for (let i = 0; i < cell.colSpan; i++) {\n    cellWidth += this._columnWidths[cell.colIndex + i];\n  }\n  let cellHeight = rowHeight;\n  if (cellHeight === 'auto') {\n    cellHeight = this.document.page.contentHeight;\n  } else {\n    for (let i = 0; i < cell.rowSpan - 1; i++) {\n      cellHeight += this._rowHeights[cell.rowIndex + i];\n    }\n  }\n  const textAllocatedWidth = cellWidth - cell.padding.left - cell.padding.right;\n  const textAllocatedHeight = cellHeight - cell.padding.top - cell.padding.bottom;\n  const rotation = cell.textOptions.rotation ?? 0;\n  const {\n    width: textMaxWidth,\n    height: textMaxHeight\n  } = computeBounds(rotation, textAllocatedWidth, textAllocatedHeight);\n  const textOptions = {\n    align: cell.align.x,\n    ellipsis: true,\n    stroke: cell.textStroke > 0,\n    fill: true,\n    width: textMaxWidth,\n    height: textMaxHeight,\n    rotation,\n    ...cell.textOptions\n  };\n  let textBounds = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  if (cell.text) {\n    const rollbackFont = this.document._fontSource;\n    const rollbackFontSize = this.document._fontSize;\n    const rollbackFontFamily = this.document._fontFamily;\n    if (cell.font?.src) this.document.font(cell.font.src, cell.font?.family);\n    if (cell.font?.size) this.document.fontSize(cell.font.size);\n    const unRotatedTextBounds = this.document.boundsOfString(cell.text, 0, 0, {\n      ...textOptions,\n      rotation: 0\n    });\n    textOptions.width = unRotatedTextBounds.width;\n    textOptions.height = unRotatedTextBounds.height;\n    textBounds = this.document.boundsOfString(cell.text, 0, 0, textOptions);\n    this.document.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n  }\n  return {\n    ...cell,\n    textOptions,\n    x: this._columnXPos[cell.colIndex],\n    y: this._rowYPos[cell.rowIndex],\n    textX: this._columnXPos[cell.colIndex] + cell.padding.left,\n    textY: this._rowYPos[cell.rowIndex] + cell.padding.top,\n    width: cellWidth,\n    height: cellHeight,\n    textAllocatedHeight,\n    textAllocatedWidth,\n    textBounds\n  };\n}\nfunction computeBounds(rotation, allocWidth, allocHeight) {\n  let textMaxWidth, textMaxHeight;\n  const cos = cosine(rotation);\n  const sin = sine(rotation);\n  if (rotation === 0 || rotation === 180) {\n    textMaxWidth = allocWidth;\n    textMaxHeight = allocHeight;\n  } else if (rotation === 90 || rotation === 270) {\n    textMaxWidth = allocHeight;\n    textMaxHeight = allocWidth;\n  } else if (rotation < 90 || rotation > 180 && rotation < 270) {\n    textMaxWidth = allocWidth / (2 * cos);\n    textMaxHeight = allocWidth / (2 * sin);\n  } else {\n    textMaxHeight = allocWidth / (2 * cos);\n    textMaxWidth = allocWidth / (2 * sin);\n  }\n  const EF = sin * textMaxWidth;\n  const FG = cos * textMaxHeight;\n  if (EF + FG > allocHeight) {\n    const denominator = cos * cos - sin * sin;\n    if (rotation === 0 || rotation === 180) {\n      textMaxWidth = allocWidth;\n      textMaxHeight = allocHeight;\n    } else if (rotation === 90 || rotation === 270) {\n      textMaxWidth = allocHeight;\n      textMaxHeight = allocWidth;\n    } else if (rotation < 90 || rotation > 180 && rotation < 270) {\n      textMaxWidth = (allocWidth * cos - allocHeight * sin) / denominator;\n      textMaxHeight = (allocHeight * cos - allocWidth * sin) / denominator;\n    } else {\n      textMaxHeight = (allocWidth * cos - allocHeight * sin) / denominator;\n      textMaxWidth = (allocHeight * cos - allocWidth * sin) / denominator;\n    }\n  }\n  return {\n    width: Math.abs(textMaxWidth),\n    height: Math.abs(textMaxHeight)\n  };\n}\n\nfunction accommodateTable() {\n  const structParent = this.opts.structParent;\n  if (structParent) {\n    this._tableStruct = this.document.struct('Table');\n    this._tableStruct.dictionary.data.ID = this._id;\n    if (structParent instanceof PDFStructureElement) {\n      structParent.add(this._tableStruct);\n    } else if (structParent instanceof PDFDocument) {\n      structParent.addStructure(this._tableStruct);\n    }\n    this._headerRowLookup = {};\n    this._headerColumnLookup = {};\n  }\n}\nfunction accommodateCleanup() {\n  if (this._tableStruct) this._tableStruct.end();\n}\nfunction accessibleRow(row, rowIndex, renderCell) {\n  const rowStruct = this.document.struct('TR');\n  rowStruct.dictionary.data.ID = new String(`${this._id}-${rowIndex}`);\n  this._tableStruct.add(rowStruct);\n  row.forEach(cell => renderCell(cell, rowStruct));\n  rowStruct.end();\n}\nfunction accessibleCell(cell, rowStruct, callback) {\n  const doc = this.document;\n  const cellStruct = doc.struct(cell.type, {\n    title: cell.title\n  });\n  cellStruct.dictionary.data.ID = cell.id;\n  rowStruct.add(cellStruct);\n  const padding = cell.padding;\n  const border = cell.border;\n  const attributes = {\n    O: 'Table',\n    Width: cell.width,\n    Height: cell.height,\n    Padding: [padding.top, padding.bottom, padding.left, padding.right],\n    RowSpan: cell.rowSpan > 1 ? cell.rowSpan : undefined,\n    ColSpan: cell.colSpan > 1 ? cell.colSpan : undefined,\n    BorderThickness: [border.top, border.bottom, border.left, border.right]\n  };\n  if (cell.type === 'TH') {\n    if (cell.scope === 'Row' || cell.scope === 'Both') {\n      for (let i = 0; i < cell.rowSpan; i++) {\n        if (!this._headerRowLookup[cell.rowIndex + i]) {\n          this._headerRowLookup[cell.rowIndex + i] = [];\n        }\n        this._headerRowLookup[cell.rowIndex + i].push(cell.id);\n      }\n      attributes.Scope = cell.scope;\n    }\n    if (cell.scope === 'Column' || cell.scope === 'Both') {\n      for (let i = 0; i < cell.colSpan; i++) {\n        if (!this._headerColumnLookup[cell.colIndex + i]) {\n          this._headerColumnLookup[cell.colIndex + i] = [];\n        }\n        this._headerColumnLookup[cell.colIndex + i].push(cell.id);\n      }\n      attributes.Scope = cell.scope;\n    }\n  }\n  const Headers = new Set([...Array.from({\n    length: cell.colSpan\n  }, (_, i) => this._headerColumnLookup[cell.colIndex + i]).flat(), ...Array.from({\n    length: cell.rowSpan\n  }, (_, i) => this._headerRowLookup[cell.rowIndex + i]).flat()].filter(Boolean));\n  if (Headers.size) attributes.Headers = Array.from(Headers);\n  const normalizeColor = doc._normalizeColor;\n  if (cell.backgroundColor != null) {\n    attributes.BackgroundColor = normalizeColor(cell.backgroundColor);\n  }\n  const hasBorder = [border.top, border.bottom, border.left, border.right];\n  if (hasBorder.some(x => x)) {\n    const borderColor = cell.borderColor;\n    attributes.BorderColor = [hasBorder[0] ? normalizeColor(borderColor.top) : null, hasBorder[1] ? normalizeColor(borderColor.bottom) : null, hasBorder[2] ? normalizeColor(borderColor.left) : null, hasBorder[3] ? normalizeColor(borderColor.right) : null];\n  }\n  Object.keys(attributes).forEach(key => attributes[key] === undefined && delete attributes[key]);\n  cellStruct.dictionary.data.A = doc.ref(attributes);\n  cellStruct.add(callback);\n  cellStruct.end();\n  cellStruct.dictionary.data.A.end();\n}\n\nfunction renderRow(row, rowIndex) {\n  if (this._tableStruct) {\n    accessibleRow.call(this, row, rowIndex, renderCell.bind(this));\n  } else {\n    row.forEach(cell => renderCell.call(this, cell));\n  }\n  return this._rowYPos[rowIndex] + this._rowHeights[rowIndex];\n}\nfunction renderCell(cell, rowStruct) {\n  const cellRenderer = () => {\n    if (cell.backgroundColor != null) {\n      this.document.save().rect(cell.x, cell.y, cell.width, cell.height).fill(cell.backgroundColor).restore();\n    }\n    renderBorder.call(this, cell.border, cell.borderColor, cell.x, cell.y, cell.width, cell.height);\n    if (cell.debug) {\n      this.document.save();\n      this.document.dash(1, {\n        space: 1\n      }).lineWidth(1).strokeOpacity(0.3);\n      this.document.rect(cell.x, cell.y, cell.width, cell.height).stroke('green');\n      this.document.restore();\n    }\n    if (cell.text) renderCellText.call(this, cell);\n  };\n  if (rowStruct) accessibleCell.call(this, cell, rowStruct, cellRenderer);else cellRenderer();\n}\nfunction renderCellText(cell) {\n  const doc = this.document;\n  const rollbackFont = doc._fontSource;\n  const rollbackFontSize = doc._fontSize;\n  const rollbackFontFamily = doc._fontFamily;\n  if (cell.customFont) {\n    if (cell.font.src) doc.font(cell.font.src, cell.font.family);\n    if (cell.font.size) doc.fontSize(cell.font.size);\n  }\n  const x = cell.textX;\n  const y = cell.textY;\n  const Ah = cell.textAllocatedHeight;\n  const Aw = cell.textAllocatedWidth;\n  const Cw = cell.textBounds.width;\n  const Ch = cell.textBounds.height;\n  const Ox = -cell.textBounds.x;\n  const Oy = -cell.textBounds.y;\n  const PxScale = cell.align.x === 'right' ? 1 : cell.align.x === 'center' ? 0.5 : 0;\n  const Px = (Aw - Cw) * PxScale;\n  const PyScale = cell.align.y === 'bottom' ? 1 : cell.align.y === 'center' ? 0.5 : 0;\n  const Py = (Ah - Ch) * PyScale;\n  const dx = Px + Ox;\n  const dy = Py + Oy;\n  if (cell.debug) {\n    doc.save();\n    doc.dash(1, {\n      space: 1\n    }).lineWidth(1).strokeOpacity(0.3);\n    if (cell.text) {\n      doc.moveTo(x + Px, y).lineTo(x + Px, y + Ah).moveTo(x + Px + Cw, y).lineTo(x + Px + Cw, y + Ah).stroke('blue').moveTo(x, y + Py).lineTo(x + Aw, y + Py).moveTo(x, y + Py + Ch).lineTo(x + Aw, y + Py + Ch).stroke('green');\n    }\n    doc.rect(x, y, Aw, Ah).stroke('orange');\n    doc.restore();\n  }\n  doc.save().rect(x, y, Aw, Ah).clip();\n  doc.fillColor(cell.textColor).strokeColor(cell.textStrokeColor);\n  if (cell.textStroke > 0) doc.lineWidth(cell.textStroke);\n  doc.text(cell.text, x + dx, y + dy, cell.textOptions);\n  doc.restore();\n  if (cell.font) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n}\nfunction renderBorder(border, borderColor, x, y, width, height, mask) {\n  border = Object.fromEntries(Object.entries(border).map(_ref => {\n    let [k, v] = _ref;\n    return [k, mask && !mask[k] ? 0 : v];\n  }));\n  const doc = this.document;\n  if ([border.right, border.bottom, border.left].every(val => val === border.top)) {\n    if (border.top > 0) {\n      doc.save().lineWidth(border.top).rect(x, y, width, height).stroke(borderColor.top).restore();\n    }\n  } else {\n    if (border.top > 0) {\n      doc.save().lineWidth(border.top).moveTo(x, y).lineTo(x + width, y).stroke(borderColor.top).restore();\n    }\n    if (border.right > 0) {\n      doc.save().lineWidth(border.right).moveTo(x + width, y).lineTo(x + width, y + height).stroke(borderColor.right).restore();\n    }\n    if (border.bottom > 0) {\n      doc.save().lineWidth(border.bottom).moveTo(x + width, y + height).lineTo(x, y + height).stroke(borderColor.bottom).restore();\n    }\n    if (border.left > 0) {\n      doc.save().lineWidth(border.left).moveTo(x, y + height).lineTo(x, y).stroke(borderColor.left).restore();\n    }\n  }\n}\n\nclass PDFTable {\n  constructor(document) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.document = document;\n    this.opts = Object.freeze(opts);\n    normalizeTable.call(this);\n    accommodateTable.call(this);\n    this._currRowIndex = 0;\n    this._ended = false;\n    if (opts.data) {\n      for (const row of opts.data) this.row(row);\n      return this.end();\n    }\n  }\n  row(row) {\n    let lastRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this._ended) {\n      throw new Error(`Table was marked as ended on row ${this._currRowIndex}`);\n    }\n    row = Array.from(row);\n    row = normalizeRow.call(this, row, this._currRowIndex);\n    if (this._currRowIndex === 0) ensure.call(this, row);\n    const {\n      newPage,\n      toRender\n    } = measure.call(this, row, this._currRowIndex);\n    if (newPage) this.document.continueOnNewPage();\n    const yPos = renderRow.call(this, toRender, this._currRowIndex);\n    this.document.x = this._position.x;\n    this.document.y = yPos;\n    if (lastRow) return this.end();\n    this._currRowIndex++;\n    return this;\n  }\n  end() {\n    while (this._rowBuffer?.size) this.row([]);\n    this._ended = true;\n    accommodateCleanup.call(this);\n    return this.document;\n  }\n}\n\nvar TableMixin = {\n  initTables() {\n    this._tableIndex = 0;\n  },\n  table(opts) {\n    return new PDFTable(this, opts);\n  }\n};\n\nclass PDFMetadata {\n  constructor() {\n    this._metadata = `\n        <?xpacket begin=\"\\ufeff\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n            <x:xmpmeta xmlns:x=\"adobe:ns:meta/\">\n                <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n        `;\n  }\n  _closeTags() {\n    this._metadata = this._metadata.concat(`\n                </rdf:RDF>\n            </x:xmpmeta>\n        <?xpacket end=\"w\"?>\n        `);\n  }\n  append(xml) {\n    let newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._metadata = this._metadata.concat(xml);\n    if (newline) this._metadata = this._metadata.concat('\\n');\n  }\n  getXML() {\n    return this._metadata;\n  }\n  getLength() {\n    return this._metadata.length;\n  }\n  end() {\n    this._closeTags();\n    this._metadata = this._metadata.trim();\n  }\n}\n\nvar MetadataMixin = {\n  initMetadata() {\n    this.metadata = new PDFMetadata();\n  },\n  appendXML(xml) {\n    let newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.metadata.append(xml, newline);\n  },\n  _addInfo() {\n    this.appendXML(`\n        <rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">\n            <xmp:CreateDate>${this.info.CreationDate.toISOString().split('.')[0] + 'Z'}</xmp:CreateDate>\n            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>\n        </rdf:Description>\n        `);\n    if (this.info.Title || this.info.Author || this.info.Subject) {\n      this.appendXML(`\n            <rdf:Description rdf:about=\"\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n            `);\n      if (this.info.Title) {\n        this.appendXML(`\n                <dc:title>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Title}</rdf:li>\n                    </rdf:Alt>\n                </dc:title>\n                `);\n      }\n      if (this.info.Author) {\n        this.appendXML(`\n                <dc:creator>\n                    <rdf:Seq>\n                        <rdf:li>${this.info.Author}</rdf:li>\n                    </rdf:Seq>\n                </dc:creator>\n                `);\n      }\n      if (this.info.Subject) {\n        this.appendXML(`\n                <dc:description>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Subject}</rdf:li>\n                    </rdf:Alt>\n                </dc:description>\n                `);\n      }\n      this.appendXML(`\n            </rdf:Description>\n            `);\n    }\n    this.appendXML(`\n        <rdf:Description rdf:about=\"\" xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">\n            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);\n    if (this.info.Keywords) {\n      this.appendXML(`\n            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);\n    }\n    this.appendXML(`\n        </rdf:Description>\n        `);\n  },\n  endMetadata() {\n    this._addInfo();\n    this.metadata.end();\n    if (this.version != 1.3) {\n      this.metadataRef = this.ref({\n        length: this.metadata.getLength(),\n        Type: 'Metadata',\n        Subtype: 'XML'\n      });\n      this.metadataRef.compress = false;\n      this.metadataRef.write(Buffer.from(this.metadata.getXML(), 'utf-8'));\n      this.metadataRef.end();\n      this._root.data.Metadata = this.metadataRef;\n    }\n  }\n};\n\nclass PDFDocument extends (stream__WEBPACK_IMPORTED_MODULE_0___default().Readable) {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this.options = options;\n    switch (options.pdfVersion) {\n      case '1.4':\n        this.version = 1.4;\n        break;\n      case '1.5':\n        this.version = 1.5;\n        break;\n      case '1.6':\n        this.version = 1.6;\n        break;\n      case '1.7':\n      case '1.7ext3':\n        this.version = 1.7;\n        break;\n      default:\n        this.version = 1.3;\n        break;\n    }\n    this.compress = this.options.compress != null ? this.options.compress : true;\n    this._pageBuffer = [];\n    this._pageBufferStart = 0;\n    this._offsets = [];\n    this._waiting = 0;\n    this._ended = false;\n    this._offset = 0;\n    const Pages = this.ref({\n      Type: 'Pages',\n      Count: 0,\n      Kids: []\n    });\n    const Names = this.ref({\n      Dests: new PDFNameTree()\n    });\n    this._root = this.ref({\n      Type: 'Catalog',\n      Pages,\n      Names\n    });\n    if (this.options.lang) {\n      this._root.data.Lang = new String(this.options.lang);\n    }\n    this.page = null;\n    this.initMetadata();\n    this.initColor();\n    this.initVector();\n    this.initFonts(options.font);\n    this.initText();\n    this.initImages();\n    this.initOutline();\n    this.initMarkings(options);\n    this.initTables();\n    this.initSubset(options);\n    this.info = {\n      Producer: 'PDFKit',\n      Creator: 'PDFKit',\n      CreationDate: new Date()\n    };\n    if (this.options.info) {\n      for (let key in this.options.info) {\n        const val = this.options.info[key];\n        this.info[key] = val;\n      }\n    }\n    if (this.options.displayTitle) {\n      this._root.data.ViewerPreferences = this.ref({\n        DisplayDocTitle: true\n      });\n    }\n    this._id = PDFSecurity.generateFileID(this.info);\n    this._security = PDFSecurity.create(this, options);\n    this._write(`%PDF-${this.version}`);\n    this._write('%\\xFF\\xFF\\xFF\\xFF');\n    if (this.options.autoFirstPage !== false) {\n      this.addPage();\n    }\n  }\n  addPage(options) {\n    if (options == null) {\n      ({\n        options\n      } = this);\n    }\n    if (!this.options.bufferPages) {\n      this.flushPages();\n    }\n    this.page = new PDFPage(this, options);\n    this._pageBuffer.push(this.page);\n    const pages = this._root.data.Pages.data;\n    pages.Kids.push(this.page.dictionary);\n    pages.Count++;\n    this.x = this.page.margins.left;\n    this.y = this.page.margins.top;\n    this._ctm = [1, 0, 0, 1, 0, 0];\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    this.emit('pageAdded');\n    return this;\n  }\n  continueOnNewPage(options) {\n    const pageMarkings = this.endPageMarkings(this.page);\n    this.addPage(options ?? this.page._options);\n    this.initPageMarkings(pageMarkings);\n    return this;\n  }\n  bufferedPageRange() {\n    return {\n      start: this._pageBufferStart,\n      count: this._pageBuffer.length\n    };\n  }\n  switchToPage(n) {\n    let page;\n    if (!(page = this._pageBuffer[n - this._pageBufferStart])) {\n      throw new Error(`switchToPage(${n}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);\n    }\n    return this.page = page;\n  }\n  flushPages() {\n    const pages = this._pageBuffer;\n    this._pageBuffer = [];\n    this._pageBufferStart += pages.length;\n    for (let page of pages) {\n      this.endPageMarkings(page);\n      page.end();\n    }\n  }\n  addNamedDestination(name) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (args.length === 0) {\n      args = ['XYZ', null, null, null];\n    }\n    if (args[0] === 'XYZ' && args[2] !== null) {\n      args[2] = this.page.height - args[2];\n    }\n    args.unshift(this.page.dictionary);\n    this._root.data.Names.data.Dests.add(name, args);\n  }\n  addNamedEmbeddedFile(name, ref) {\n    if (!this._root.data.Names.data.EmbeddedFiles) {\n      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({\n        limits: false\n      });\n    }\n    this._root.data.Names.data.EmbeddedFiles.add(name, ref);\n  }\n  addNamedJavaScript(name, js) {\n    if (!this._root.data.Names.data.JavaScript) {\n      this._root.data.Names.data.JavaScript = new PDFNameTree();\n    }\n    let data = {\n      JS: new String(js),\n      S: 'JavaScript'\n    };\n    this._root.data.Names.data.JavaScript.add(name, data);\n  }\n  ref(data) {\n    const ref = new PDFReference(this, this._offsets.length + 1, data);\n    this._offsets.push(null);\n    this._waiting++;\n    return ref;\n  }\n  _read() {}\n  _write(data) {\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data + '\\n', 'binary');\n    }\n    this.push(data);\n    this._offset += data.length;\n  }\n  addContent(data) {\n    this.page.write(data);\n    return this;\n  }\n  _refEnd(ref) {\n    this._offsets[ref.id - 1] = ref.offset;\n    if (--this._waiting === 0 && this._ended) {\n      this._finalize();\n      this._ended = false;\n    }\n  }\n  end() {\n    this.flushPages();\n    this._info = this.ref();\n    for (let key in this.info) {\n      let val = this.info[key];\n      if (typeof val === 'string') {\n        val = new String(val);\n      }\n      let entry = this.ref(val);\n      entry.end();\n      this._info.data[key] = entry;\n    }\n    this._info.end();\n    for (let name in this._fontFamilies) {\n      const font = this._fontFamilies[name];\n      font.finalize();\n    }\n    this.endOutline();\n    this.endMarkings();\n    if (this.subset) {\n      this.endSubset();\n    }\n    this.endMetadata();\n    this._root.end();\n    this._root.data.Pages.end();\n    this._root.data.Names.end();\n    this.endAcroForm();\n    if (this._root.data.ViewerPreferences) {\n      this._root.data.ViewerPreferences.end();\n    }\n    if (this._security) {\n      this._security.end();\n    }\n    if (this._waiting === 0) {\n      this._finalize();\n    } else {\n      this._ended = true;\n    }\n  }\n  _finalize() {\n    const xRefOffset = this._offset;\n    this._write('xref');\n    this._write(`0 ${this._offsets.length + 1}`);\n    this._write('0000000000 65535 f ');\n    for (let offset of this._offsets) {\n      offset = `0000000000${offset}`.slice(-10);\n      this._write(offset + ' 00000 n ');\n    }\n    const trailer = {\n      Size: this._offsets.length + 1,\n      Root: this._root,\n      Info: this._info,\n      ID: [this._id, this._id]\n    };\n    if (this._security) {\n      trailer.Encrypt = this._security.dictionary;\n    }\n    this._write('trailer');\n    this._write(PDFObject.convert(trailer));\n    this._write('startxref');\n    this._write(`${xRefOffset}`);\n    this._write('%%EOF');\n    this.push(null);\n  }\n  toString() {\n    return '[object PDFDocument]';\n  }\n}\nconst mixin = methods => {\n  Object.assign(PDFDocument.prototype, methods);\n};\nmixin(MetadataMixin);\nmixin(ColorMixin);\nmixin(VectorMixin);\nmixin(FontsMixin);\nmixin(TextMixin);\nmixin(ImagesMixin);\nmixin(AnnotationsMixin);\nmixin(OutlineMixin);\nmixin(MarkingsMixin);\nmixin(AcroFormMixin);\nmixin(AttachmentsMixin);\nmixin(SubsetMixin);\nmixin(TableMixin);\nPDFDocument.LineWrapper = LineWrapper;\n\n\n//# sourceMappingURL=pdfkit.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wZGZraXRAMC4xNy4xL25vZGVfbW9kdWxlcy9wZGZraXQvanMvcGRma2l0LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEI7QUFDSjtBQUNTO0FBQ2I7QUFDZTtBQUNHO0FBQ0Y7QUFDUDtBQUNKOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRUFBcUU7QUFDakc7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0Esc0JBQXNCLDBDQUEwQyxFQUFFLG9DQUFvQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixNQUFNO0FBQ047QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLE1BQU07QUFDTixpQkFBaUIsdUJBQXVCO0FBQ3hDLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTix3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkIsTUFBTSxXQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLEVBQUUsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLEVBQUUsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEVBQUUsVUFBVTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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K0IsTUFBTTtBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBLDhCQUE4QixHQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSxzREFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1Isb0RBQW9ELElBQUk7QUFDeEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSyxFQUFFLCtCQUErQjtBQUM5RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsYUFBYTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVMsR0FBRyxTQUFTLEdBQUcsU0FBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsd0RBQXdEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLEdBQUcsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLHNCQUFzQixrQkFBa0I7QUFDeEMsK0JBQStCLGFBQWEsR0FBRyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUyxHQUFHLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBeUQ7QUFDdkYsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHdEQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLCtDQUErQyx1QkFBdUIsS0FBSyxvREFBb0Q7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0M7QUFDbEMiLCJzb3VyY2VzIjpbIkQ6XFxBY3RpbmdFdXJvcGVcXEFjdGluZ0V1cm9wZV9kZXZcXEFjdGluZ0V1cm9wZV9kZXZcXG5vZGVfbW9kdWxlc1xcLnBucG1cXHBkZmtpdEAwLjE3LjFcXG5vZGVfbW9kdWxlc1xccGRma2l0XFxqc1xccGRma2l0LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IENyeXB0b0pTIGZyb20gJ2NyeXB0by1qcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgZm9udGtpdCBmcm9tICdmb250a2l0JztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgTGluZUJyZWFrZXIgZnJvbSAnbGluZWJyZWFrJztcbmltcG9ydCBleGlmIGZyb20gJ2pwZWctZXhpZic7XG5pbXBvcnQgUE5HIGZyb20gJ3BuZy1qcyc7XG5cbmNsYXNzIFBERkFic3RyYWN0UmVmZXJlbmNlIHtcbiAgdG9TdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMnKTtcbiAgfVxufVxuXG5jbGFzcyBQREZUcmVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMuX2l0ZW1zID0ge307XG4gICAgdGhpcy5saW1pdHMgPSB0eXBlb2Ygb3B0aW9ucy5saW1pdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMubGltaXRzIDogdHJ1ZTtcbiAgfVxuICBhZGQoa2V5LCB2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXNba2V5XSA9IHZhbDtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zW2tleV07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2l0ZW1zKS5zb3J0KChhLCBiKSA9PiB0aGlzLl9jb21wYXJlS2V5cyhhLCBiKSk7XG4gICAgY29uc3Qgb3V0ID0gWyc8PCddO1xuICAgIGlmICh0aGlzLmxpbWl0cyAmJiBzb3J0ZWRLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gc29ydGVkS2V5c1swXSxcbiAgICAgICAgbGFzdCA9IHNvcnRlZEtleXNbc29ydGVkS2V5cy5sZW5ndGggLSAxXTtcbiAgICAgIG91dC5wdXNoKGAgIC9MaW1pdHMgJHtQREZPYmplY3QuY29udmVydChbdGhpcy5fZGF0YUZvcktleShmaXJzdCksIHRoaXMuX2RhdGFGb3JLZXkobGFzdCldKX1gKTtcbiAgICB9XG4gICAgb3V0LnB1c2goYCAgLyR7dGhpcy5fa2V5c05hbWUoKX0gW2ApO1xuICAgIGZvciAobGV0IGtleSBvZiBzb3J0ZWRLZXlzKSB7XG4gICAgICBvdXQucHVzaChgICAgICR7UERGT2JqZWN0LmNvbnZlcnQodGhpcy5fZGF0YUZvcktleShrZXkpKX0gJHtQREZPYmplY3QuY29udmVydCh0aGlzLl9pdGVtc1trZXldKX1gKTtcbiAgICB9XG4gICAgb3V0LnB1c2goJ10nKTtcbiAgICBvdXQucHVzaCgnPj4nKTtcbiAgICByZXR1cm4gb3V0LmpvaW4oJ1xcbicpO1xuICB9XG4gIF9jb21wYXJlS2V5cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcycpO1xuICB9XG4gIF9rZXlzTmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcycpO1xuICB9XG4gIF9kYXRhRm9yS2V5KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbn1cblxuY2xhc3MgU3BvdENvbG9yIHtcbiAgY29uc3RydWN0b3IoZG9jLCBuYW1lLCBDLCBNLCBZLCBLKSB7XG4gICAgdGhpcy5pZCA9ICdDUycgKyBPYmplY3Qua2V5cyhkb2Muc3BvdENvbG9ycykubGVuZ3RoO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZXMgPSBbQywgTSwgWSwgS107XG4gICAgdGhpcy5yZWYgPSBkb2MucmVmKFsnU2VwYXJhdGlvbicsIHRoaXMubmFtZSwgJ0RldmljZUNNWUsnLCB7XG4gICAgICBSYW5nZTogWzAsIDEsIDAsIDEsIDAsIDEsIDAsIDFdLFxuICAgICAgQzA6IFswLCAwLCAwLCAwXSxcbiAgICAgIEMxOiB0aGlzLnZhbHVlcy5tYXAodmFsdWUgPT4gdmFsdWUgLyAxMDApLFxuICAgICAgRnVuY3Rpb25UeXBlOiAyLFxuICAgICAgRG9tYWluOiBbMCwgMV0sXG4gICAgICBOOiAxXG4gICAgfV0pO1xuICAgIHRoaXMucmVmLmVuZCgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnJlZi5pZH0gMCBSYDtcbiAgfVxufVxuXG5jb25zdCBwYWQgPSAoc3RyLCBsZW5ndGgpID0+IChBcnJheShsZW5ndGggKyAxKS5qb2luKCcwJykgKyBzdHIpLnNsaWNlKC1sZW5ndGgpO1xuY29uc3QgZXNjYXBhYmxlUmUgPSAvW1xcblxcclxcdFxcYlxcZigpXFxcXF0vZztcbmNvbnN0IGVzY2FwYWJsZSA9IHtcbiAgJ1xcbic6ICdcXFxcbicsXG4gICdcXHInOiAnXFxcXHInLFxuICAnXFx0JzogJ1xcXFx0JyxcbiAgJ1xcYic6ICdcXFxcYicsXG4gICdcXGYnOiAnXFxcXGYnLFxuICAnXFxcXCc6ICdcXFxcXFxcXCcsXG4gICcoJzogJ1xcXFwoJyxcbiAgJyknOiAnXFxcXCknXG59O1xuY29uc3Qgc3dhcEJ5dGVzID0gZnVuY3Rpb24gKGJ1ZmYpIHtcbiAgY29uc3QgbCA9IGJ1ZmYubGVuZ3RoO1xuICBpZiAobCAmIDB4MDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBsZW5ndGggbXVzdCBiZSBldmVuJyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGVuZCA9IGwgLSAxOyBpIDwgZW5kOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGEgPSBidWZmW2ldO1xuICAgICAgYnVmZltpXSA9IGJ1ZmZbaSArIDFdO1xuICAgICAgYnVmZltpICsgMV0gPSBhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmZjtcbn07XG5jbGFzcyBQREZPYmplY3Qge1xuICBzdGF0aWMgY29udmVydChvYmplY3QpIHtcbiAgICBsZXQgZW5jcnlwdEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGAvJHtvYmplY3R9YDtcbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgbGV0IHN0cmluZyA9IG9iamVjdDtcbiAgICAgIGxldCBpc1VuaWNvZGUgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBlbmQgPSBzdHJpbmcubGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID4gMHg3Zikge1xuICAgICAgICAgIGlzVW5pY29kZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBzdHJpbmdCdWZmZXI7XG4gICAgICBpZiAoaXNVbmljb2RlKSB7XG4gICAgICAgIHN0cmluZ0J1ZmZlciA9IHN3YXBCeXRlcyhCdWZmZXIuZnJvbShgXFx1ZmVmZiR7c3RyaW5nfWAsICd1dGYxNmxlJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5nQnVmZmVyID0gQnVmZmVyLmZyb20oc3RyaW5nLnZhbHVlT2YoKSwgJ2FzY2lpJyk7XG4gICAgICB9XG4gICAgICBpZiAoZW5jcnlwdEZuKSB7XG4gICAgICAgIHN0cmluZyA9IGVuY3J5cHRGbihzdHJpbmdCdWZmZXIpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZ0J1ZmZlci50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShlc2NhcGFibGVSZSwgYyA9PiBlc2NhcGFibGVbY10pO1xuICAgICAgcmV0dXJuIGAoJHtzdHJpbmd9KWA7XG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIGA8JHtvYmplY3QudG9TdHJpbmcoJ2hleCcpfT5gO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUERGQWJzdHJhY3RSZWZlcmVuY2UgfHwgb2JqZWN0IGluc3RhbmNlb2YgUERGVHJlZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBTcG90Q29sb3IpIHtcbiAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGxldCBzdHJpbmcgPSBgRDoke3BhZChvYmplY3QuZ2V0VVRDRnVsbFllYXIoKSwgNCl9YCArIHBhZChvYmplY3QuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgcGFkKG9iamVjdC5nZXRVVENEYXRlKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENIb3VycygpLCAyKSArIHBhZChvYmplY3QuZ2V0VVRDTWludXRlcygpLCAyKSArIHBhZChvYmplY3QuZ2V0VVRDU2Vjb25kcygpLCAyKSArICdaJztcbiAgICAgIGlmIChlbmNyeXB0Rm4pIHtcbiAgICAgICAgc3RyaW5nID0gZW5jcnlwdEZuKEJ1ZmZlci5mcm9tKHN0cmluZywgJ2FzY2lpJykpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlUmUsIGMgPT4gZXNjYXBhYmxlW2NdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgKCR7c3RyaW5nfSlgO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICBjb25zdCBpdGVtcyA9IG9iamVjdC5tYXAoZSA9PiBQREZPYmplY3QuY29udmVydChlLCBlbmNyeXB0Rm4pKS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gYFske2l0ZW1zfV1gO1xuICAgIH0gZWxzZSBpZiAoe30udG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgY29uc3Qgb3V0ID0gWyc8PCddO1xuICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgb3V0LnB1c2goYC8ke2tleX0gJHtQREZPYmplY3QuY29udmVydCh2YWwsIGVuY3J5cHRGbil9YCk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaCgnPj4nKTtcbiAgICAgIHJldHVybiBvdXQuam9pbignXFxuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFBERk9iamVjdC5udW1iZXIob2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke29iamVjdH1gO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgbnVtYmVyKG4pIHtcbiAgICBpZiAobiA+IC0xZTIxICYmIG4gPCAxZTIxKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChuICogMWU2KSAvIDFlNjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBudW1iZXI6ICR7bn1gKTtcbiAgfVxufVxuXG5jbGFzcyBQREZSZWZlcmVuY2UgZXh0ZW5kcyBQREZBYnN0cmFjdFJlZmVyZW5jZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBpZCkge1xuICAgIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmdlbiA9IDA7XG4gICAgdGhpcy5jb21wcmVzcyA9IHRoaXMuZG9jdW1lbnQuY29tcHJlc3MgJiYgIXRoaXMuZGF0YS5GaWx0ZXI7XG4gICAgdGhpcy51bmNvbXByZXNzZWRMZW5ndGggPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gIH1cbiAgd3JpdGUoY2h1bmspIHtcbiAgICBpZiAoIShjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rICsgJ1xcbicsICdiaW5hcnknKTtcbiAgICB9XG4gICAgdGhpcy51bmNvbXByZXNzZWRMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgIGlmICh0aGlzLmRhdGEuTGVuZ3RoID09IG51bGwpIHtcbiAgICAgIHRoaXMuZGF0YS5MZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGEuTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICBpZiAodGhpcy5jb21wcmVzcykge1xuICAgICAgdGhpcy5kYXRhLkZpbHRlciA9ICdGbGF0ZURlY29kZSc7XG4gICAgfVxuICB9XG4gIGVuZChjaHVuaykge1xuICAgIGlmIChjaHVuaykge1xuICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgfVxuICBmaW5hbGl6ZSgpIHtcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMuZG9jdW1lbnQuX29mZnNldDtcbiAgICBjb25zdCBlbmNyeXB0Rm4gPSB0aGlzLmRvY3VtZW50Ll9zZWN1cml0eSA/IHRoaXMuZG9jdW1lbnQuX3NlY3VyaXR5LmdldEVuY3J5cHRGbih0aGlzLmlkLCB0aGlzLmdlbikgOiBudWxsO1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlcik7XG4gICAgICBpZiAodGhpcy5jb21wcmVzcykge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHpsaWIuZGVmbGF0ZVN5bmModGhpcy5idWZmZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuY3J5cHRGbikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGVuY3J5cHRGbih0aGlzLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGEuTGVuZ3RoID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLmRvY3VtZW50Ll93cml0ZShgJHt0aGlzLmlkfSAke3RoaXMuZ2VufSBvYmpgKTtcbiAgICB0aGlzLmRvY3VtZW50Ll93cml0ZShQREZPYmplY3QuY29udmVydCh0aGlzLmRhdGEsIGVuY3J5cHRGbikpO1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKCdzdHJlYW0nKTtcbiAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKHRoaXMuYnVmZmVyKTtcbiAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICB0aGlzLmRvY3VtZW50Ll93cml0ZSgnXFxuZW5kc3RyZWFtJyk7XG4gICAgfVxuICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKCdlbmRvYmonKTtcbiAgICB0aGlzLmRvY3VtZW50Ll9yZWZFbmQodGhpcyk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuaWR9ICR7dGhpcy5nZW59IFJgO1xuICB9XG59XG5cbmNvbnN0IGZBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5jb25zdCB1QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoZkFycmF5LmJ1ZmZlcik7XG5mdW5jdGlvbiBQREZOdW1iZXIobikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5mcm91bmQobik7XG4gIGlmIChyb3VuZGVkIDw9IG4pIHJldHVybiByb3VuZGVkO1xuICBmQXJyYXlbMF0gPSBuO1xuICBpZiAobiA8PSAwKSB7XG4gICAgdUFycmF5WzBdICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgdUFycmF5WzBdIC09IDE7XG4gIH1cbiAgcmV0dXJuIGZBcnJheVswXTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpZGVzKHNpZGVzKSB7XG4gIGxldCBkZWZhdWx0RGVmaW5pdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICBsZXQgdHJhbnNmb3JtZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHYgPT4gdjtcbiAgaWYgKHNpZGVzID09IG51bGwgfHwgdHlwZW9mIHNpZGVzID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhzaWRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgc2lkZXMgPSBkZWZhdWx0RGVmaW5pdGlvbjtcbiAgfVxuICBpZiAoc2lkZXMgPT0gbnVsbCB8fCB0eXBlb2Ygc2lkZXMgIT09ICdvYmplY3QnKSB7XG4gICAgc2lkZXMgPSB7XG4gICAgICB0b3A6IHNpZGVzLFxuICAgICAgcmlnaHQ6IHNpZGVzLFxuICAgICAgYm90dG9tOiBzaWRlcyxcbiAgICAgIGxlZnQ6IHNpZGVzXG4gICAgfTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNpZGVzKSkge1xuICAgIGlmIChzaWRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNpZGVzID0ge1xuICAgICAgICB2ZXJ0aWNhbDogc2lkZXNbMF0sXG4gICAgICAgIGhvcml6b250YWw6IHNpZGVzWzFdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWRlcyA9IHtcbiAgICAgICAgdG9wOiBzaWRlc1swXSxcbiAgICAgICAgcmlnaHQ6IHNpZGVzWzFdLFxuICAgICAgICBib3R0b206IHNpZGVzWzJdLFxuICAgICAgICBsZWZ0OiBzaWRlc1szXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKCd2ZXJ0aWNhbCcgaW4gc2lkZXMgfHwgJ2hvcml6b250YWwnIGluIHNpZGVzKSB7XG4gICAgc2lkZXMgPSB7XG4gICAgICB0b3A6IHNpZGVzLnZlcnRpY2FsLFxuICAgICAgcmlnaHQ6IHNpZGVzLmhvcml6b250YWwsXG4gICAgICBib3R0b206IHNpZGVzLnZlcnRpY2FsLFxuICAgICAgbGVmdDogc2lkZXMuaG9yaXpvbnRhbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRyYW5zZm9ybWVyKHNpZGVzLnRvcCksXG4gICAgcmlnaHQ6IHRyYW5zZm9ybWVyKHNpZGVzLnJpZ2h0KSxcbiAgICBib3R0b206IHRyYW5zZm9ybWVyKHNpZGVzLmJvdHRvbSksXG4gICAgbGVmdDogdHJhbnNmb3JtZXIoc2lkZXMubGVmdClcbiAgfTtcbn1cbmNvbnN0IE1NX1RPX0NNID0gMSAvIDEwO1xuY29uc3QgQ01fVE9fSU4gPSAxIC8gMi41NDtcbmNvbnN0IFBYX1RPX0lOID0gMSAvIDk2O1xuY29uc3QgSU5fVE9fUFQgPSA3MjtcbmNvbnN0IFBDX1RPX1BUID0gMTI7XG5mdW5jdGlvbiBjb3NpbmUoYSkge1xuICBpZiAoYSA9PT0gMCkgcmV0dXJuIDE7XG4gIGlmIChhID09PSA5MCkgcmV0dXJuIDA7XG4gIGlmIChhID09PSAxODApIHJldHVybiAtMTtcbiAgaWYgKGEgPT09IDI3MCkgcmV0dXJuIDA7XG4gIHJldHVybiBNYXRoLmNvcyhhICogTWF0aC5QSSAvIDE4MCk7XG59XG5mdW5jdGlvbiBzaW5lKGEpIHtcbiAgaWYgKGEgPT09IDApIHJldHVybiAwO1xuICBpZiAoYSA9PT0gOTApIHJldHVybiAxO1xuICBpZiAoYSA9PT0gMTgwKSByZXR1cm4gMDtcbiAgaWYgKGEgPT09IDI3MCkgcmV0dXJuIC0xO1xuICByZXR1cm4gTWF0aC5zaW4oYSAqIE1hdGguUEkgLyAxODApO1xufVxuXG5jb25zdCBERUZBVUxUX01BUkdJTlMgPSB7XG4gIHRvcDogNzIsXG4gIGxlZnQ6IDcyLFxuICBib3R0b206IDcyLFxuICByaWdodDogNzJcbn07XG5jb25zdCBTSVpFUyA9IHtcbiAgJzRBMCc6IFs0NzY3Ljg3LCA2NzQwLjc5XSxcbiAgJzJBMCc6IFszMzcwLjM5LCA0NzY3Ljg3XSxcbiAgQTA6IFsyMzgzLjk0LCAzMzcwLjM5XSxcbiAgQTE6IFsxNjgzLjc4LCAyMzgzLjk0XSxcbiAgQTI6IFsxMTkwLjU1LCAxNjgzLjc4XSxcbiAgQTM6IFs4NDEuODksIDExOTAuNTVdLFxuICBBNDogWzU5NS4yOCwgODQxLjg5XSxcbiAgQTU6IFs0MTkuNTMsIDU5NS4yOF0sXG4gIEE2OiBbMjk3LjY0LCA0MTkuNTNdLFxuICBBNzogWzIwOS43NiwgMjk3LjY0XSxcbiAgQTg6IFsxNDcuNCwgMjA5Ljc2XSxcbiAgQTk6IFsxMDQuODgsIDE0Ny40XSxcbiAgQTEwOiBbNzMuNywgMTA0Ljg4XSxcbiAgQjA6IFsyODM0LjY1LCA0MDA4LjE5XSxcbiAgQjE6IFsyMDA0LjA5LCAyODM0LjY1XSxcbiAgQjI6IFsxNDE3LjMyLCAyMDA0LjA5XSxcbiAgQjM6IFsxMDAwLjYzLCAxNDE3LjMyXSxcbiAgQjQ6IFs3MDguNjYsIDEwMDAuNjNdLFxuICBCNTogWzQ5OC45LCA3MDguNjZdLFxuICBCNjogWzM1NC4zMywgNDk4LjldLFxuICBCNzogWzI0OS40NSwgMzU0LjMzXSxcbiAgQjg6IFsxNzUuNzUsIDI0OS40NV0sXG4gIEI5OiBbMTI0LjcyLCAxNzUuNzVdLFxuICBCMTA6IFs4Ny44NywgMTI0LjcyXSxcbiAgQzA6IFsyNTk5LjM3LCAzNjc2LjU0XSxcbiAgQzE6IFsxODM2Ljg1LCAyNTk5LjM3XSxcbiAgQzI6IFsxMjk4LjI3LCAxODM2Ljg1XSxcbiAgQzM6IFs5MTguNDMsIDEyOTguMjddLFxuICBDNDogWzY0OS4xMywgOTE4LjQzXSxcbiAgQzU6IFs0NTkuMjEsIDY0OS4xM10sXG4gIEM2OiBbMzIzLjE1LCA0NTkuMjFdLFxuICBDNzogWzIyOS42MSwgMzIzLjE1XSxcbiAgQzg6IFsxNjEuNTcsIDIyOS42MV0sXG4gIEM5OiBbMTEzLjM5LCAxNjEuNTddLFxuICBDMTA6IFs3OS4zNywgMTEzLjM5XSxcbiAgUkEwOiBbMjQzNy44LCAzNDU4LjI3XSxcbiAgUkExOiBbMTcyOS4xMywgMjQzNy44XSxcbiAgUkEyOiBbMTIxOC45LCAxNzI5LjEzXSxcbiAgUkEzOiBbODY0LjU3LCAxMjE4LjldLFxuICBSQTQ6IFs2MDkuNDUsIDg2NC41N10sXG4gIFNSQTA6IFsyNTUxLjE4LCAzNjI4LjM1XSxcbiAgU1JBMTogWzE4MTQuMTcsIDI1NTEuMThdLFxuICBTUkEyOiBbMTI3NS41OSwgMTgxNC4xN10sXG4gIFNSQTM6IFs5MDcuMDksIDEyNzUuNTldLFxuICBTUkE0OiBbNjM3LjgsIDkwNy4wOV0sXG4gIEVYRUNVVElWRTogWzUyMS44NiwgNzU2LjBdLFxuICBGT0xJTzogWzYxMi4wLCA5MzYuMF0sXG4gIExFR0FMOiBbNjEyLjAsIDEwMDguMF0sXG4gIExFVFRFUjogWzYxMi4wLCA3OTIuMF0sXG4gIFRBQkxPSUQ6IFs3OTIuMCwgMTIyNC4wXVxufTtcbmNsYXNzIFBERlBhZ2Uge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplIHx8ICdsZXR0ZXInO1xuICAgIHRoaXMubGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQgfHwgJ3BvcnRyYWl0JztcbiAgICBjb25zdCBkaW1lbnNpb25zID0gQXJyYXkuaXNBcnJheSh0aGlzLnNpemUpID8gdGhpcy5zaXplIDogU0laRVNbdGhpcy5zaXplLnRvVXBwZXJDYXNlKCldO1xuICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zW3RoaXMubGF5b3V0ID09PSAncG9ydHJhaXQnID8gMCA6IDFdO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9uc1t0aGlzLmxheW91dCA9PT0gJ3BvcnRyYWl0JyA/IDEgOiAwXTtcbiAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICAgIGlmIChvcHRpb25zLmZvbnQpIGRvY3VtZW50LmZvbnQob3B0aW9ucy5mb250LCBvcHRpb25zLmZvbnRGYW1pbHkpO1xuICAgIGlmIChvcHRpb25zLmZvbnRTaXplKSBkb2N1bWVudC5mb250U2l6ZShvcHRpb25zLmZvbnRTaXplKTtcbiAgICB0aGlzLm1hcmdpbnMgPSBub3JtYWxpemVTaWRlcyhvcHRpb25zLm1hcmdpbiA/PyBvcHRpb25zLm1hcmdpbnMsIERFRkFVTFRfTUFSR0lOUywgeCA9PiBkb2N1bWVudC5zaXplVG9Qb2ludCh4LCAwLCB0aGlzKSk7XG4gICAgdGhpcy5yZXNvdXJjZXMgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ11cbiAgICB9KTtcbiAgICB0aGlzLmRpY3Rpb25hcnkgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICBUeXBlOiAnUGFnZScsXG4gICAgICBQYXJlbnQ6IHRoaXMuZG9jdW1lbnQuX3Jvb3QuZGF0YS5QYWdlcyxcbiAgICAgIE1lZGlhQm94OiBbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLFxuICAgICAgQ29udGVudHM6IHRoaXMuY29udGVudCxcbiAgICAgIFJlc291cmNlczogdGhpcy5yZXNvdXJjZXNcbiAgICB9KTtcbiAgICB0aGlzLm1hcmtpbmdzID0gW107XG4gIH1cbiAgZ2V0IGZvbnRzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgIHJldHVybiBkYXRhLkZvbnQgIT0gbnVsbCA/IGRhdGEuRm9udCA6IGRhdGEuRm9udCA9IHt9O1xuICB9XG4gIGdldCB4b2JqZWN0cygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNvdXJjZXMuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5YT2JqZWN0ICE9IG51bGwgPyBkYXRhLlhPYmplY3QgOiBkYXRhLlhPYmplY3QgPSB7fTtcbiAgfVxuICBnZXQgZXh0X2dzdGF0ZXMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzb3VyY2VzLmRhdGE7XG4gICAgcmV0dXJuIGRhdGEuRXh0R1N0YXRlICE9IG51bGwgPyBkYXRhLkV4dEdTdGF0ZSA6IGRhdGEuRXh0R1N0YXRlID0ge307XG4gIH1cbiAgZ2V0IHBhdHRlcm5zKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgIHJldHVybiBkYXRhLlBhdHRlcm4gIT0gbnVsbCA/IGRhdGEuUGF0dGVybiA6IGRhdGEuUGF0dGVybiA9IHt9O1xuICB9XG4gIGdldCBjb2xvclNwYWNlcygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNvdXJjZXMuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5Db2xvclNwYWNlIHx8IChkYXRhLkNvbG9yU3BhY2UgPSB7fSk7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25zKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRpY3Rpb25hcnkuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5Bbm5vdHMgIT0gbnVsbCA/IGRhdGEuQW5ub3RzIDogZGF0YS5Bbm5vdHMgPSBbXTtcbiAgfVxuICBnZXQgc3RydWN0UGFyZW50VHJlZUtleSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kaWN0aW9uYXJ5LmRhdGE7XG4gICAgcmV0dXJuIGRhdGEuU3RydWN0UGFyZW50cyAhPSBudWxsID8gZGF0YS5TdHJ1Y3RQYXJlbnRzIDogZGF0YS5TdHJ1Y3RQYXJlbnRzID0gdGhpcy5kb2N1bWVudC5jcmVhdGVTdHJ1Y3RQYXJlbnRUcmVlTmV4dEtleSgpO1xuICB9XG4gIGdldCBjb250ZW50V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCAtIHRoaXMubWFyZ2lucy5yaWdodDtcbiAgfVxuICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wIC0gdGhpcy5tYXJnaW5zLmJvdHRvbTtcbiAgfVxuICBtYXhZKCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodCAtIHRoaXMubWFyZ2lucy5ib3R0b207XG4gIH1cbiAgd3JpdGUoY2h1bmspIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LndyaXRlKGNodW5rKTtcbiAgfVxuICBfc2V0VGFiT3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRpY3Rpb25hcnkuVGFicyAmJiB0aGlzLmRvY3VtZW50Lmhhc01hcmtJbmZvRGljdGlvbmFyeSgpKSB7XG4gICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5UYWJzID0gJ1MnO1xuICAgIH1cbiAgfVxuICBlbmQoKSB7XG4gICAgdGhpcy5fc2V0VGFiT3JkZXIoKTtcbiAgICB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gICAgdGhpcy5yZXNvdXJjZXMuZGF0YS5Db2xvclNwYWNlID0gdGhpcy5yZXNvdXJjZXMuZGF0YS5Db2xvclNwYWNlIHx8IHt9O1xuICAgIGZvciAobGV0IGNvbG9yIG9mIE9iamVjdC52YWx1ZXModGhpcy5kb2N1bWVudC5zcG90Q29sb3JzKSkge1xuICAgICAgdGhpcy5yZXNvdXJjZXMuZGF0YS5Db2xvclNwYWNlW2NvbG9yLmlkXSA9IGNvbG9yO1xuICAgIH1cbiAgICB0aGlzLnJlc291cmNlcy5lbmQoKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmVuZCgpO1xuICB9XG59XG5cbmNsYXNzIFBERk5hbWVUcmVlIGV4dGVuZHMgUERGVHJlZSB7XG4gIF9jb21wYXJlS2V5cyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgfVxuICBfa2V5c05hbWUoKSB7XG4gICAgcmV0dXJuICdOYW1lcyc7XG4gIH1cbiAgX2RhdGFGb3JLZXkoaykge1xuICAgIHJldHVybiBuZXcgU3RyaW5nKGspO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2UodmFsdWUsIHJhbmdlR3JvdXApIHtcbiAgaWYgKHZhbHVlIDwgcmFuZ2VHcm91cFswXSkgcmV0dXJuIGZhbHNlO1xuICBsZXQgc3RhcnRSYW5nZSA9IDA7XG4gIGxldCBlbmRSYW5nZSA9IHJhbmdlR3JvdXAubGVuZ3RoIC8gMjtcbiAgd2hpbGUgKHN0YXJ0UmFuZ2UgPD0gZW5kUmFuZ2UpIHtcbiAgICBjb25zdCBtaWRkbGVSYW5nZSA9IE1hdGguZmxvb3IoKHN0YXJ0UmFuZ2UgKyBlbmRSYW5nZSkgLyAyKTtcbiAgICBjb25zdCBhcnJheUluZGV4ID0gbWlkZGxlUmFuZ2UgKiAyO1xuICAgIGlmICh2YWx1ZSA+PSByYW5nZUdyb3VwW2FycmF5SW5kZXhdICYmIHZhbHVlIDw9IHJhbmdlR3JvdXBbYXJyYXlJbmRleCArIDFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gcmFuZ2VHcm91cFthcnJheUluZGV4ICsgMV0pIHtcbiAgICAgIHN0YXJ0UmFuZ2UgPSBtaWRkbGVSYW5nZSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZFJhbmdlID0gbWlkZGxlUmFuZ2UgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IHVuYXNzaWduZWRfY29kZV9wb2ludHMgPSBbMHgwMjIxLCAweDAyMjEsIDB4MDIzNCwgMHgwMjRmLCAweDAyYWUsIDB4MDJhZiwgMHgwMmVmLCAweDAyZmYsIDB4MDM1MCwgMHgwMzVmLCAweDAzNzAsIDB4MDM3MywgMHgwMzc2LCAweDAzNzksIDB4MDM3YiwgMHgwMzdkLCAweDAzN2YsIDB4MDM4MywgMHgwMzhiLCAweDAzOGIsIDB4MDM4ZCwgMHgwMzhkLCAweDAzYTIsIDB4MDNhMiwgMHgwM2NmLCAweDAzY2YsIDB4MDNmNywgMHgwM2ZmLCAweDA0ODcsIDB4MDQ4NywgMHgwNGNmLCAweDA0Y2YsIDB4MDRmNiwgMHgwNGY3LCAweDA0ZmEsIDB4MDRmZiwgMHgwNTEwLCAweDA1MzAsIDB4MDU1NywgMHgwNTU4LCAweDA1NjAsIDB4MDU2MCwgMHgwNTg4LCAweDA1ODgsIDB4MDU4YiwgMHgwNTkwLCAweDA1YTIsIDB4MDVhMiwgMHgwNWJhLCAweDA1YmEsIDB4MDVjNSwgMHgwNWNmLCAweDA1ZWIsIDB4MDVlZiwgMHgwNWY1LCAweDA2MGIsIDB4MDYwZCwgMHgwNjFhLCAweDA2MWMsIDB4MDYxZSwgMHgwNjIwLCAweDA2MjAsIDB4MDYzYiwgMHgwNjNmLCAweDA2NTYsIDB4MDY1ZiwgMHgwNmVlLCAweDA2ZWYsIDB4MDZmZiwgMHgwNmZmLCAweDA3MGUsIDB4MDcwZSwgMHgwNzJkLCAweDA3MmYsIDB4MDc0YiwgMHgwNzdmLCAweDA3YjIsIDB4MDkwMCwgMHgwOTA0LCAweDA5MDQsIDB4MDkzYSwgMHgwOTNiLCAweDA5NGUsIDB4MDk0ZiwgMHgwOTU1LCAweDA5NTcsIDB4MDk3MSwgMHgwOTgwLCAweDA5ODQsIDB4MDk4NCwgMHgwOThkLCAweDA5OGUsIDB4MDk5MSwgMHgwOTkyLCAweDA5YTksIDB4MDlhOSwgMHgwOWIxLCAweDA5YjEsIDB4MDliMywgMHgwOWI1LCAweDA5YmEsIDB4MDliYiwgMHgwOWJkLCAweDA5YmQsIDB4MDljNSwgMHgwOWM2LCAweDA5YzksIDB4MDljYSwgMHgwOWNlLCAweDA5ZDYsIDB4MDlkOCwgMHgwOWRiLCAweDA5ZGUsIDB4MDlkZSwgMHgwOWU0LCAweDA5ZTUsIDB4MDlmYiwgMHgwYTAxLCAweDBhMDMsIDB4MGEwNCwgMHgwYTBiLCAweDBhMGUsIDB4MGExMSwgMHgwYTEyLCAweDBhMjksIDB4MGEyOSwgMHgwYTMxLCAweDBhMzEsIDB4MGEzNCwgMHgwYTM0LCAweDBhMzcsIDB4MGEzNywgMHgwYTNhLCAweDBhM2IsIDB4MGEzZCwgMHgwYTNkLCAweDBhNDMsIDB4MGE0NiwgMHgwYTQ5LCAweDBhNGEsIDB4MGE0ZSwgMHgwYTU4LCAweDBhNWQsIDB4MGE1ZCwgMHgwYTVmLCAweDBhNjUsIDB4MGE3NSwgMHgwYTgwLCAweDBhODQsIDB4MGE4NCwgMHgwYThjLCAweDBhOGMsIDB4MGE4ZSwgMHgwYThlLCAweDBhOTIsIDB4MGE5MiwgMHgwYWE5LCAweDBhYTksIDB4MGFiMSwgMHgwYWIxLCAweDBhYjQsIDB4MGFiNCwgMHgwYWJhLCAweDBhYmIsIDB4MGFjNiwgMHgwYWM2LCAweDBhY2EsIDB4MGFjYSwgMHgwYWNlLCAweDBhY2YsIDB4MGFkMSwgMHgwYWRmLCAweDBhZTEsIDB4MGFlNSwgMHgwYWYwLCAweDBiMDAsIDB4MGIwNCwgMHgwYjA0LCAweDBiMGQsIDB4MGIwZSwgMHgwYjExLCAweDBiMTIsIDB4MGIyOSwgMHgwYjI5LCAweDBiMzEsIDB4MGIzMSwgMHgwYjM0LCAweDBiMzUsIDB4MGIzYSwgMHgwYjNiLCAweDBiNDQsIDB4MGI0NiwgMHgwYjQ5LCAweDBiNGEsIDB4MGI0ZSwgMHgwYjU1LCAweDBiNTgsIDB4MGI1YiwgMHgwYjVlLCAweDBiNWUsIDB4MGI2MiwgMHgwYjY1LCAweDBiNzEsIDB4MGI4MSwgMHgwYjg0LCAweDBiODQsIDB4MGI4YiwgMHgwYjhkLCAweDBiOTEsIDB4MGI5MSwgMHgwYjk2LCAweDBiOTgsIDB4MGI5YiwgMHgwYjliLCAweDBiOWQsIDB4MGI5ZCwgMHgwYmEwLCAweDBiYTIsIDB4MGJhNSwgMHgwYmE3LCAweDBiYWIsIDB4MGJhZCwgMHgwYmI2LCAweDBiYjYsIDB4MGJiYSwgMHgwYmJkLCAweDBiYzMsIDB4MGJjNSwgMHgwYmM5LCAweDBiYzksIDB4MGJjZSwgMHgwYmQ2LCAweDBiZDgsIDB4MGJlNiwgMHgwYmYzLCAweDBjMDAsIDB4MGMwNCwgMHgwYzA0LCAweDBjMGQsIDB4MGMwZCwgMHgwYzExLCAweDBjMTEsIDB4MGMyOSwgMHgwYzI5LCAweDBjMzQsIDB4MGMzNCwgMHgwYzNhLCAweDBjM2QsIDB4MGM0NSwgMHgwYzQ1LCAweDBjNDksIDB4MGM0OSwgMHgwYzRlLCAweDBjNTQsIDB4MGM1NywgMHgwYzVmLCAweDBjNjIsIDB4MGM2NSwgMHgwYzcwLCAweDBjODEsIDB4MGM4NCwgMHgwYzg0LCAweDBjOGQsIDB4MGM4ZCwgMHgwYzkxLCAweDBjOTEsIDB4MGNhOSwgMHgwY2E5LCAweDBjYjQsIDB4MGNiNCwgMHgwY2JhLCAweDBjYmQsIDB4MGNjNSwgMHgwY2M1LCAweDBjYzksIDB4MGNjOSwgMHgwY2NlLCAweDBjZDQsIDB4MGNkNywgMHgwY2RkLCAweDBjZGYsIDB4MGNkZiwgMHgwY2UyLCAweDBjZTUsIDB4MGNmMCwgMHgwZDAxLCAweDBkMDQsIDB4MGQwNCwgMHgwZDBkLCAweDBkMGQsIDB4MGQxMSwgMHgwZDExLCAweDBkMjksIDB4MGQyOSwgMHgwZDNhLCAweDBkM2QsIDB4MGQ0NCwgMHgwZDQ1LCAweDBkNDksIDB4MGQ0OSwgMHgwZDRlLCAweDBkNTYsIDB4MGQ1OCwgMHgwZDVmLCAweDBkNjIsIDB4MGQ2NSwgMHgwZDcwLCAweDBkODEsIDB4MGQ4NCwgMHgwZDg0LCAweDBkOTcsIDB4MGQ5OSwgMHgwZGIyLCAweDBkYjIsIDB4MGRiYywgMHgwZGJjLCAweDBkYmUsIDB4MGRiZiwgMHgwZGM3LCAweDBkYzksIDB4MGRjYiwgMHgwZGNlLCAweDBkZDUsIDB4MGRkNSwgMHgwZGQ3LCAweDBkZDcsIDB4MGRlMCwgMHgwZGYxLCAweDBkZjUsIDB4MGUwMCwgMHgwZTNiLCAweDBlM2UsIDB4MGU1YywgMHgwZTgwLCAweDBlODMsIDB4MGU4MywgMHgwZTg1LCAweDBlODYsIDB4MGU4OSwgMHgwZTg5LCAweDBlOGIsIDB4MGU4YywgMHgwZThlLCAweDBlOTMsIDB4MGU5OCwgMHgwZTk4LCAweDBlYTAsIDB4MGVhMCwgMHgwZWE0LCAweDBlYTQsIDB4MGVhNiwgMHgwZWE2LCAweDBlYTgsIDB4MGVhOSwgMHgwZWFjLCAweDBlYWMsIDB4MGViYSwgMHgwZWJhLCAweDBlYmUsIDB4MGViZiwgMHgwZWM1LCAweDBlYzUsIDB4MGVjNywgMHgwZWM3LCAweDBlY2UsIDB4MGVjZiwgMHgwZWRhLCAweDBlZGIsIDB4MGVkZSwgMHgwZWZmLCAweDBmNDgsIDB4MGY0OCwgMHgwZjZiLCAweDBmNzAsIDB4MGY4YywgMHgwZjhmLCAweDBmOTgsIDB4MGY5OCwgMHgwZmJkLCAweDBmYmQsIDB4MGZjZCwgMHgwZmNlLCAweDBmZDAsIDB4MGZmZiwgMHgxMDIyLCAweDEwMjIsIDB4MTAyOCwgMHgxMDI4LCAweDEwMmIsIDB4MTAyYiwgMHgxMDMzLCAweDEwMzUsIDB4MTAzYSwgMHgxMDNmLCAweDEwNWEsIDB4MTA5ZiwgMHgxMGM2LCAweDEwY2YsIDB4MTBmOSwgMHgxMGZhLCAweDEwZmMsIDB4MTBmZiwgMHgxMTVhLCAweDExNWUsIDB4MTFhMywgMHgxMWE3LCAweDExZmEsIDB4MTFmZiwgMHgxMjA3LCAweDEyMDcsIDB4MTI0NywgMHgxMjQ3LCAweDEyNDksIDB4MTI0OSwgMHgxMjRlLCAweDEyNGYsIDB4MTI1NywgMHgxMjU3LCAweDEyNTksIDB4MTI1OSwgMHgxMjVlLCAweDEyNWYsIDB4MTI4NywgMHgxMjg3LCAweDEyODksIDB4MTI4OSwgMHgxMjhlLCAweDEyOGYsIDB4MTJhZiwgMHgxMmFmLCAweDEyYjEsIDB4MTJiMSwgMHgxMmI2LCAweDEyYjcsIDB4MTJiZiwgMHgxMmJmLCAweDEyYzEsIDB4MTJjMSwgMHgxMmM2LCAweDEyYzcsIDB4MTJjZiwgMHgxMmNmLCAweDEyZDcsIDB4MTJkNywgMHgxMmVmLCAweDEyZWYsIDB4MTMwZiwgMHgxMzBmLCAweDEzMTEsIDB4MTMxMSwgMHgxMzE2LCAweDEzMTcsIDB4MTMxZiwgMHgxMzFmLCAweDEzNDcsIDB4MTM0NywgMHgxMzViLCAweDEzNjAsIDB4MTM3ZCwgMHgxMzlmLCAweDEzZjUsIDB4MTQwMCwgMHgxNjc3LCAweDE2N2YsIDB4MTY5ZCwgMHgxNjlmLCAweDE2ZjEsIDB4MTZmZiwgMHgxNzBkLCAweDE3MGQsIDB4MTcxNSwgMHgxNzFmLCAweDE3MzcsIDB4MTczZiwgMHgxNzU0LCAweDE3NWYsIDB4MTc2ZCwgMHgxNzZkLCAweDE3NzEsIDB4MTc3MSwgMHgxNzc0LCAweDE3N2YsIDB4MTdkZCwgMHgxN2RmLCAweDE3ZWEsIDB4MTdmZiwgMHgxODBmLCAweDE4MGYsIDB4MTgxYSwgMHgxODFmLCAweDE4NzgsIDB4MTg3ZiwgMHgxOGFhLCAweDFkZmYsIDB4MWU5YywgMHgxZTlmLCAweDFlZmEsIDB4MWVmZiwgMHgxZjE2LCAweDFmMTcsIDB4MWYxZSwgMHgxZjFmLCAweDFmNDYsIDB4MWY0NywgMHgxZjRlLCAweDFmNGYsIDB4MWY1OCwgMHgxZjU4LCAweDFmNWEsIDB4MWY1YSwgMHgxZjVjLCAweDFmNWMsIDB4MWY1ZSwgMHgxZjVlLCAweDFmN2UsIDB4MWY3ZiwgMHgxZmI1LCAweDFmYjUsIDB4MWZjNSwgMHgxZmM1LCAweDFmZDQsIDB4MWZkNSwgMHgxZmRjLCAweDFmZGMsIDB4MWZmMCwgMHgxZmYxLCAweDFmZjUsIDB4MWZmNSwgMHgxZmZmLCAweDFmZmYsIDB4MjA1MywgMHgyMDU2LCAweDIwNTgsIDB4MjA1ZSwgMHgyMDY0LCAweDIwNjksIDB4MjA3MiwgMHgyMDczLCAweDIwOGYsIDB4MjA5ZiwgMHgyMGIyLCAweDIwY2YsIDB4MjBlYiwgMHgyMGZmLCAweDIxM2IsIDB4MjEzYywgMHgyMTRjLCAweDIxNTIsIDB4MjE4NCwgMHgyMThmLCAweDIzY2YsIDB4MjNmZiwgMHgyNDI3LCAweDI0M2YsIDB4MjQ0YiwgMHgyNDVmLCAweDI0ZmYsIDB4MjRmZiwgMHgyNjE0LCAweDI2MTUsIDB4MjYxOCwgMHgyNjE4LCAweDI2N2UsIDB4MjY3ZiwgMHgyNjhhLCAweDI3MDAsIDB4MjcwNSwgMHgyNzA1LCAweDI3MGEsIDB4MjcwYiwgMHgyNzI4LCAweDI3MjgsIDB4Mjc0YywgMHgyNzRjLCAweDI3NGUsIDB4Mjc0ZSwgMHgyNzUzLCAweDI3NTUsIDB4Mjc1NywgMHgyNzU3LCAweDI3NWYsIDB4Mjc2MCwgMHgyNzk1LCAweDI3OTcsIDB4MjdiMCwgMHgyN2IwLCAweDI3YmYsIDB4MjdjZiwgMHgyN2VjLCAweDI3ZWYsIDB4MmIwMCwgMHgyZTdmLCAweDJlOWEsIDB4MmU5YSwgMHgyZWY0LCAweDJlZmYsIDB4MmZkNiwgMHgyZmVmLCAweDJmZmMsIDB4MmZmZiwgMHgzMDQwLCAweDMwNDAsIDB4MzA5NywgMHgzMDk4LCAweDMxMDAsIDB4MzEwNCwgMHgzMTJkLCAweDMxMzAsIDB4MzE4ZiwgMHgzMThmLCAweDMxYjgsIDB4MzFlZiwgMHgzMjFkLCAweDMyMWYsIDB4MzI0NCwgMHgzMjUwLCAweDMyN2MsIDB4MzI3ZSwgMHgzMmNjLCAweDMyY2YsIDB4MzJmZiwgMHgzMmZmLCAweDMzNzcsIDB4MzM3YSwgMHgzM2RlLCAweDMzZGYsIDB4MzNmZiwgMHgzM2ZmLCAweDRkYjYsIDB4NGRmZiwgMHg5ZmE2LCAweDlmZmYsIDB4YTQ4ZCwgMHhhNDhmLCAweGE0YzcsIDB4YWJmZiwgMHhkN2E0LCAweGQ3ZmYsIDB4ZmEyZSwgMHhmYTJmLCAweGZhNmIsIDB4ZmFmZiwgMHhmYjA3LCAweGZiMTIsIDB4ZmIxOCwgMHhmYjFjLCAweGZiMzcsIDB4ZmIzNywgMHhmYjNkLCAweGZiM2QsIDB4ZmIzZiwgMHhmYjNmLCAweGZiNDIsIDB4ZmI0MiwgMHhmYjQ1LCAweGZiNDUsIDB4ZmJiMiwgMHhmYmQyLCAweGZkNDAsIDB4ZmQ0ZiwgMHhmZDkwLCAweGZkOTEsIDB4ZmRjOCwgMHhmZGNmLCAweGZkZmQsIDB4ZmRmZiwgMHhmZTEwLCAweGZlMWYsIDB4ZmUyNCwgMHhmZTJmLCAweGZlNDcsIDB4ZmU0OCwgMHhmZTUzLCAweGZlNTMsIDB4ZmU2NywgMHhmZTY3LCAweGZlNmMsIDB4ZmU2ZiwgMHhmZTc1LCAweGZlNzUsIDB4ZmVmZCwgMHhmZWZlLCAweGZmMDAsIDB4ZmYwMCwgMHhmZmJmLCAweGZmYzEsIDB4ZmZjOCwgMHhmZmM5LCAweGZmZDAsIDB4ZmZkMSwgMHhmZmQ4LCAweGZmZDksIDB4ZmZkZCwgMHhmZmRmLCAweGZmZTcsIDB4ZmZlNywgMHhmZmVmLCAweGZmZjgsIDB4MTAwMDAsIDB4MTAyZmYsIDB4MTAzMWYsIDB4MTAzMWYsIDB4MTAzMjQsIDB4MTAzMmYsIDB4MTAzNGIsIDB4MTAzZmYsIDB4MTA0MjYsIDB4MTA0MjcsIDB4MTA0NGUsIDB4MWNmZmYsIDB4MWQwZjYsIDB4MWQwZmYsIDB4MWQxMjcsIDB4MWQxMjksIDB4MWQxZGUsIDB4MWQzZmYsIDB4MWQ0NTUsIDB4MWQ0NTUsIDB4MWQ0OWQsIDB4MWQ0OWQsIDB4MWQ0YTAsIDB4MWQ0YTEsIDB4MWQ0YTMsIDB4MWQ0YTQsIDB4MWQ0YTcsIDB4MWQ0YTgsIDB4MWQ0YWQsIDB4MWQ0YWQsIDB4MWQ0YmEsIDB4MWQ0YmEsIDB4MWQ0YmMsIDB4MWQ0YmMsIDB4MWQ0YzEsIDB4MWQ0YzEsIDB4MWQ0YzQsIDB4MWQ0YzQsIDB4MWQ1MDYsIDB4MWQ1MDYsIDB4MWQ1MGIsIDB4MWQ1MGMsIDB4MWQ1MTUsIDB4MWQ1MTUsIDB4MWQ1MWQsIDB4MWQ1MWQsIDB4MWQ1M2EsIDB4MWQ1M2EsIDB4MWQ1M2YsIDB4MWQ1M2YsIDB4MWQ1NDUsIDB4MWQ1NDUsIDB4MWQ1NDcsIDB4MWQ1NDksIDB4MWQ1NTEsIDB4MWQ1NTEsIDB4MWQ2YTQsIDB4MWQ2YTcsIDB4MWQ3Y2EsIDB4MWQ3Y2QsIDB4MWQ4MDAsIDB4MWZmZmQsIDB4MmE2ZDcsIDB4MmY3ZmYsIDB4MmZhMWUsIDB4MmZmZmQsIDB4MzAwMDAsIDB4M2ZmZmQsIDB4NDAwMDAsIDB4NGZmZmQsIDB4NTAwMDAsIDB4NWZmZmQsIDB4NjAwMDAsIDB4NmZmZmQsIDB4NzAwMDAsIDB4N2ZmZmQsIDB4ODAwMDAsIDB4OGZmZmQsIDB4OTAwMDAsIDB4OWZmZmQsIDB4YTAwMDAsIDB4YWZmZmQsIDB4YjAwMDAsIDB4YmZmZmQsIDB4YzAwMDAsIDB4Y2ZmZmQsIDB4ZDAwMDAsIDB4ZGZmZmQsIDB4ZTAwMDAsIDB4ZTAwMDAsIDB4ZTAwMDIsIDB4ZTAwMWYsIDB4ZTAwODAsIDB4ZWZmZmRdO1xuY29uc3QgaXNVbmFzc2lnbmVkQ29kZVBvaW50ID0gY2hhcmFjdGVyID0+IGluUmFuZ2UoY2hhcmFjdGVyLCB1bmFzc2lnbmVkX2NvZGVfcG9pbnRzKTtcbmNvbnN0IGNvbW1vbmx5X21hcHBlZF90b19ub3RoaW5nID0gWzB4MDBhZCwgMHgwMGFkLCAweDAzNGYsIDB4MDM0ZiwgMHgxODA2LCAweDE4MDYsIDB4MTgwYiwgMHgxODBiLCAweDE4MGMsIDB4MTgwYywgMHgxODBkLCAweDE4MGQsIDB4MjAwYiwgMHgyMDBiLCAweDIwMGMsIDB4MjAwYywgMHgyMDBkLCAweDIwMGQsIDB4MjA2MCwgMHgyMDYwLCAweGZlMDAsIDB4ZmUwMCwgMHhmZTAxLCAweGZlMDEsIDB4ZmUwMiwgMHhmZTAyLCAweGZlMDMsIDB4ZmUwMywgMHhmZTA0LCAweGZlMDQsIDB4ZmUwNSwgMHhmZTA1LCAweGZlMDYsIDB4ZmUwNiwgMHhmZTA3LCAweGZlMDcsIDB4ZmUwOCwgMHhmZTA4LCAweGZlMDksIDB4ZmUwOSwgMHhmZTBhLCAweGZlMGEsIDB4ZmUwYiwgMHhmZTBiLCAweGZlMGMsIDB4ZmUwYywgMHhmZTBkLCAweGZlMGQsIDB4ZmUwZSwgMHhmZTBlLCAweGZlMGYsIDB4ZmUwZiwgMHhmZWZmLCAweGZlZmZdO1xuY29uc3QgaXNDb21tb25seU1hcHBlZFRvTm90aGluZyA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3RlciwgY29tbW9ubHlfbWFwcGVkX3RvX25vdGhpbmcpO1xuY29uc3Qgbm9uX0FTQ0lJX3NwYWNlX2NoYXJhY3RlcnMgPSBbMHgwMGEwLCAweDAwYTAsIDB4MTY4MCwgMHgxNjgwLCAweDIwMDAsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAyLCAweDIwMDMsIDB4MjAwMywgMHgyMDA0LCAweDIwMDQsIDB4MjAwNSwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA4LCAweDIwMDksIDB4MjAwOSwgMHgyMDBhLCAweDIwMGEsIDB4MjAwYiwgMHgyMDBiLCAweDIwMmYsIDB4MjAyZiwgMHgyMDVmLCAweDIwNWYsIDB4MzAwMCwgMHgzMDAwXTtcbmNvbnN0IGlzTm9uQVNDSUlTcGFjZUNoYXJhY3RlciA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3Rlciwgbm9uX0FTQ0lJX3NwYWNlX2NoYXJhY3RlcnMpO1xuY29uc3Qgbm9uX0FTQ0lJX2NvbnRyb2xzX2NoYXJhY3RlcnMgPSBbMHgwMDgwLCAweDAwOWYsIDB4MDZkZCwgMHgwNmRkLCAweDA3MGYsIDB4MDcwZiwgMHgxODBlLCAweDE4MGUsIDB4MjAwYywgMHgyMDBjLCAweDIwMGQsIDB4MjAwZCwgMHgyMDI4LCAweDIwMjgsIDB4MjAyOSwgMHgyMDI5LCAweDIwNjAsIDB4MjA2MCwgMHgyMDYxLCAweDIwNjEsIDB4MjA2MiwgMHgyMDYyLCAweDIwNjMsIDB4MjA2MywgMHgyMDZhLCAweDIwNmYsIDB4ZmVmZiwgMHhmZWZmLCAweGZmZjksIDB4ZmZmYywgMHgxZDE3MywgMHgxZDE3YV07XG5jb25zdCBub25fY2hhcmFjdGVyX2NvZGVwb2ludHMgPSBbMHhmZGQwLCAweGZkZWYsIDB4ZmZmZSwgMHhmZmZmLCAweDFmZmZlLCAweDFmZmZmLCAweDJmZmZlLCAweDJmZmZmLCAweDNmZmZlLCAweDNmZmZmLCAweDRmZmZlLCAweDRmZmZmLCAweDVmZmZlLCAweDVmZmZmLCAweDZmZmZlLCAweDZmZmZmLCAweDdmZmZlLCAweDdmZmZmLCAweDhmZmZlLCAweDhmZmZmLCAweDlmZmZlLCAweDlmZmZmLCAweGFmZmZlLCAweGFmZmZmLCAweGJmZmZlLCAweGJmZmZmLCAweGNmZmZlLCAweGNmZmZmLCAweGRmZmZlLCAweGRmZmZmLCAweGVmZmZlLCAweGVmZmZmLCAweDEwZmZmZSwgMHgxMGZmZmZdO1xuY29uc3QgcHJvaGliaXRlZF9jaGFyYWN0ZXJzID0gWzAsIDB4MDAxZiwgMHgwMDdmLCAweDAwN2YsIDB4MDM0MCwgMHgwMzQwLCAweDAzNDEsIDB4MDM0MSwgMHgyMDBlLCAweDIwMGUsIDB4MjAwZiwgMHgyMDBmLCAweDIwMmEsIDB4MjAyYSwgMHgyMDJiLCAweDIwMmIsIDB4MjAyYywgMHgyMDJjLCAweDIwMmQsIDB4MjAyZCwgMHgyMDJlLCAweDIwMmUsIDB4MjA2YSwgMHgyMDZhLCAweDIwNmIsIDB4MjA2YiwgMHgyMDZjLCAweDIwNmMsIDB4MjA2ZCwgMHgyMDZkLCAweDIwNmUsIDB4MjA2ZSwgMHgyMDZmLCAweDIwNmYsIDB4MmZmMCwgMHgyZmZiLCAweGQ4MDAsIDB4ZGZmZiwgMHhlMDAwLCAweGY4ZmYsIDB4ZmZmOSwgMHhmZmY5LCAweGZmZmEsIDB4ZmZmYSwgMHhmZmZiLCAweGZmZmIsIDB4ZmZmYywgMHhmZmZjLCAweGZmZmQsIDB4ZmZmZCwgMHhlMDAwMSwgMHhlMDAwMSwgMHhlMDAyMCwgMHhlMDA3ZiwgMHhmMDAwMCwgMHhmZmZmZCwgMHgxMDAwMDAsIDB4MTBmZmZkXTtcbmNvbnN0IGlzUHJvaGliaXRlZENoYXJhY3RlciA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3Rlciwgbm9uX0FTQ0lJX3NwYWNlX2NoYXJhY3RlcnMpIHx8IGluUmFuZ2UoY2hhcmFjdGVyLCBwcm9oaWJpdGVkX2NoYXJhY3RlcnMpIHx8IGluUmFuZ2UoY2hhcmFjdGVyLCBub25fQVNDSUlfY29udHJvbHNfY2hhcmFjdGVycykgfHwgaW5SYW5nZShjaGFyYWN0ZXIsIG5vbl9jaGFyYWN0ZXJfY29kZXBvaW50cyk7XG5jb25zdCBiaWRpcmVjdGlvbmFsX3JfYWwgPSBbMHgwNWJlLCAweDA1YmUsIDB4MDVjMCwgMHgwNWMwLCAweDA1YzMsIDB4MDVjMywgMHgwNWQwLCAweDA1ZWEsIDB4MDVmMCwgMHgwNWY0LCAweDA2MWIsIDB4MDYxYiwgMHgwNjFmLCAweDA2MWYsIDB4MDYyMSwgMHgwNjNhLCAweDA2NDAsIDB4MDY0YSwgMHgwNjZkLCAweDA2NmYsIDB4MDY3MSwgMHgwNmQ1LCAweDA2ZGQsIDB4MDZkZCwgMHgwNmU1LCAweDA2ZTYsIDB4MDZmYSwgMHgwNmZlLCAweDA3MDAsIDB4MDcwZCwgMHgwNzEwLCAweDA3MTAsIDB4MDcxMiwgMHgwNzJjLCAweDA3ODAsIDB4MDdhNSwgMHgwN2IxLCAweDA3YjEsIDB4MjAwZiwgMHgyMDBmLCAweGZiMWQsIDB4ZmIxZCwgMHhmYjFmLCAweGZiMjgsIDB4ZmIyYSwgMHhmYjM2LCAweGZiMzgsIDB4ZmIzYywgMHhmYjNlLCAweGZiM2UsIDB4ZmI0MCwgMHhmYjQxLCAweGZiNDMsIDB4ZmI0NCwgMHhmYjQ2LCAweGZiYjEsIDB4ZmJkMywgMHhmZDNkLCAweGZkNTAsIDB4ZmQ4ZiwgMHhmZDkyLCAweGZkYzcsIDB4ZmRmMCwgMHhmZGZjLCAweGZlNzAsIDB4ZmU3NCwgMHhmZTc2LCAweGZlZmNdO1xuY29uc3QgaXNCaWRpcmVjdGlvbmFsUkFMID0gY2hhcmFjdGVyID0+IGluUmFuZ2UoY2hhcmFjdGVyLCBiaWRpcmVjdGlvbmFsX3JfYWwpO1xuY29uc3QgYmlkaXJlY3Rpb25hbF9sID0gWzB4MDA0MSwgMHgwMDVhLCAweDAwNjEsIDB4MDA3YSwgMHgwMGFhLCAweDAwYWEsIDB4MDBiNSwgMHgwMGI1LCAweDAwYmEsIDB4MDBiYSwgMHgwMGMwLCAweDAwZDYsIDB4MDBkOCwgMHgwMGY2LCAweDAwZjgsIDB4MDIyMCwgMHgwMjIyLCAweDAyMzMsIDB4MDI1MCwgMHgwMmFkLCAweDAyYjAsIDB4MDJiOCwgMHgwMmJiLCAweDAyYzEsIDB4MDJkMCwgMHgwMmQxLCAweDAyZTAsIDB4MDJlNCwgMHgwMmVlLCAweDAyZWUsIDB4MDM3YSwgMHgwMzdhLCAweDAzODYsIDB4MDM4NiwgMHgwMzg4LCAweDAzOGEsIDB4MDM4YywgMHgwMzhjLCAweDAzOGUsIDB4MDNhMSwgMHgwM2EzLCAweDAzY2UsIDB4MDNkMCwgMHgwM2Y1LCAweDA0MDAsIDB4MDQ4MiwgMHgwNDhhLCAweDA0Y2UsIDB4MDRkMCwgMHgwNGY1LCAweDA0ZjgsIDB4MDRmOSwgMHgwNTAwLCAweDA1MGYsIDB4MDUzMSwgMHgwNTU2LCAweDA1NTksIDB4MDU1ZiwgMHgwNTYxLCAweDA1ODcsIDB4MDU4OSwgMHgwNTg5LCAweDA5MDMsIDB4MDkwMywgMHgwOTA1LCAweDA5MzksIDB4MDkzZCwgMHgwOTQwLCAweDA5NDksIDB4MDk0YywgMHgwOTUwLCAweDA5NTAsIDB4MDk1OCwgMHgwOTYxLCAweDA5NjQsIDB4MDk3MCwgMHgwOTgyLCAweDA5ODMsIDB4MDk4NSwgMHgwOThjLCAweDA5OGYsIDB4MDk5MCwgMHgwOTkzLCAweDA5YTgsIDB4MDlhYSwgMHgwOWIwLCAweDA5YjIsIDB4MDliMiwgMHgwOWI2LCAweDA5YjksIDB4MDliZSwgMHgwOWMwLCAweDA5YzcsIDB4MDljOCwgMHgwOWNiLCAweDA5Y2MsIDB4MDlkNywgMHgwOWQ3LCAweDA5ZGMsIDB4MDlkZCwgMHgwOWRmLCAweDA5ZTEsIDB4MDllNiwgMHgwOWYxLCAweDA5ZjQsIDB4MDlmYSwgMHgwYTA1LCAweDBhMGEsIDB4MGEwZiwgMHgwYTEwLCAweDBhMTMsIDB4MGEyOCwgMHgwYTJhLCAweDBhMzAsIDB4MGEzMiwgMHgwYTMzLCAweDBhMzUsIDB4MGEzNiwgMHgwYTM4LCAweDBhMzksIDB4MGEzZSwgMHgwYTQwLCAweDBhNTksIDB4MGE1YywgMHgwYTVlLCAweDBhNWUsIDB4MGE2NiwgMHgwYTZmLCAweDBhNzIsIDB4MGE3NCwgMHgwYTgzLCAweDBhODMsIDB4MGE4NSwgMHgwYThiLCAweDBhOGQsIDB4MGE4ZCwgMHgwYThmLCAweDBhOTEsIDB4MGE5MywgMHgwYWE4LCAweDBhYWEsIDB4MGFiMCwgMHgwYWIyLCAweDBhYjMsIDB4MGFiNSwgMHgwYWI5LCAweDBhYmQsIDB4MGFjMCwgMHgwYWM5LCAweDBhYzksIDB4MGFjYiwgMHgwYWNjLCAweDBhZDAsIDB4MGFkMCwgMHgwYWUwLCAweDBhZTAsIDB4MGFlNiwgMHgwYWVmLCAweDBiMDIsIDB4MGIwMywgMHgwYjA1LCAweDBiMGMsIDB4MGIwZiwgMHgwYjEwLCAweDBiMTMsIDB4MGIyOCwgMHgwYjJhLCAweDBiMzAsIDB4MGIzMiwgMHgwYjMzLCAweDBiMzYsIDB4MGIzOSwgMHgwYjNkLCAweDBiM2UsIDB4MGI0MCwgMHgwYjQwLCAweDBiNDcsIDB4MGI0OCwgMHgwYjRiLCAweDBiNGMsIDB4MGI1NywgMHgwYjU3LCAweDBiNWMsIDB4MGI1ZCwgMHgwYjVmLCAweDBiNjEsIDB4MGI2NiwgMHgwYjcwLCAweDBiODMsIDB4MGI4MywgMHgwYjg1LCAweDBiOGEsIDB4MGI4ZSwgMHgwYjkwLCAweDBiOTIsIDB4MGI5NSwgMHgwYjk5LCAweDBiOWEsIDB4MGI5YywgMHgwYjljLCAweDBiOWUsIDB4MGI5ZiwgMHgwYmEzLCAweDBiYTQsIDB4MGJhOCwgMHgwYmFhLCAweDBiYWUsIDB4MGJiNSwgMHgwYmI3LCAweDBiYjksIDB4MGJiZSwgMHgwYmJmLCAweDBiYzEsIDB4MGJjMiwgMHgwYmM2LCAweDBiYzgsIDB4MGJjYSwgMHgwYmNjLCAweDBiZDcsIDB4MGJkNywgMHgwYmU3LCAweDBiZjIsIDB4MGMwMSwgMHgwYzAzLCAweDBjMDUsIDB4MGMwYywgMHgwYzBlLCAweDBjMTAsIDB4MGMxMiwgMHgwYzI4LCAweDBjMmEsIDB4MGMzMywgMHgwYzM1LCAweDBjMzksIDB4MGM0MSwgMHgwYzQ0LCAweDBjNjAsIDB4MGM2MSwgMHgwYzY2LCAweDBjNmYsIDB4MGM4MiwgMHgwYzgzLCAweDBjODUsIDB4MGM4YywgMHgwYzhlLCAweDBjOTAsIDB4MGM5MiwgMHgwY2E4LCAweDBjYWEsIDB4MGNiMywgMHgwY2I1LCAweDBjYjksIDB4MGNiZSwgMHgwY2JlLCAweDBjYzAsIDB4MGNjNCwgMHgwY2M3LCAweDBjYzgsIDB4MGNjYSwgMHgwY2NiLCAweDBjZDUsIDB4MGNkNiwgMHgwY2RlLCAweDBjZGUsIDB4MGNlMCwgMHgwY2UxLCAweDBjZTYsIDB4MGNlZiwgMHgwZDAyLCAweDBkMDMsIDB4MGQwNSwgMHgwZDBjLCAweDBkMGUsIDB4MGQxMCwgMHgwZDEyLCAweDBkMjgsIDB4MGQyYSwgMHgwZDM5LCAweDBkM2UsIDB4MGQ0MCwgMHgwZDQ2LCAweDBkNDgsIDB4MGQ0YSwgMHgwZDRjLCAweDBkNTcsIDB4MGQ1NywgMHgwZDYwLCAweDBkNjEsIDB4MGQ2NiwgMHgwZDZmLCAweDBkODIsIDB4MGQ4MywgMHgwZDg1LCAweDBkOTYsIDB4MGQ5YSwgMHgwZGIxLCAweDBkYjMsIDB4MGRiYiwgMHgwZGJkLCAweDBkYmQsIDB4MGRjMCwgMHgwZGM2LCAweDBkY2YsIDB4MGRkMSwgMHgwZGQ4LCAweDBkZGYsIDB4MGRmMiwgMHgwZGY0LCAweDBlMDEsIDB4MGUzMCwgMHgwZTMyLCAweDBlMzMsIDB4MGU0MCwgMHgwZTQ2LCAweDBlNGYsIDB4MGU1YiwgMHgwZTgxLCAweDBlODIsIDB4MGU4NCwgMHgwZTg0LCAweDBlODcsIDB4MGU4OCwgMHgwZThhLCAweDBlOGEsIDB4MGU4ZCwgMHgwZThkLCAweDBlOTQsIDB4MGU5NywgMHgwZTk5LCAweDBlOWYsIDB4MGVhMSwgMHgwZWEzLCAweDBlYTUsIDB4MGVhNSwgMHgwZWE3LCAweDBlYTcsIDB4MGVhYSwgMHgwZWFiLCAweDBlYWQsIDB4MGViMCwgMHgwZWIyLCAweDBlYjMsIDB4MGViZCwgMHgwZWJkLCAweDBlYzAsIDB4MGVjNCwgMHgwZWM2LCAweDBlYzYsIDB4MGVkMCwgMHgwZWQ5LCAweDBlZGMsIDB4MGVkZCwgMHgwZjAwLCAweDBmMTcsIDB4MGYxYSwgMHgwZjM0LCAweDBmMzYsIDB4MGYzNiwgMHgwZjM4LCAweDBmMzgsIDB4MGYzZSwgMHgwZjQ3LCAweDBmNDksIDB4MGY2YSwgMHgwZjdmLCAweDBmN2YsIDB4MGY4NSwgMHgwZjg1LCAweDBmODgsIDB4MGY4YiwgMHgwZmJlLCAweDBmYzUsIDB4MGZjNywgMHgwZmNjLCAweDBmY2YsIDB4MGZjZiwgMHgxMDAwLCAweDEwMjEsIDB4MTAyMywgMHgxMDI3LCAweDEwMjksIDB4MTAyYSwgMHgxMDJjLCAweDEwMmMsIDB4MTAzMSwgMHgxMDMxLCAweDEwMzgsIDB4MTAzOCwgMHgxMDQwLCAweDEwNTcsIDB4MTBhMCwgMHgxMGM1LCAweDEwZDAsIDB4MTBmOCwgMHgxMGZiLCAweDEwZmIsIDB4MTEwMCwgMHgxMTU5LCAweDExNWYsIDB4MTFhMiwgMHgxMWE4LCAweDExZjksIDB4MTIwMCwgMHgxMjA2LCAweDEyMDgsIDB4MTI0NiwgMHgxMjQ4LCAweDEyNDgsIDB4MTI0YSwgMHgxMjRkLCAweDEyNTAsIDB4MTI1NiwgMHgxMjU4LCAweDEyNTgsIDB4MTI1YSwgMHgxMjVkLCAweDEyNjAsIDB4MTI4NiwgMHgxMjg4LCAweDEyODgsIDB4MTI4YSwgMHgxMjhkLCAweDEyOTAsIDB4MTJhZSwgMHgxMmIwLCAweDEyYjAsIDB4MTJiMiwgMHgxMmI1LCAweDEyYjgsIDB4MTJiZSwgMHgxMmMwLCAweDEyYzAsIDB4MTJjMiwgMHgxMmM1LCAweDEyYzgsIDB4MTJjZSwgMHgxMmQwLCAweDEyZDYsIDB4MTJkOCwgMHgxMmVlLCAweDEyZjAsIDB4MTMwZSwgMHgxMzEwLCAweDEzMTAsIDB4MTMxMiwgMHgxMzE1LCAweDEzMTgsIDB4MTMxZSwgMHgxMzIwLCAweDEzNDYsIDB4MTM0OCwgMHgxMzVhLCAweDEzNjEsIDB4MTM3YywgMHgxM2EwLCAweDEzZjQsIDB4MTQwMSwgMHgxNjc2LCAweDE2ODEsIDB4MTY5YSwgMHgxNmEwLCAweDE2ZjAsIDB4MTcwMCwgMHgxNzBjLCAweDE3MGUsIDB4MTcxMSwgMHgxNzIwLCAweDE3MzEsIDB4MTczNSwgMHgxNzM2LCAweDE3NDAsIDB4MTc1MSwgMHgxNzYwLCAweDE3NmMsIDB4MTc2ZSwgMHgxNzcwLCAweDE3ODAsIDB4MTdiNiwgMHgxN2JlLCAweDE3YzUsIDB4MTdjNywgMHgxN2M4LCAweDE3ZDQsIDB4MTdkYSwgMHgxN2RjLCAweDE3ZGMsIDB4MTdlMCwgMHgxN2U5LCAweDE4MTAsIDB4MTgxOSwgMHgxODIwLCAweDE4NzcsIDB4MTg4MCwgMHgxOGE4LCAweDFlMDAsIDB4MWU5YiwgMHgxZWEwLCAweDFlZjksIDB4MWYwMCwgMHgxZjE1LCAweDFmMTgsIDB4MWYxZCwgMHgxZjIwLCAweDFmNDUsIDB4MWY0OCwgMHgxZjRkLCAweDFmNTAsIDB4MWY1NywgMHgxZjU5LCAweDFmNTksIDB4MWY1YiwgMHgxZjViLCAweDFmNWQsIDB4MWY1ZCwgMHgxZjVmLCAweDFmN2QsIDB4MWY4MCwgMHgxZmI0LCAweDFmYjYsIDB4MWZiYywgMHgxZmJlLCAweDFmYmUsIDB4MWZjMiwgMHgxZmM0LCAweDFmYzYsIDB4MWZjYywgMHgxZmQwLCAweDFmZDMsIDB4MWZkNiwgMHgxZmRiLCAweDFmZTAsIDB4MWZlYywgMHgxZmYyLCAweDFmZjQsIDB4MWZmNiwgMHgxZmZjLCAweDIwMGUsIDB4MjAwZSwgMHgyMDcxLCAweDIwNzEsIDB4MjA3ZiwgMHgyMDdmLCAweDIxMDIsIDB4MjEwMiwgMHgyMTA3LCAweDIxMDcsIDB4MjEwYSwgMHgyMTEzLCAweDIxMTUsIDB4MjExNSwgMHgyMTE5LCAweDIxMWQsIDB4MjEyNCwgMHgyMTI0LCAweDIxMjYsIDB4MjEyNiwgMHgyMTI4LCAweDIxMjgsIDB4MjEyYSwgMHgyMTJkLCAweDIxMmYsIDB4MjEzMSwgMHgyMTMzLCAweDIxMzksIDB4MjEzZCwgMHgyMTNmLCAweDIxNDUsIDB4MjE0OSwgMHgyMTYwLCAweDIxODMsIDB4MjMzNiwgMHgyMzdhLCAweDIzOTUsIDB4MjM5NSwgMHgyNDljLCAweDI0ZTksIDB4MzAwNSwgMHgzMDA3LCAweDMwMjEsIDB4MzAyOSwgMHgzMDMxLCAweDMwMzUsIDB4MzAzOCwgMHgzMDNjLCAweDMwNDEsIDB4MzA5NiwgMHgzMDlkLCAweDMwOWYsIDB4MzBhMSwgMHgzMGZhLCAweDMwZmMsIDB4MzBmZiwgMHgzMTA1LCAweDMxMmMsIDB4MzEzMSwgMHgzMThlLCAweDMxOTAsIDB4MzFiNywgMHgzMWYwLCAweDMyMWMsIDB4MzIyMCwgMHgzMjQzLCAweDMyNjAsIDB4MzI3YiwgMHgzMjdmLCAweDMyYjAsIDB4MzJjMCwgMHgzMmNiLCAweDMyZDAsIDB4MzJmZSwgMHgzMzAwLCAweDMzNzYsIDB4MzM3YiwgMHgzM2RkLCAweDMzZTAsIDB4MzNmZSwgMHgzNDAwLCAweDRkYjUsIDB4NGUwMCwgMHg5ZmE1LCAweGEwMDAsIDB4YTQ4YywgMHhhYzAwLCAweGQ3YTMsIDB4ZDgwMCwgMHhmYTJkLCAweGZhMzAsIDB4ZmE2YSwgMHhmYjAwLCAweGZiMDYsIDB4ZmIxMywgMHhmYjE3LCAweGZmMjEsIDB4ZmYzYSwgMHhmZjQxLCAweGZmNWEsIDB4ZmY2NiwgMHhmZmJlLCAweGZmYzIsIDB4ZmZjNywgMHhmZmNhLCAweGZmY2YsIDB4ZmZkMiwgMHhmZmQ3LCAweGZmZGEsIDB4ZmZkYywgMHgxMDMwMCwgMHgxMDMxZSwgMHgxMDMyMCwgMHgxMDMyMywgMHgxMDMzMCwgMHgxMDM0YSwgMHgxMDQwMCwgMHgxMDQyNSwgMHgxMDQyOCwgMHgxMDQ0ZCwgMHgxZDAwMCwgMHgxZDBmNSwgMHgxZDEwMCwgMHgxZDEyNiwgMHgxZDEyYSwgMHgxZDE2NiwgMHgxZDE2YSwgMHgxZDE3MiwgMHgxZDE4MywgMHgxZDE4NCwgMHgxZDE4YywgMHgxZDFhOSwgMHgxZDFhZSwgMHgxZDFkZCwgMHgxZDQwMCwgMHgxZDQ1NCwgMHgxZDQ1NiwgMHgxZDQ5YywgMHgxZDQ5ZSwgMHgxZDQ5ZiwgMHgxZDRhMiwgMHgxZDRhMiwgMHgxZDRhNSwgMHgxZDRhNiwgMHgxZDRhOSwgMHgxZDRhYywgMHgxZDRhZSwgMHgxZDRiOSwgMHgxZDRiYiwgMHgxZDRiYiwgMHgxZDRiZCwgMHgxZDRjMCwgMHgxZDRjMiwgMHgxZDRjMywgMHgxZDRjNSwgMHgxZDUwNSwgMHgxZDUwNywgMHgxZDUwYSwgMHgxZDUwZCwgMHgxZDUxNCwgMHgxZDUxNiwgMHgxZDUxYywgMHgxZDUxZSwgMHgxZDUzOSwgMHgxZDUzYiwgMHgxZDUzZSwgMHgxZDU0MCwgMHgxZDU0NCwgMHgxZDU0NiwgMHgxZDU0NiwgMHgxZDU0YSwgMHgxZDU1MCwgMHgxZDU1MiwgMHgxZDZhMywgMHgxZDZhOCwgMHgxZDdjOSwgMHgyMDAwMCwgMHgyYTZkNiwgMHgyZjgwMCwgMHgyZmExZCwgMHhmMDAwMCwgMHhmZmZmZCwgMHgxMDAwMDAsIDB4MTBmZmZkXTtcbmNvbnN0IGlzQmlkaXJlY3Rpb25hbEwgPSBjaGFyYWN0ZXIgPT4gaW5SYW5nZShjaGFyYWN0ZXIsIGJpZGlyZWN0aW9uYWxfbCk7XG5cbmNvbnN0IG1hcHBpbmcyc3BhY2UgPSBpc05vbkFTQ0lJU3BhY2VDaGFyYWN0ZXI7XG5jb25zdCBtYXBwaW5nMm5vdGhpbmcgPSBpc0NvbW1vbmx5TWFwcGVkVG9Ob3RoaW5nO1xuY29uc3QgZ2V0Q29kZVBvaW50ID0gY2hhcmFjdGVyID0+IGNoYXJhY3Rlci5jb2RlUG9pbnRBdCgwKTtcbmNvbnN0IGZpcnN0ID0geCA9PiB4WzBdO1xuY29uc3QgbGFzdCA9IHggPT4geFt4Lmxlbmd0aCAtIDFdO1xuZnVuY3Rpb24gdG9Db2RlUG9pbnRzKGlucHV0KSB7XG4gIGNvbnN0IGNvZGVwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2l6ZSA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChiZWZvcmUgPj0gMHhkODAwICYmIGJlZm9yZSA8PSAweGRiZmYgJiYgc2l6ZSA+IGkgKyAxKSB7XG4gICAgICBjb25zdCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICBpZiAobmV4dCA+PSAweGRjMDAgJiYgbmV4dCA8PSAweGRmZmYpIHtcbiAgICAgICAgY29kZXBvaW50cy5wdXNoKChiZWZvcmUgLSAweGQ4MDApICogMHg0MDAgKyBuZXh0IC0gMHhkYzAwICsgMHgxMDAwMCk7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvZGVwb2ludHMucHVzaChiZWZvcmUpO1xuICB9XG4gIHJldHVybiBjb2RlcG9pbnRzO1xufVxuZnVuY3Rpb24gc2FzbHByZXAoaW5wdXQpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHN0cmluZy4nKTtcbiAgfVxuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IG1hcHBlZF9pbnB1dCA9IHRvQ29kZVBvaW50cyhpbnB1dCkubWFwKGNoYXJhY3RlciA9PiBtYXBwaW5nMnNwYWNlKGNoYXJhY3RlcikgPyAweDIwIDogY2hhcmFjdGVyKS5maWx0ZXIoY2hhcmFjdGVyID0+ICFtYXBwaW5nMm5vdGhpbmcoY2hhcmFjdGVyKSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRfaW5wdXQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCBtYXBwZWRfaW5wdXQpLm5vcm1hbGl6ZSgnTkZLQycpO1xuICBjb25zdCBub3JtYWxpemVkX21hcCA9IHRvQ29kZVBvaW50cyhub3JtYWxpemVkX2lucHV0KTtcbiAgY29uc3QgaGFzUHJvaGliaXRlZCA9IG5vcm1hbGl6ZWRfbWFwLnNvbWUoaXNQcm9oaWJpdGVkQ2hhcmFjdGVyKTtcbiAgaWYgKGhhc1Byb2hpYml0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2hpYml0ZWQgY2hhcmFjdGVyLCBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQwMTMjc2VjdGlvbi0yLjMnKTtcbiAgfVxuICBpZiAob3B0cy5hbGxvd1VuYXNzaWduZWQgIT09IHRydWUpIHtcbiAgICBjb25zdCBoYXNVbmFzc2lnbmVkID0gbm9ybWFsaXplZF9tYXAuc29tZShpc1VuYXNzaWduZWRDb2RlUG9pbnQpO1xuICAgIGlmIChoYXNVbmFzc2lnbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYXNzaWduZWQgY29kZSBwb2ludCwgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MDEzI3NlY3Rpb24tMi41Jyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc0JpZGlSQUwgPSBub3JtYWxpemVkX21hcC5zb21lKGlzQmlkaXJlY3Rpb25hbFJBTCk7XG4gIGNvbnN0IGhhc0JpZGlMID0gbm9ybWFsaXplZF9tYXAuc29tZShpc0JpZGlyZWN0aW9uYWxMKTtcbiAgaWYgKGhhc0JpZGlSQUwgJiYgaGFzQmlkaUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBtdXN0IG5vdCBjb250YWluIFJhbmRBTENhdCBhbmQgTENhdCBhdCB0aGUgc2FtZSB0aW1lLCcgKyAnIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNzZWN0aW9uLTYnKTtcbiAgfVxuICBjb25zdCBpc0ZpcnN0QmlkaVJBTCA9IGlzQmlkaXJlY3Rpb25hbFJBTChnZXRDb2RlUG9pbnQoZmlyc3Qobm9ybWFsaXplZF9pbnB1dCkpKTtcbiAgY29uc3QgaXNMYXN0QmlkaVJBTCA9IGlzQmlkaXJlY3Rpb25hbFJBTChnZXRDb2RlUG9pbnQobGFzdChub3JtYWxpemVkX2lucHV0KSkpO1xuICBpZiAoaGFzQmlkaVJBTCAmJiAhKGlzRmlyc3RCaWRpUkFMICYmIGlzTGFzdEJpZGlSQUwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCaWRpcmVjdGlvbmFsIFJhbmRBTENhdCBjaGFyYWN0ZXIgbXVzdCBiZSB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0JyArICcgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcsIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNzZWN0aW9uLTYnKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZF9pbnB1dDtcbn1cblxuY2xhc3MgUERGU2VjdXJpdHkge1xuICBzdGF0aWMgZ2VuZXJhdGVGaWxlSUQoKSB7XG4gICAgbGV0IGluZm8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBpbmZvU3RyID0gYCR7aW5mby5DcmVhdGlvbkRhdGUuZ2V0VGltZSgpfVxcbmA7XG4gICAgZm9yIChsZXQga2V5IGluIGluZm8pIHtcbiAgICAgIGlmICghaW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5mb1N0ciArPSBgJHtrZXl9OiAke2luZm9ba2V5XS52YWx1ZU9mKCl9XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmRBcnJheVRvQnVmZmVyKENyeXB0b0pTLk1ENShpbmZvU3RyKSk7XG4gIH1cbiAgc3RhdGljIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KGJ5dGVzKSB7XG4gICAgcmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGRvY3VtZW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmICghb3B0aW9ucy5vd25lclBhc3N3b3JkICYmICFvcHRpb25zLnVzZXJQYXNzd29yZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGU2VjdXJpdHkoZG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmICghb3B0aW9ucy5vd25lclBhc3N3b3JkICYmICFvcHRpb25zLnVzZXJQYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIG93bmVyIHBhc3N3b3JkIGFuZCB1c2VyIHBhc3N3b3JkIGlzIGRlZmluZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLl9zZXR1cEVuY3J5cHRpb24ob3B0aW9ucyk7XG4gIH1cbiAgX3NldHVwRW5jcnlwdGlvbihvcHRpb25zKSB7XG4gICAgc3dpdGNoIChvcHRpb25zLnBkZlZlcnNpb24pIHtcbiAgICAgIGNhc2UgJzEuNCc6XG4gICAgICBjYXNlICcxLjUnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEuNic6XG4gICAgICBjYXNlICcxLjcnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEuN2V4dDMnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSA1O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBlbmNEaWN0ID0ge1xuICAgICAgRmlsdGVyOiAnU3RhbmRhcmQnXG4gICAgfTtcbiAgICBzd2l0Y2ggKHRoaXMudmVyc2lvbikge1xuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSA0OlxuICAgICAgICB0aGlzLl9zZXR1cEVuY3J5cHRpb25WMVYyVjQodGhpcy52ZXJzaW9uLCBlbmNEaWN0LCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHRoaXMuX3NldHVwRW5jcnlwdGlvblY1KGVuY0RpY3QsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5kaWN0aW9uYXJ5ID0gdGhpcy5kb2N1bWVudC5yZWYoZW5jRGljdCk7XG4gIH1cbiAgX3NldHVwRW5jcnlwdGlvblYxVjJWNCh2LCBlbmNEaWN0LCBvcHRpb25zKSB7XG4gICAgbGV0IHIsIHBlcm1pc3Npb25zO1xuICAgIHN3aXRjaCAodikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByID0gMjtcbiAgICAgICAgdGhpcy5rZXlCaXRzID0gNDA7XG4gICAgICAgIHBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnNSMihvcHRpb25zLnBlcm1pc3Npb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHIgPSAzO1xuICAgICAgICB0aGlzLmtleUJpdHMgPSAxMjg7XG4gICAgICAgIHBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnNSMyhvcHRpb25zLnBlcm1pc3Npb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSA0O1xuICAgICAgICB0aGlzLmtleUJpdHMgPSAxMjg7XG4gICAgICAgIHBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnNSMyhvcHRpb25zLnBlcm1pc3Npb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRlZFVzZXJQYXNzd29yZCA9IHByb2Nlc3NQYXNzd29yZFIyUjNSNChvcHRpb25zLnVzZXJQYXNzd29yZCk7XG4gICAgY29uc3QgcGFkZGVkT3duZXJQYXNzd29yZCA9IG9wdGlvbnMub3duZXJQYXNzd29yZCA/IHByb2Nlc3NQYXNzd29yZFIyUjNSNChvcHRpb25zLm93bmVyUGFzc3dvcmQpIDogcGFkZGVkVXNlclBhc3N3b3JkO1xuICAgIGNvbnN0IG93bmVyUGFzc3dvcmRFbnRyeSA9IGdldE93bmVyUGFzc3dvcmRSMlIzUjQociwgdGhpcy5rZXlCaXRzLCBwYWRkZWRVc2VyUGFzc3dvcmQsIHBhZGRlZE93bmVyUGFzc3dvcmQpO1xuICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGdldEVuY3J5cHRpb25LZXlSMlIzUjQociwgdGhpcy5rZXlCaXRzLCB0aGlzLmRvY3VtZW50Ll9pZCwgcGFkZGVkVXNlclBhc3N3b3JkLCBvd25lclBhc3N3b3JkRW50cnksIHBlcm1pc3Npb25zKTtcbiAgICBsZXQgdXNlclBhc3N3b3JkRW50cnk7XG4gICAgaWYgKHIgPT09IDIpIHtcbiAgICAgIHVzZXJQYXNzd29yZEVudHJ5ID0gZ2V0VXNlclBhc3N3b3JkUjIodGhpcy5lbmNyeXB0aW9uS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSM1I0KHRoaXMuZG9jdW1lbnQuX2lkLCB0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgIH1cbiAgICBlbmNEaWN0LlYgPSB2O1xuICAgIGlmICh2ID49IDIpIHtcbiAgICAgIGVuY0RpY3QuTGVuZ3RoID0gdGhpcy5rZXlCaXRzO1xuICAgIH1cbiAgICBpZiAodiA9PT0gNCkge1xuICAgICAgZW5jRGljdC5DRiA9IHtcbiAgICAgICAgU3RkQ0Y6IHtcbiAgICAgICAgICBBdXRoRXZlbnQ6ICdEb2NPcGVuJyxcbiAgICAgICAgICBDRk06ICdBRVNWMicsXG4gICAgICAgICAgTGVuZ3RoOiB0aGlzLmtleUJpdHMgLyA4XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbmNEaWN0LlN0bUYgPSAnU3RkQ0YnO1xuICAgICAgZW5jRGljdC5TdHJGID0gJ1N0ZENGJztcbiAgICB9XG4gICAgZW5jRGljdC5SID0gcjtcbiAgICBlbmNEaWN0Lk8gPSB3b3JkQXJyYXlUb0J1ZmZlcihvd25lclBhc3N3b3JkRW50cnkpO1xuICAgIGVuY0RpY3QuVSA9IHdvcmRBcnJheVRvQnVmZmVyKHVzZXJQYXNzd29yZEVudHJ5KTtcbiAgICBlbmNEaWN0LlAgPSBwZXJtaXNzaW9ucztcbiAgfVxuICBfc2V0dXBFbmNyeXB0aW9uVjUoZW5jRGljdCwgb3B0aW9ucykge1xuICAgIHRoaXMua2V5Qml0cyA9IDI1NjtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGdldFBlcm1pc3Npb25zUjMob3B0aW9ucy5wZXJtaXNzaW9ucyk7XG4gICAgY29uc3QgcHJvY2Vzc2VkVXNlclBhc3N3b3JkID0gcHJvY2Vzc1Bhc3N3b3JkUjUob3B0aW9ucy51c2VyUGFzc3dvcmQpO1xuICAgIGNvbnN0IHByb2Nlc3NlZE93bmVyUGFzc3dvcmQgPSBvcHRpb25zLm93bmVyUGFzc3dvcmQgPyBwcm9jZXNzUGFzc3dvcmRSNShvcHRpb25zLm93bmVyUGFzc3dvcmQpIDogcHJvY2Vzc2VkVXNlclBhc3N3b3JkO1xuICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGdldEVuY3J5cHRpb25LZXlSNShQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgY29uc3QgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSNShwcm9jZXNzZWRVc2VyUGFzc3dvcmQsIFBERlNlY3VyaXR5LmdlbmVyYXRlUmFuZG9tV29yZEFycmF5KTtcbiAgICBjb25zdCB1c2VyS2V5U2FsdCA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKHVzZXJQYXNzd29yZEVudHJ5LndvcmRzLnNsaWNlKDEwLCAxMiksIDgpO1xuICAgIGNvbnN0IHVzZXJFbmNyeXB0aW9uS2V5RW50cnkgPSBnZXRVc2VyRW5jcnlwdGlvbktleVI1KHByb2Nlc3NlZFVzZXJQYXNzd29yZCwgdXNlcktleVNhbHQsIHRoaXMuZW5jcnlwdGlvbktleSk7XG4gICAgY29uc3Qgb3duZXJQYXNzd29yZEVudHJ5ID0gZ2V0T3duZXJQYXNzd29yZFI1KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQsIHVzZXJQYXNzd29yZEVudHJ5LCBQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgY29uc3Qgb3duZXJLZXlTYWx0ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3duZXJQYXNzd29yZEVudHJ5LndvcmRzLnNsaWNlKDEwLCAxMiksIDgpO1xuICAgIGNvbnN0IG93bmVyRW5jcnlwdGlvbktleUVudHJ5ID0gZ2V0T3duZXJFbmNyeXB0aW9uS2V5UjUocHJvY2Vzc2VkT3duZXJQYXNzd29yZCwgb3duZXJLZXlTYWx0LCB1c2VyUGFzc3dvcmRFbnRyeSwgdGhpcy5lbmNyeXB0aW9uS2V5KTtcbiAgICBjb25zdCBwZXJtc0VudHJ5ID0gZ2V0RW5jcnlwdGVkUGVybWlzc2lvbnNSNShwZXJtaXNzaW9ucywgdGhpcy5lbmNyeXB0aW9uS2V5LCBQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgZW5jRGljdC5WID0gNTtcbiAgICBlbmNEaWN0Lkxlbmd0aCA9IHRoaXMua2V5Qml0cztcbiAgICBlbmNEaWN0LkNGID0ge1xuICAgICAgU3RkQ0Y6IHtcbiAgICAgICAgQXV0aEV2ZW50OiAnRG9jT3BlbicsXG4gICAgICAgIENGTTogJ0FFU1YzJyxcbiAgICAgICAgTGVuZ3RoOiB0aGlzLmtleUJpdHMgLyA4XG4gICAgICB9XG4gICAgfTtcbiAgICBlbmNEaWN0LlN0bUYgPSAnU3RkQ0YnO1xuICAgIGVuY0RpY3QuU3RyRiA9ICdTdGRDRic7XG4gICAgZW5jRGljdC5SID0gNTtcbiAgICBlbmNEaWN0Lk8gPSB3b3JkQXJyYXlUb0J1ZmZlcihvd25lclBhc3N3b3JkRW50cnkpO1xuICAgIGVuY0RpY3QuT0UgPSB3b3JkQXJyYXlUb0J1ZmZlcihvd25lckVuY3J5cHRpb25LZXlFbnRyeSk7XG4gICAgZW5jRGljdC5VID0gd29yZEFycmF5VG9CdWZmZXIodXNlclBhc3N3b3JkRW50cnkpO1xuICAgIGVuY0RpY3QuVUUgPSB3b3JkQXJyYXlUb0J1ZmZlcih1c2VyRW5jcnlwdGlvbktleUVudHJ5KTtcbiAgICBlbmNEaWN0LlAgPSBwZXJtaXNzaW9ucztcbiAgICBlbmNEaWN0LlBlcm1zID0gd29yZEFycmF5VG9CdWZmZXIocGVybXNFbnRyeSk7XG4gIH1cbiAgZ2V0RW5jcnlwdEZuKG9iaiwgZ2VuKSB7XG4gICAgbGV0IGRpZ2VzdDtcbiAgICBpZiAodGhpcy52ZXJzaW9uIDwgNSkge1xuICAgICAgZGlnZXN0ID0gdGhpcy5lbmNyeXB0aW9uS2V5LmNsb25lKCkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsob2JqICYgMHhmZikgPDwgMjQgfCAob2JqICYgMHhmZjAwKSA8PCA4IHwgb2JqID4+IDggJiAweGZmMDAgfCBnZW4gJiAweGZmLCAoZ2VuICYgMHhmZjAwKSA8PCAxNl0sIDUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSB8fCB0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIGxldCBrZXkgPSBDcnlwdG9KUy5NRDUoZGlnZXN0KTtcbiAgICAgIGtleS5zaWdCeXRlcyA9IE1hdGgubWluKDE2LCB0aGlzLmtleUJpdHMgLyA4ICsgNSk7XG4gICAgICByZXR1cm4gYnVmZmVyID0+IHdvcmRBcnJheVRvQnVmZmVyKENyeXB0b0pTLlJDNC5lbmNyeXB0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGJ1ZmZlciksIGtleSkuY2lwaGVydGV4dCk7XG4gICAgfVxuICAgIGxldCBrZXk7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gNCkge1xuICAgICAga2V5ID0gQ3J5cHRvSlMuTUQ1KGRpZ2VzdC5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4NzM0MTZjNTRdLCA0KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSB0aGlzLmVuY3J5cHRpb25LZXk7XG4gICAgfVxuICAgIGNvbnN0IGl2ID0gUERGU2VjdXJpdHkuZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoMTYpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzNyxcbiAgICAgIGl2XG4gICAgfTtcbiAgICByZXR1cm4gYnVmZmVyID0+IHdvcmRBcnJheVRvQnVmZmVyKGl2LmNsb25lKCkuY29uY2F0KENyeXB0b0pTLkFFUy5lbmNyeXB0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGJ1ZmZlciksIGtleSwgb3B0aW9ucykuY2lwaGVydGV4dCkpO1xuICB9XG4gIGVuZCgpIHtcbiAgICB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBlcm1pc3Npb25zUjIoKSB7XG4gIGxldCBwZXJtaXNzaW9uT2JqZWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IHBlcm1pc3Npb25zID0gMHhmZmZmZmZjMCA+PiAwO1xuICBpZiAocGVybWlzc2lvbk9iamVjdC5wcmludGluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDAwMTAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0Lm1vZGlmeWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDAxMDAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmNvcHlpbmcpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDAxMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5hbm5vdGF0aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAwMDAxMDAwMDA7XG4gIH1cbiAgcmV0dXJuIHBlcm1pc3Npb25zO1xufVxuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbnNSMygpIHtcbiAgbGV0IHBlcm1pc3Npb25PYmplY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgcGVybWlzc2lvbnMgPSAweGZmZmZmMGMwID4+IDA7XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LnByaW50aW5nID09PSAnbG93UmVzb2x1dGlvbicpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDAwMDEwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5wcmludGluZyA9PT0gJ2hpZ2hSZXNvbHV0aW9uJykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMTAwMDAwMDAwMTAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0Lm1vZGlmeWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDAxMDAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmNvcHlpbmcpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDAxMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5hbm5vdGF0aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAwMDAxMDAwMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuZmlsbGluZ0Zvcm1zKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAxMDAwMDAwMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuY29udGVudEFjY2Vzc2liaWxpdHkpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMTAwMDAwMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5kb2N1bWVudEFzc2VtYmx5KSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMTAwMDAwMDAwMDA7XG4gIH1cbiAgcmV0dXJuIHBlcm1pc3Npb25zO1xufVxuZnVuY3Rpb24gZ2V0VXNlclBhc3N3b3JkUjIoZW5jcnlwdGlvbktleSkge1xuICByZXR1cm4gQ3J5cHRvSlMuUkM0LmVuY3J5cHQocHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KCksIGVuY3J5cHRpb25LZXkpLmNpcGhlcnRleHQ7XG59XG5mdW5jdGlvbiBnZXRVc2VyUGFzc3dvcmRSM1I0KGRvY3VtZW50SWQsIGVuY3J5cHRpb25LZXkpIHtcbiAgY29uc3Qga2V5ID0gZW5jcnlwdGlvbktleS5jbG9uZSgpO1xuICBsZXQgY2lwaGVyID0gQ3J5cHRvSlMuTUQ1KHByb2Nlc3NQYXNzd29yZFIyUjNSNCgpLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShkb2N1bWVudElkKSkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICBjb25zdCB4b3JSb3VuZCA9IE1hdGguY2VpbChrZXkuc2lnQnl0ZXMgLyA0KTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHhvclJvdW5kOyBqKyspIHtcbiAgICAgIGtleS53b3Jkc1tqXSA9IGVuY3J5cHRpb25LZXkud29yZHNbal0gXiAoaSB8IGkgPDwgOCB8IGkgPDwgMTYgfCBpIDw8IDI0KTtcbiAgICB9XG4gICAgY2lwaGVyID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQoY2lwaGVyLCBrZXkpLmNpcGhlcnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNpcGhlci5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUobnVsbCwgMTYpKTtcbn1cbmZ1bmN0aW9uIGdldE93bmVyUGFzc3dvcmRSMlIzUjQociwga2V5Qml0cywgcGFkZGVkVXNlclBhc3N3b3JkLCBwYWRkZWRPd25lclBhc3N3b3JkKSB7XG4gIGxldCBkaWdlc3QgPSBwYWRkZWRPd25lclBhc3N3b3JkO1xuICBsZXQgcm91bmQgPSByID49IDMgPyA1MSA6IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmQ7IGkrKykge1xuICAgIGRpZ2VzdCA9IENyeXB0b0pTLk1ENShkaWdlc3QpO1xuICB9XG4gIGNvbnN0IGtleSA9IGRpZ2VzdC5jbG9uZSgpO1xuICBrZXkuc2lnQnl0ZXMgPSBrZXlCaXRzIC8gODtcbiAgbGV0IGNpcGhlciA9IHBhZGRlZFVzZXJQYXNzd29yZDtcbiAgcm91bmQgPSByID49IDMgPyAyMCA6IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmQ7IGkrKykge1xuICAgIGNvbnN0IHhvclJvdW5kID0gTWF0aC5jZWlsKGtleS5zaWdCeXRlcyAvIDQpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgeG9yUm91bmQ7IGorKykge1xuICAgICAga2V5LndvcmRzW2pdID0gZGlnZXN0LndvcmRzW2pdIF4gKGkgfCBpIDw8IDggfCBpIDw8IDE2IHwgaSA8PCAyNCk7XG4gICAgfVxuICAgIGNpcGhlciA9IENyeXB0b0pTLlJDNC5lbmNyeXB0KGNpcGhlciwga2V5KS5jaXBoZXJ0ZXh0O1xuICB9XG4gIHJldHVybiBjaXBoZXI7XG59XG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uS2V5UjJSM1I0KHIsIGtleUJpdHMsIGRvY3VtZW50SWQsIHBhZGRlZFVzZXJQYXNzd29yZCwgb3duZXJQYXNzd29yZEVudHJ5LCBwZXJtaXNzaW9ucykge1xuICBsZXQga2V5ID0gcGFkZGVkVXNlclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KG93bmVyUGFzc3dvcmRFbnRyeSkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtsc2JGaXJzdFdvcmQocGVybWlzc2lvbnMpXSwgNCkpLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShkb2N1bWVudElkKSk7XG4gIGNvbnN0IHJvdW5kID0gciA+PSAzID8gNTEgOiAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kOyBpKyspIHtcbiAgICBrZXkgPSBDcnlwdG9KUy5NRDUoa2V5KTtcbiAgICBrZXkuc2lnQnl0ZXMgPSBrZXlCaXRzIC8gODtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gZ2V0VXNlclBhc3N3b3JkUjUocHJvY2Vzc2VkVXNlclBhc3N3b3JkLCBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICBjb25zdCB2YWxpZGF0aW9uU2FsdCA9IGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDgpO1xuICBjb25zdCBrZXlTYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIHJldHVybiBDcnlwdG9KUy5TSEEyNTYocHJvY2Vzc2VkVXNlclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KHZhbGlkYXRpb25TYWx0KSkuY29uY2F0KHZhbGlkYXRpb25TYWx0KS5jb25jYXQoa2V5U2FsdCk7XG59XG5mdW5jdGlvbiBnZXRVc2VyRW5jcnlwdGlvbktleVI1KHByb2Nlc3NlZFVzZXJQYXNzd29yZCwgdXNlcktleVNhbHQsIGVuY3J5cHRpb25LZXkpIHtcbiAgY29uc3Qga2V5ID0gQ3J5cHRvSlMuU0hBMjU2KHByb2Nlc3NlZFVzZXJQYXNzd29yZC5jbG9uZSgpLmNvbmNhdCh1c2VyS2V5U2FsdCkpO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Ob1BhZGRpbmcsXG4gICAgaXY6IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKG51bGwsIDE2KVxuICB9O1xuICByZXR1cm4gQ3J5cHRvSlMuQUVTLmVuY3J5cHQoZW5jcnlwdGlvbktleSwga2V5LCBvcHRpb25zKS5jaXBoZXJ0ZXh0O1xufVxuZnVuY3Rpb24gZ2V0T3duZXJQYXNzd29yZFI1KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQsIHVzZXJQYXNzd29yZEVudHJ5LCBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICBjb25zdCB2YWxpZGF0aW9uU2FsdCA9IGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDgpO1xuICBjb25zdCBrZXlTYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIHJldHVybiBDcnlwdG9KUy5TSEEyNTYocHJvY2Vzc2VkT3duZXJQYXNzd29yZC5jbG9uZSgpLmNvbmNhdCh2YWxpZGF0aW9uU2FsdCkuY29uY2F0KHVzZXJQYXNzd29yZEVudHJ5KSkuY29uY2F0KHZhbGlkYXRpb25TYWx0KS5jb25jYXQoa2V5U2FsdCk7XG59XG5mdW5jdGlvbiBnZXRPd25lckVuY3J5cHRpb25LZXlSNShwcm9jZXNzZWRPd25lclBhc3N3b3JkLCBvd25lcktleVNhbHQsIHVzZXJQYXNzd29yZEVudHJ5LCBlbmNyeXB0aW9uS2V5KSB7XG4gIGNvbnN0IGtleSA9IENyeXB0b0pTLlNIQTI1Nihwcm9jZXNzZWRPd25lclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KG93bmVyS2V5U2FsdCkuY29uY2F0KHVzZXJQYXNzd29yZEVudHJ5KSk7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyxcbiAgICBpdjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUobnVsbCwgMTYpXG4gIH07XG4gIHJldHVybiBDcnlwdG9KUy5BRVMuZW5jcnlwdChlbmNyeXB0aW9uS2V5LCBrZXksIG9wdGlvbnMpLmNpcGhlcnRleHQ7XG59XG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uS2V5UjUoZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkpIHtcbiAgcmV0dXJuIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDMyKTtcbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRlZFBlcm1pc3Npb25zUjUocGVybWlzc2lvbnMsIGVuY3J5cHRpb25LZXksIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KSB7XG4gIGNvbnN0IGNpcGhlciA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtsc2JGaXJzdFdvcmQocGVybWlzc2lvbnMpLCAweGZmZmZmZmZmLCAweDU0NjE2NDYyXSwgMTIpLmNvbmNhdChnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSg0KSk7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZ1xuICB9O1xuICByZXR1cm4gQ3J5cHRvSlMuQUVTLmVuY3J5cHQoY2lwaGVyLCBlbmNyeXB0aW9uS2V5LCBvcHRpb25zKS5jaXBoZXJ0ZXh0O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KCkge1xuICBsZXQgcGFzc3dvcmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICBjb25zdCBvdXQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICBjb25zdCBsZW5ndGggPSBwYXNzd29yZC5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiBpbmRleCA8IDMyKSB7XG4gICAgY29uc3QgY29kZSA9IHBhc3N3b3JkLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGlmIChjb2RlID4gMHhmZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCBjb250YWlucyBvbmUgb3IgbW9yZSBpbnZhbGlkIGNoYXJhY3RlcnMuJyk7XG4gICAgfVxuICAgIG91dFtpbmRleF0gPSBjb2RlO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgd2hpbGUgKGluZGV4IDwgMzIpIHtcbiAgICBvdXRbaW5kZXhdID0gUEFTU1dPUkRfUEFERElOR1tpbmRleCAtIGxlbmd0aF07XG4gICAgaW5kZXgrKztcbiAgfVxuICByZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3V0KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NQYXNzd29yZFI1KCkge1xuICBsZXQgcGFzc3dvcmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICBwYXNzd29yZCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzYXNscHJlcChwYXNzd29yZCkpKTtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oMTI3LCBwYXNzd29yZC5sZW5ndGgpO1xuICBjb25zdCBvdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dFtpXSA9IHBhc3N3b3JkLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKG91dCk7XG59XG5mdW5jdGlvbiBsc2JGaXJzdFdvcmQoZGF0YSkge1xuICByZXR1cm4gKGRhdGEgJiAweGZmKSA8PCAyNCB8IChkYXRhICYgMHhmZjAwKSA8PCA4IHwgZGF0YSA+PiA4ICYgMHhmZjAwIHwgZGF0YSA+PiAyNCAmIDB4ZmY7XG59XG5mdW5jdGlvbiB3b3JkQXJyYXlUb0J1ZmZlcih3b3JkQXJyYXkpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZEFycmF5LnNpZ0J5dGVzOyBpKyspIHtcbiAgICBieXRlQXJyYXkucHVzaCh3b3JkQXJyYXkud29yZHNbTWF0aC5mbG9vcihpIC8gNCldID4+IDggKiAoMyAtIGkgJSA0KSAmIDB4ZmYpO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShieXRlQXJyYXkpO1xufVxuY29uc3QgUEFTU1dPUkRfUEFERElORyA9IFsweDI4LCAweGJmLCAweDRlLCAweDVlLCAweDRlLCAweDc1LCAweDhhLCAweDQxLCAweDY0LCAweDAwLCAweDRlLCAweDU2LCAweGZmLCAweGZhLCAweDAxLCAweDA4LCAweDJlLCAweDJlLCAweDAwLCAweGI2LCAweGQwLCAweDY4LCAweDNlLCAweDgwLCAweDJmLCAweDBjLCAweGE5LCAweGZlLCAweDY0LCAweDUzLCAweDY5LCAweDdhXTtcblxuY29uc3Qge1xuICBudW1iZXI6IG51bWJlciQyXG59ID0gUERGT2JqZWN0O1xuY2xhc3MgUERGR3JhZGllbnQkMSB7XG4gIGNvbnN0cnVjdG9yKGRvYykge1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICB0aGlzLmVtYmVkZGVkID0gZmFsc2U7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gIH1cbiAgc3RvcChwb3MsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgaWYgKG9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGNvbG9yID0gdGhpcy5kb2MuX25vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgICBpZiAodGhpcy5zdG9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9ICdEZXZpY2VSR0InO1xuICAgICAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9ICdEZXZpY2VDTVlLJztcbiAgICAgIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yU3BhY2UgPSAnRGV2aWNlR3JheSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29sb3Igc3BhY2UnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbG9yU3BhY2UgPT09ICdEZXZpY2VSR0InICYmIGNvbG9yLmxlbmd0aCAhPT0gMyB8fCB0aGlzLl9jb2xvclNwYWNlID09PSAnRGV2aWNlQ01ZSycgJiYgY29sb3IubGVuZ3RoICE9PSA0IHx8IHRoaXMuX2NvbG9yU3BhY2UgPT09ICdEZXZpY2VHcmF5JyAmJiBjb2xvci5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGdyYWRpZW50IHN0b3BzIG11c3QgdXNlIHRoZSBzYW1lIGNvbG9yIHNwYWNlJyk7XG4gICAgfVxuICAgIG9wYWNpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvcGFjaXR5KSk7XG4gICAgdGhpcy5zdG9wcy5wdXNoKFtwb3MsIGNvbG9yLCBvcGFjaXR5XSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKG0xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5KSB7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbbTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHldO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVtYmVkKG0pIHtcbiAgICBsZXQgZm47XG4gICAgY29uc3Qgc3RvcHNMZW5ndGggPSB0aGlzLnN0b3BzLmxlbmd0aDtcbiAgICBpZiAoc3RvcHNMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWJlZGRlZCA9IHRydWU7XG4gICAgdGhpcy5tYXRyaXggPSBtO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLnN0b3BzW3N0b3BzTGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RbMF0gPCAxKSB7XG4gICAgICB0aGlzLnN0b3BzLnB1c2goWzEsIGxhc3RbMV0sIGxhc3RbMl1dKTtcbiAgICB9XG4gICAgY29uc3QgYm91bmRzID0gW107XG4gICAgY29uc3QgZW5jb2RlID0gW107XG4gICAgY29uc3Qgc3RvcHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BzTGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBlbmNvZGUucHVzaCgwLCAxKTtcbiAgICAgIGlmIChpICsgMiAhPT0gc3RvcHNMZW5ndGgpIHtcbiAgICAgICAgYm91bmRzLnB1c2godGhpcy5zdG9wc1tpICsgMV1bMF0pO1xuICAgICAgfVxuICAgICAgZm4gPSB0aGlzLmRvYy5yZWYoe1xuICAgICAgICBGdW5jdGlvblR5cGU6IDIsXG4gICAgICAgIERvbWFpbjogWzAsIDFdLFxuICAgICAgICBDMDogdGhpcy5zdG9wc1tpICsgMF1bMV0sXG4gICAgICAgIEMxOiB0aGlzLnN0b3BzW2kgKyAxXVsxXSxcbiAgICAgICAgTjogMVxuICAgICAgfSk7XG4gICAgICBzdG9wcy5wdXNoKGZuKTtcbiAgICAgIGZuLmVuZCgpO1xuICAgIH1cbiAgICBpZiAoc3RvcHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGZuID0gc3RvcHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuID0gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgRnVuY3Rpb25UeXBlOiAzLFxuICAgICAgICBEb21haW46IFswLCAxXSxcbiAgICAgICAgRnVuY3Rpb25zOiBzdG9wcyxcbiAgICAgICAgQm91bmRzOiBib3VuZHMsXG4gICAgICAgIEVuY29kZTogZW5jb2RlXG4gICAgICB9KTtcbiAgICAgIGZuLmVuZCgpO1xuICAgIH1cbiAgICB0aGlzLmlkID0gYFNoJHsrK3RoaXMuZG9jLl9ncmFkQ291bnR9YDtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcihmbik7XG4gICAgc2hhZGVyLmVuZCgpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLmRvYy5yZWYoe1xuICAgICAgVHlwZTogJ1BhdHRlcm4nLFxuICAgICAgUGF0dGVyblR5cGU6IDIsXG4gICAgICBTaGFkaW5nOiBzaGFkZXIsXG4gICAgICBNYXRyaXg6IHRoaXMubWF0cml4Lm1hcChudW1iZXIkMilcbiAgICB9KTtcbiAgICBwYXR0ZXJuLmVuZCgpO1xuICAgIGlmICh0aGlzLnN0b3BzLnNvbWUoc3RvcCA9PiBzdG9wWzJdIDwgMSkpIHtcbiAgICAgIGxldCBncmFkID0gdGhpcy5vcGFjaXR5R3JhZGllbnQoKTtcbiAgICAgIGdyYWQuX2NvbG9yU3BhY2UgPSAnRGV2aWNlR3JheSc7XG4gICAgICBmb3IgKGxldCBzdG9wIG9mIHRoaXMuc3RvcHMpIHtcbiAgICAgICAgZ3JhZC5zdG9wKHN0b3BbMF0sIFtzdG9wWzJdXSk7XG4gICAgICB9XG4gICAgICBncmFkID0gZ3JhZC5lbWJlZCh0aGlzLm1hdHJpeCk7XG4gICAgICBjb25zdCBwYWdlQkJveCA9IFswLCAwLCB0aGlzLmRvYy5wYWdlLndpZHRoLCB0aGlzLmRvYy5wYWdlLmhlaWdodF07XG4gICAgICBjb25zdCBmb3JtID0gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgVHlwZTogJ1hPYmplY3QnLFxuICAgICAgICBTdWJ0eXBlOiAnRm9ybScsXG4gICAgICAgIEZvcm1UeXBlOiAxLFxuICAgICAgICBCQm94OiBwYWdlQkJveCxcbiAgICAgICAgR3JvdXA6IHtcbiAgICAgICAgICBUeXBlOiAnR3JvdXAnLFxuICAgICAgICAgIFM6ICdUcmFuc3BhcmVuY3knLFxuICAgICAgICAgIENTOiAnRGV2aWNlR3JheSdcbiAgICAgICAgfSxcbiAgICAgICAgUmVzb3VyY2VzOiB7XG4gICAgICAgICAgUHJvY1NldDogWydQREYnLCAnVGV4dCcsICdJbWFnZUInLCAnSW1hZ2VDJywgJ0ltYWdlSSddLFxuICAgICAgICAgIFBhdHRlcm46IHtcbiAgICAgICAgICAgIFNoMTogZ3JhZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3JtLndyaXRlKCcvUGF0dGVybiBjcyAvU2gxIHNjbicpO1xuICAgICAgZm9ybS5lbmQoYCR7cGFnZUJCb3guam9pbignICcpfSByZSBmYCk7XG4gICAgICBjb25zdCBnc3RhdGUgPSB0aGlzLmRvYy5yZWYoe1xuICAgICAgICBUeXBlOiAnRXh0R1N0YXRlJyxcbiAgICAgICAgU01hc2s6IHtcbiAgICAgICAgICBUeXBlOiAnTWFzaycsXG4gICAgICAgICAgUzogJ0x1bWlub3NpdHknLFxuICAgICAgICAgIEc6IGZvcm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBnc3RhdGUuZW5kKCk7XG4gICAgICBjb25zdCBvcGFjaXR5UGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgIFR5cGU6ICdQYXR0ZXJuJyxcbiAgICAgICAgUGF0dGVyblR5cGU6IDEsXG4gICAgICAgIFBhaW50VHlwZTogMSxcbiAgICAgICAgVGlsaW5nVHlwZTogMixcbiAgICAgICAgQkJveDogcGFnZUJCb3gsXG4gICAgICAgIFhTdGVwOiBwYWdlQkJveFsyXSxcbiAgICAgICAgWVN0ZXA6IHBhZ2VCQm94WzNdLFxuICAgICAgICBSZXNvdXJjZXM6IHtcbiAgICAgICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ10sXG4gICAgICAgICAgUGF0dGVybjoge1xuICAgICAgICAgICAgU2gxOiBwYXR0ZXJuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBFeHRHU3RhdGU6IHtcbiAgICAgICAgICAgIEdzMTogZ3N0YXRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9wYWNpdHlQYXR0ZXJuLndyaXRlKCcvR3MxIGdzIC9QYXR0ZXJuIGNzIC9TaDEgc2NuJyk7XG4gICAgICBvcGFjaXR5UGF0dGVybi5lbmQoYCR7cGFnZUJCb3guam9pbignICcpfSByZSBmYCk7XG4gICAgICB0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdID0gb3BhY2l0eVBhdHRlcm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9jLnBhZ2UucGF0dGVybnNbdGhpcy5pZF0gPSBwYXR0ZXJuO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBhcHBseShzdHJva2UpIHtcbiAgICBjb25zdCBbbTAsIG0xLCBtMiwgbTMsIG00LCBtNV0gPSB0aGlzLmRvYy5fY3RtO1xuICAgIGNvbnN0IFttMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeV0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICBjb25zdCBtID0gW20wICogbTExICsgbTIgKiBtMTIsIG0xICogbTExICsgbTMgKiBtMTIsIG0wICogbTIxICsgbTIgKiBtMjIsIG0xICogbTIxICsgbTMgKiBtMjIsIG0wICogZHggKyBtMiAqIGR5ICsgbTQsIG0xICogZHggKyBtMyAqIGR5ICsgbTVdO1xuICAgIGlmICghdGhpcy5lbWJlZGRlZCB8fCBtLmpvaW4oJyAnKSAhPT0gdGhpcy5tYXRyaXguam9pbignICcpKSB7XG4gICAgICB0aGlzLmVtYmVkKG0pO1xuICAgIH1cbiAgICB0aGlzLmRvYy5fc2V0Q29sb3JTcGFjZSgnUGF0dGVybicsIHN0cm9rZSk7XG4gICAgY29uc3Qgb3AgPSBzdHJva2UgPyAnU0NOJyA6ICdzY24nO1xuICAgIHJldHVybiB0aGlzLmRvYy5hZGRDb250ZW50KGAvJHt0aGlzLmlkfSAke29wfWApO1xuICB9XG59XG5jbGFzcyBQREZMaW5lYXJHcmFkaWVudCQxIGV4dGVuZHMgUERGR3JhZGllbnQkMSB7XG4gIGNvbnN0cnVjdG9yKGRvYywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBzdXBlcihkb2MpO1xuICAgIHRoaXMueDEgPSB4MTtcbiAgICB0aGlzLnkxID0geTE7XG4gICAgdGhpcy54MiA9IHgyO1xuICAgIHRoaXMueTIgPSB5MjtcbiAgfVxuICBzaGFkZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5kb2MucmVmKHtcbiAgICAgIFNoYWRpbmdUeXBlOiAyLFxuICAgICAgQ29sb3JTcGFjZTogdGhpcy5fY29sb3JTcGFjZSxcbiAgICAgIENvb3JkczogW3RoaXMueDEsIHRoaXMueTEsIHRoaXMueDIsIHRoaXMueTJdLFxuICAgICAgRnVuY3Rpb246IGZuLFxuICAgICAgRXh0ZW5kOiBbdHJ1ZSwgdHJ1ZV1cbiAgICB9KTtcbiAgfVxuICBvcGFjaXR5R3JhZGllbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQREZMaW5lYXJHcmFkaWVudCQxKHRoaXMuZG9jLCB0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyLCB0aGlzLnkyKTtcbiAgfVxufVxuY2xhc3MgUERGUmFkaWFsR3JhZGllbnQkMSBleHRlbmRzIFBERkdyYWRpZW50JDEge1xuICBjb25zdHJ1Y3Rvcihkb2MsIHgxLCB5MSwgcjEsIHgyLCB5MiwgcjIpIHtcbiAgICBzdXBlcihkb2MpO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMueDEgPSB4MTtcbiAgICB0aGlzLnkxID0geTE7XG4gICAgdGhpcy5yMSA9IHIxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG4gICAgdGhpcy5yMiA9IHIyO1xuICB9XG4gIHNoYWRlcihmbikge1xuICAgIHJldHVybiB0aGlzLmRvYy5yZWYoe1xuICAgICAgU2hhZGluZ1R5cGU6IDMsXG4gICAgICBDb2xvclNwYWNlOiB0aGlzLl9jb2xvclNwYWNlLFxuICAgICAgQ29vcmRzOiBbdGhpcy54MSwgdGhpcy55MSwgdGhpcy5yMSwgdGhpcy54MiwgdGhpcy55MiwgdGhpcy5yMl0sXG4gICAgICBGdW5jdGlvbjogZm4sXG4gICAgICBFeHRlbmQ6IFt0cnVlLCB0cnVlXVxuICAgIH0pO1xuICB9XG4gIG9wYWNpdHlHcmFkaWVudCgpIHtcbiAgICByZXR1cm4gbmV3IFBERlJhZGlhbEdyYWRpZW50JDEodGhpcy5kb2MsIHRoaXMueDEsIHRoaXMueTEsIHRoaXMucjEsIHRoaXMueDIsIHRoaXMueTIsIHRoaXMucjIpO1xuICB9XG59XG52YXIgR3JhZGllbnQgPSB7XG4gIFBERkdyYWRpZW50OiBQREZHcmFkaWVudCQxLFxuICBQREZMaW5lYXJHcmFkaWVudDogUERGTGluZWFyR3JhZGllbnQkMSxcbiAgUERGUmFkaWFsR3JhZGllbnQ6IFBERlJhZGlhbEdyYWRpZW50JDFcbn07XG5cbmNvbnN0IHVuZGVybHlpbmdDb2xvclNwYWNlcyA9IFsnRGV2aWNlQ01ZSycsICdEZXZpY2VSR0InXTtcbmNsYXNzIFBERlRpbGluZ1BhdHRlcm4kMSB7XG4gIGNvbnN0cnVjdG9yKGRvYywgYkJveCwgeFN0ZXAsIHlTdGVwLCBzdHJlYW0pIHtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLmJCb3ggPSBiQm94O1xuICAgIHRoaXMueFN0ZXAgPSB4U3RlcDtcbiAgICB0aGlzLnlTdGVwID0geVN0ZXA7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gIH1cbiAgY3JlYXRlUGF0dGVybigpIHtcbiAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLmRvYy5yZWYoKTtcbiAgICByZXNvdXJjZXMuZW5kKCk7XG4gICAgY29uc3QgW20wLCBtMSwgbTIsIG0zLCBtNCwgbTVdID0gdGhpcy5kb2MuX2N0bTtcbiAgICBjb25zdCBbbTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHldID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIGNvbnN0IG0gPSBbbTAgKiBtMTEgKyBtMiAqIG0xMiwgbTEgKiBtMTEgKyBtMyAqIG0xMiwgbTAgKiBtMjEgKyBtMiAqIG0yMiwgbTEgKiBtMjEgKyBtMyAqIG0yMiwgbTAgKiBkeCArIG0yICogZHkgKyBtNCwgbTEgKiBkeCArIG0zICogZHkgKyBtNV07XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICBUeXBlOiAnUGF0dGVybicsXG4gICAgICBQYXR0ZXJuVHlwZTogMSxcbiAgICAgIFBhaW50VHlwZTogMixcbiAgICAgIFRpbGluZ1R5cGU6IDIsXG4gICAgICBCQm94OiB0aGlzLmJCb3gsXG4gICAgICBYU3RlcDogdGhpcy54U3RlcCxcbiAgICAgIFlTdGVwOiB0aGlzLnlTdGVwLFxuICAgICAgTWF0cml4OiBtLm1hcCh2ID0+ICt2LnRvRml4ZWQoNSkpLFxuICAgICAgUmVzb3VyY2VzOiByZXNvdXJjZXNcbiAgICB9KTtcbiAgICBwYXR0ZXJuLmVuZCh0aGlzLnN0cmVhbSk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgZW1iZWRQYXR0ZXJuQ29sb3JTcGFjZXMoKSB7XG4gICAgdW5kZXJseWluZ0NvbG9yU3BhY2VzLmZvckVhY2goY3NOYW1lID0+IHtcbiAgICAgIGNvbnN0IGNzSWQgPSB0aGlzLmdldFBhdHRlcm5Db2xvclNwYWNlSWQoY3NOYW1lKTtcbiAgICAgIGlmICh0aGlzLmRvYy5wYWdlLmNvbG9yU3BhY2VzW2NzSWRdKSByZXR1cm47XG4gICAgICBjb25zdCBjcyA9IHRoaXMuZG9jLnJlZihbJ1BhdHRlcm4nLCBjc05hbWVdKTtcbiAgICAgIGNzLmVuZCgpO1xuICAgICAgdGhpcy5kb2MucGFnZS5jb2xvclNwYWNlc1tjc0lkXSA9IGNzO1xuICAgIH0pO1xuICB9XG4gIGdldFBhdHRlcm5Db2xvclNwYWNlSWQodW5kZXJseWluZ0NvbG9yc3BhY2UpIHtcbiAgICByZXR1cm4gYENzUCR7dW5kZXJseWluZ0NvbG9yc3BhY2V9YDtcbiAgfVxuICBlbWJlZCgpIHtcbiAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgIHRoaXMuZG9jLl9wYXR0ZXJuQ291bnQgPSB0aGlzLmRvYy5fcGF0dGVybkNvdW50ICsgMTtcbiAgICAgIHRoaXMuaWQgPSAnUCcgKyB0aGlzLmRvYy5fcGF0dGVybkNvdW50O1xuICAgICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5jcmVhdGVQYXR0ZXJuKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kb2MucGFnZS5wYXR0ZXJuc1t0aGlzLmlkXSkge1xuICAgICAgdGhpcy5kb2MucGFnZS5wYXR0ZXJuc1t0aGlzLmlkXSA9IHRoaXMucGF0dGVybjtcbiAgICB9XG4gIH1cbiAgYXBwbHkoc3Ryb2tlLCBwYXR0ZXJuQ29sb3IpIHtcbiAgICB0aGlzLmVtYmVkUGF0dGVybkNvbG9yU3BhY2VzKCk7XG4gICAgdGhpcy5lbWJlZCgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IHRoaXMuZG9jLl9ub3JtYWxpemVDb2xvcihwYXR0ZXJuQ29sb3IpO1xuICAgIGlmICghbm9ybWFsaXplZENvbG9yKSB0aHJvdyBFcnJvcihgaW52YWxpZCBwYXR0ZXJuIGNvbG9yLiAodmFsdWU6ICR7cGF0dGVybkNvbG9yfSlgKTtcbiAgICBjb25zdCBjc0lkID0gdGhpcy5nZXRQYXR0ZXJuQ29sb3JTcGFjZUlkKHRoaXMuZG9jLl9nZXRDb2xvclNwYWNlKG5vcm1hbGl6ZWRDb2xvcikpO1xuICAgIHRoaXMuZG9jLl9zZXRDb2xvclNwYWNlKGNzSWQsIHN0cm9rZSk7XG4gICAgY29uc3Qgb3AgPSBzdHJva2UgPyAnU0NOJyA6ICdzY24nO1xuICAgIHJldHVybiB0aGlzLmRvYy5hZGRDb250ZW50KGAke25vcm1hbGl6ZWRDb2xvci5qb2luKCcgJyl9IC8ke3RoaXMuaWR9ICR7b3B9YCk7XG4gIH1cbn1cbnZhciBwYXR0ZXJuID0ge1xuICBQREZUaWxpbmdQYXR0ZXJuOiBQREZUaWxpbmdQYXR0ZXJuJDFcbn07XG5cbmNvbnN0IHtcbiAgUERGR3JhZGllbnQsXG4gIFBERkxpbmVhckdyYWRpZW50LFxuICBQREZSYWRpYWxHcmFkaWVudFxufSA9IEdyYWRpZW50O1xuY29uc3Qge1xuICBQREZUaWxpbmdQYXR0ZXJuXG59ID0gcGF0dGVybjtcbnZhciBDb2xvck1peGluID0ge1xuICBpbml0Q29sb3IoKSB7XG4gICAgdGhpcy5zcG90Q29sb3JzID0ge307XG4gICAgdGhpcy5fb3BhY2l0eVJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5fb3BhY2l0eUNvdW50ID0gMDtcbiAgICB0aGlzLl9wYXR0ZXJuQ291bnQgPSAwO1xuICAgIHRoaXMuX2dyYWRDb3VudCA9IDA7XG4gIH0sXG4gIF9ub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoY29sb3IuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSgvIyhbMC05QS1GXSkoWzAtOUEtRl0pKFswLTlBLUZdKS9pLCAnIyQxJDEkMiQyJDMkMycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleCA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgICAgIGNvbG9yID0gW2hleCA+PiAxNiwgaGV4ID4+IDggJiAweGZmLCBoZXggJiAweGZmXTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZWRDb2xvcnNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZWRDb2xvcnNbY29sb3JdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNwb3RDb2xvcnNbY29sb3JdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwb3RDb2xvcnNbY29sb3JdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgY29sb3IgPSBjb2xvci5tYXAocGFydCA9PiBwYXJ0IC8gMjU1KTtcbiAgICAgIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIGNvbG9yID0gY29sb3IubWFwKHBhcnQgPT4gcGFydCAvIDEwMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBfc2V0Q29sb3IoY29sb3IsIHN0cm9rZSkge1xuICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIFBERkdyYWRpZW50KSB7XG4gICAgICBjb2xvci5hcHBseShzdHJva2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSAmJiBjb2xvclswXSBpbnN0YW5jZW9mIFBERlRpbGluZ1BhdHRlcm4pIHtcbiAgICAgIGNvbG9yWzBdLmFwcGx5KHN0cm9rZSwgY29sb3JbMV0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXRDb2xvckNvcmUoY29sb3IsIHN0cm9rZSk7XG4gIH0sXG4gIF9zZXRDb2xvckNvcmUoY29sb3IsIHN0cm9rZSkge1xuICAgIGNvbG9yID0gdGhpcy5fbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3AgPSBzdHJva2UgPyAnU0NOJyA6ICdzY24nO1xuICAgIGNvbnN0IHNwYWNlID0gdGhpcy5fZ2V0Q29sb3JTcGFjZShjb2xvcik7XG4gICAgdGhpcy5fc2V0Q29sb3JTcGFjZShzcGFjZSwgc3Ryb2tlKTtcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBTcG90Q29sb3IpIHtcbiAgICAgIHRoaXMucGFnZS5jb2xvclNwYWNlc1tjb2xvci5pZF0gPSBjb2xvci5yZWY7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoYDEgJHtvcH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDb250ZW50KGAke2NvbG9yLmpvaW4oJyAnKX0gJHtvcH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIF9zZXRDb2xvclNwYWNlKHNwYWNlLCBzdHJva2UpIHtcbiAgICBjb25zdCBvcCA9IHN0cm9rZSA/ICdDUycgOiAnY3MnO1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYC8ke3NwYWNlfSAke29wfWApO1xuICB9LFxuICBfZ2V0Q29sb3JTcGFjZShjb2xvcikge1xuICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIFNwb3RDb2xvcikge1xuICAgICAgcmV0dXJuIGNvbG9yLmlkO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3IubGVuZ3RoID09PSA0ID8gJ0RldmljZUNNWUsnIDogJ0RldmljZVJHQic7XG4gIH0sXG4gIGZpbGxDb2xvcihjb2xvciwgb3BhY2l0eSkge1xuICAgIGNvbnN0IHNldCA9IHRoaXMuX3NldENvbG9yKGNvbG9yLCBmYWxzZSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgdGhpcy5maWxsT3BhY2l0eShvcGFjaXR5KTtcbiAgICB9XG4gICAgdGhpcy5fZmlsbENvbG9yID0gW2NvbG9yLCBvcGFjaXR5XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc3Ryb2tlQ29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgICBjb25zdCBzZXQgPSB0aGlzLl9zZXRDb2xvcihjb2xvciwgdHJ1ZSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgdGhpcy5zdHJva2VPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5fZG9PcGFjaXR5KG9wYWNpdHksIG9wYWNpdHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmaWxsT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5fZG9PcGFjaXR5KG9wYWNpdHksIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdHJva2VPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9kb09wYWNpdHkobnVsbCwgb3BhY2l0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb09wYWNpdHkoZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHkpIHtcbiAgICBsZXQgZGljdGlvbmFyeSwgbmFtZTtcbiAgICBpZiAoZmlsbE9wYWNpdHkgPT0gbnVsbCAmJiBzdHJva2VPcGFjaXR5ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgIGZpbGxPcGFjaXR5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZmlsbE9wYWNpdHkpKTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZU9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgc3Ryb2tlT3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHN0cm9rZU9wYWNpdHkpKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYCR7ZmlsbE9wYWNpdHl9XyR7c3Ryb2tlT3BhY2l0eX1gO1xuICAgIGlmICh0aGlzLl9vcGFjaXR5UmVnaXN0cnlba2V5XSkge1xuICAgICAgW2RpY3Rpb25hcnksIG5hbWVdID0gdGhpcy5fb3BhY2l0eVJlZ2lzdHJ5W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3Rpb25hcnkgPSB7XG4gICAgICAgIFR5cGU6ICdFeHRHU3RhdGUnXG4gICAgICB9O1xuICAgICAgaWYgKGZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgICAgZGljdGlvbmFyeS5jYSA9IGZpbGxPcGFjaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHN0cm9rZU9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICBkaWN0aW9uYXJ5LkNBID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGRpY3Rpb25hcnkgPSB0aGlzLnJlZihkaWN0aW9uYXJ5KTtcbiAgICAgIGRpY3Rpb25hcnkuZW5kKCk7XG4gICAgICBjb25zdCBpZCA9ICsrdGhpcy5fb3BhY2l0eUNvdW50O1xuICAgICAgbmFtZSA9IGBHcyR7aWR9YDtcbiAgICAgIHRoaXMuX29wYWNpdHlSZWdpc3RyeVtrZXldID0gW2RpY3Rpb25hcnksIG5hbWVdO1xuICAgIH1cbiAgICB0aGlzLnBhZ2UuZXh0X2dzdGF0ZXNbbmFtZV0gPSBkaWN0aW9uYXJ5O1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYC8ke25hbWV9IGdzYCk7XG4gIH0sXG4gIGxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIG5ldyBQREZMaW5lYXJHcmFkaWVudCh0aGlzLCB4MSwgeTEsIHgyLCB5Mik7XG4gIH0sXG4gIHJhZGlhbEdyYWRpZW50KHgxLCB5MSwgcjEsIHgyLCB5MiwgcjIpIHtcbiAgICByZXR1cm4gbmV3IFBERlJhZGlhbEdyYWRpZW50KHRoaXMsIHgxLCB5MSwgcjEsIHgyLCB5MiwgcjIpO1xuICB9LFxuICBwYXR0ZXJuKGJib3gsIHhTdGVwLCB5U3RlcCwgc3RyZWFtKSB7XG4gICAgcmV0dXJuIG5ldyBQREZUaWxpbmdQYXR0ZXJuKHRoaXMsIGJib3gsIHhTdGVwLCB5U3RlcCwgc3RyZWFtKTtcbiAgfSxcbiAgYWRkU3BvdENvbG9yKG5hbWUsIEMsIE0sIFksIEspIHtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBTcG90Q29sb3IodGhpcywgbmFtZSwgQywgTSwgWSwgSyk7XG4gICAgdGhpcy5zcG90Q29sb3JzW25hbWVdID0gY29sb3I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgbmFtZWRDb2xvcnMgPSB7XG4gIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICBmbG9yYWx3aGl0ZTogWzI1NSwgMjUwLCAyNDBdLFxuICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICByZWQ6IFsyNTUsIDAsIDBdLFxuICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG59O1xuXG5sZXQgY3gsIGN5LCBweCwgcHksIHN4LCBzeTtcbmN4ID0gY3kgPSBweCA9IHB5ID0gc3ggPSBzeSA9IDA7XG5jb25zdCBwYXJhbWV0ZXJzID0ge1xuICBBOiA3LFxuICBhOiA3LFxuICBDOiA2LFxuICBjOiA2LFxuICBIOiAxLFxuICBoOiAxLFxuICBMOiAyLFxuICBsOiAyLFxuICBNOiAyLFxuICBtOiAyLFxuICBROiA0LFxuICBxOiA0LFxuICBTOiA0LFxuICBzOiA0LFxuICBUOiAyLFxuICB0OiAyLFxuICBWOiAxLFxuICB2OiAxLFxuICBaOiAwLFxuICB6OiAwXG59O1xuY29uc3QgcGFyc2UgPSBmdW5jdGlvbiAocGF0aCkge1xuICBsZXQgY21kO1xuICBjb25zdCByZXQgPSBbXTtcbiAgbGV0IGFyZ3MgPSBbXTtcbiAgbGV0IGN1ckFyZyA9ICcnO1xuICBsZXQgZm91bmREZWNpbWFsID0gZmFsc2U7XG4gIGxldCBwYXJhbXMgPSAwO1xuICBmb3IgKGxldCBjIG9mIHBhdGgpIHtcbiAgICBpZiAocGFyYW1ldGVyc1tjXSAhPSBudWxsKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbWV0ZXJzW2NdO1xuICAgICAgaWYgKGNtZCkge1xuICAgICAgICBpZiAoY3VyQXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoXSA9ICtjdXJBcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0W3JldC5sZW5ndGhdID0ge1xuICAgICAgICAgIGNtZCxcbiAgICAgICAgICBhcmdzXG4gICAgICAgIH07XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgY3VyQXJnID0gJyc7XG4gICAgICAgIGZvdW5kRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY21kID0gYztcbiAgICB9IGVsc2UgaWYgKFsnICcsICcsJ10uaW5jbHVkZXMoYykgfHwgYyA9PT0gJy0nICYmIGN1ckFyZy5sZW5ndGggPiAwICYmIGN1ckFyZ1tjdXJBcmcubGVuZ3RoIC0gMV0gIT09ICdlJyB8fCBjID09PSAnLicgJiYgZm91bmREZWNpbWFsKSB7XG4gICAgICBpZiAoY3VyQXJnLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gcGFyYW1zKSB7XG4gICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICAgICAgICBjbWQsXG4gICAgICAgICAgYXJnc1xuICAgICAgICB9O1xuICAgICAgICBhcmdzID0gWytjdXJBcmddO1xuICAgICAgICBpZiAoY21kID09PSAnTScpIHtcbiAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtZCA9PT0gJ20nKSB7XG4gICAgICAgICAgY21kID0gJ2wnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoXSA9ICtjdXJBcmc7XG4gICAgICB9XG4gICAgICBmb3VuZERlY2ltYWwgPSBjID09PSAnLic7XG4gICAgICBjdXJBcmcgPSBbJy0nLCAnLiddLmluY2x1ZGVzKGMpID8gYyA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJBcmcgKz0gYztcbiAgICAgIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgZm91bmREZWNpbWFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGN1ckFyZy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSBwYXJhbXMpIHtcbiAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICAgICAgY21kLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgICAgYXJncyA9IFsrY3VyQXJnXTtcbiAgICAgIGlmIChjbWQgPT09ICdNJykge1xuICAgICAgICBjbWQgPSAnTCc7XG4gICAgICB9XG4gICAgICBpZiAoY21kID09PSAnbScpIHtcbiAgICAgICAgY21kID0gJ2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoXSA9ICtjdXJBcmc7XG4gICAgfVxuICB9XG4gIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICBjbWQsXG4gICAgYXJnc1xuICB9O1xuICByZXR1cm4gcmV0O1xufTtcbmNvbnN0IGFwcGx5ID0gZnVuY3Rpb24gKGNvbW1hbmRzLCBkb2MpIHtcbiAgY3ggPSBjeSA9IHB4ID0gcHkgPSBzeCA9IHN5ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGMgPSBjb21tYW5kc1tpXTtcbiAgICBpZiAodHlwZW9mIHJ1bm5lcnNbYy5jbWRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBydW5uZXJzW2MuY21kXShkb2MsIGMuYXJncyk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgcnVubmVycyA9IHtcbiAgTShkb2MsIGEpIHtcbiAgICBjeCA9IGFbMF07XG4gICAgY3kgPSBhWzFdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHN4ID0gY3g7XG4gICAgc3kgPSBjeTtcbiAgICByZXR1cm4gZG9jLm1vdmVUbyhjeCwgY3kpO1xuICB9LFxuICBtKGRvYywgYSkge1xuICAgIGN4ICs9IGFbMF07XG4gICAgY3kgKz0gYVsxXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICBzeCA9IGN4O1xuICAgIHN5ID0gY3k7XG4gICAgcmV0dXJuIGRvYy5tb3ZlVG8oY3gsIGN5KTtcbiAgfSxcbiAgQyhkb2MsIGEpIHtcbiAgICBjeCA9IGFbNF07XG4gICAgY3kgPSBhWzVdO1xuICAgIHB4ID0gYVsyXTtcbiAgICBweSA9IGFbM107XG4gICAgcmV0dXJuIGRvYy5iZXppZXJDdXJ2ZVRvKC4uLmEpO1xuICB9LFxuICBjKGRvYywgYSkge1xuICAgIGRvYy5iZXppZXJDdXJ2ZVRvKGFbMF0gKyBjeCwgYVsxXSArIGN5LCBhWzJdICsgY3gsIGFbM10gKyBjeSwgYVs0XSArIGN4LCBhWzVdICsgY3kpO1xuICAgIHB4ID0gY3ggKyBhWzJdO1xuICAgIHB5ID0gY3kgKyBhWzNdO1xuICAgIGN4ICs9IGFbNF07XG4gICAgcmV0dXJuIGN5ICs9IGFbNV07XG4gIH0sXG4gIFMoZG9jLCBhKSB7XG4gICAgaWYgKHB4ID09PSBudWxsKSB7XG4gICAgICBweCA9IGN4O1xuICAgICAgcHkgPSBjeTtcbiAgICB9XG4gICAgZG9jLmJlemllckN1cnZlVG8oY3ggLSAocHggLSBjeCksIGN5IC0gKHB5IC0gY3kpLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICBweCA9IGFbMF07XG4gICAgcHkgPSBhWzFdO1xuICAgIGN4ID0gYVsyXTtcbiAgICByZXR1cm4gY3kgPSBhWzNdO1xuICB9LFxuICBzKGRvYywgYSkge1xuICAgIGlmIChweCA9PT0gbnVsbCkge1xuICAgICAgcHggPSBjeDtcbiAgICAgIHB5ID0gY3k7XG4gICAgfVxuICAgIGRvYy5iZXppZXJDdXJ2ZVRvKGN4IC0gKHB4IC0gY3gpLCBjeSAtIChweSAtIGN5KSwgY3ggKyBhWzBdLCBjeSArIGFbMV0sIGN4ICsgYVsyXSwgY3kgKyBhWzNdKTtcbiAgICBweCA9IGN4ICsgYVswXTtcbiAgICBweSA9IGN5ICsgYVsxXTtcbiAgICBjeCArPSBhWzJdO1xuICAgIHJldHVybiBjeSArPSBhWzNdO1xuICB9LFxuICBRKGRvYywgYSkge1xuICAgIHB4ID0gYVswXTtcbiAgICBweSA9IGFbMV07XG4gICAgY3ggPSBhWzJdO1xuICAgIGN5ID0gYVszXTtcbiAgICByZXR1cm4gZG9jLnF1YWRyYXRpY0N1cnZlVG8oYVswXSwgYVsxXSwgY3gsIGN5KTtcbiAgfSxcbiAgcShkb2MsIGEpIHtcbiAgICBkb2MucXVhZHJhdGljQ3VydmVUbyhhWzBdICsgY3gsIGFbMV0gKyBjeSwgYVsyXSArIGN4LCBhWzNdICsgY3kpO1xuICAgIHB4ID0gY3ggKyBhWzBdO1xuICAgIHB5ID0gY3kgKyBhWzFdO1xuICAgIGN4ICs9IGFbMl07XG4gICAgcmV0dXJuIGN5ICs9IGFbM107XG4gIH0sXG4gIFQoZG9jLCBhKSB7XG4gICAgaWYgKHB4ID09PSBudWxsKSB7XG4gICAgICBweCA9IGN4O1xuICAgICAgcHkgPSBjeTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHggPSBjeCAtIChweCAtIGN4KTtcbiAgICAgIHB5ID0gY3kgLSAocHkgLSBjeSk7XG4gICAgfVxuICAgIGRvYy5xdWFkcmF0aWNDdXJ2ZVRvKHB4LCBweSwgYVswXSwgYVsxXSk7XG4gICAgcHggPSBjeCAtIChweCAtIGN4KTtcbiAgICBweSA9IGN5IC0gKHB5IC0gY3kpO1xuICAgIGN4ID0gYVswXTtcbiAgICByZXR1cm4gY3kgPSBhWzFdO1xuICB9LFxuICB0KGRvYywgYSkge1xuICAgIGlmIChweCA9PT0gbnVsbCkge1xuICAgICAgcHggPSBjeDtcbiAgICAgIHB5ID0gY3k7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB4ID0gY3ggLSAocHggLSBjeCk7XG4gICAgICBweSA9IGN5IC0gKHB5IC0gY3kpO1xuICAgIH1cbiAgICBkb2MucXVhZHJhdGljQ3VydmVUbyhweCwgcHksIGN4ICsgYVswXSwgY3kgKyBhWzFdKTtcbiAgICBjeCArPSBhWzBdO1xuICAgIHJldHVybiBjeSArPSBhWzFdO1xuICB9LFxuICBBKGRvYywgYSkge1xuICAgIHNvbHZlQXJjKGRvYywgY3gsIGN5LCBhKTtcbiAgICBjeCA9IGFbNV07XG4gICAgcmV0dXJuIGN5ID0gYVs2XTtcbiAgfSxcbiAgYShkb2MsIGEpIHtcbiAgICBhWzVdICs9IGN4O1xuICAgIGFbNl0gKz0gY3k7XG4gICAgc29sdmVBcmMoZG9jLCBjeCwgY3ksIGEpO1xuICAgIGN4ID0gYVs1XTtcbiAgICByZXR1cm4gY3kgPSBhWzZdO1xuICB9LFxuICBMKGRvYywgYSkge1xuICAgIGN4ID0gYVswXTtcbiAgICBjeSA9IGFbMV07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgbChkb2MsIGEpIHtcbiAgICBjeCArPSBhWzBdO1xuICAgIGN5ICs9IGFbMV07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgSChkb2MsIGEpIHtcbiAgICBjeCA9IGFbMF07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgaChkb2MsIGEpIHtcbiAgICBjeCArPSBhWzBdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIFYoZG9jLCBhKSB7XG4gICAgY3kgPSBhWzBdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIHYoZG9jLCBhKSB7XG4gICAgY3kgKz0gYVswXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICByZXR1cm4gZG9jLmxpbmVUbyhjeCwgY3kpO1xuICB9LFxuICBaKGRvYykge1xuICAgIGRvYy5jbG9zZVBhdGgoKTtcbiAgICBjeCA9IHN4O1xuICAgIHJldHVybiBjeSA9IHN5O1xuICB9LFxuICB6KGRvYykge1xuICAgIGRvYy5jbG9zZVBhdGgoKTtcbiAgICBjeCA9IHN4O1xuICAgIHJldHVybiBjeSA9IHN5O1xuICB9XG59O1xuY29uc3Qgc29sdmVBcmMgPSBmdW5jdGlvbiAoZG9jLCB4LCB5LCBjb29yZHMpIHtcbiAgY29uc3QgW3J4LCByeSwgcm90LCBsYXJnZSwgc3dlZXAsIGV4LCBleV0gPSBjb29yZHM7XG4gIGNvbnN0IHNlZ3MgPSBhcmNUb1NlZ21lbnRzKGV4LCBleSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCwgeCwgeSk7XG4gIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgY29uc3QgYmV6ID0gc2VnbWVudFRvQmV6aWVyKC4uLnNlZyk7XG4gICAgZG9jLmJlemllckN1cnZlVG8oLi4uYmV6KTtcbiAgfVxufTtcbmNvbnN0IGFyY1RvU2VnbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgsIG94LCBveSkge1xuICBjb25zdCB0aCA9IHJvdGF0ZVggKiAoTWF0aC5QSSAvIDE4MCk7XG4gIGNvbnN0IHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgY29uc3QgY29zX3RoID0gTWF0aC5jb3ModGgpO1xuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIHB4ID0gY29zX3RoICogKG94IC0geCkgKiAwLjUgKyBzaW5fdGggKiAob3kgLSB5KSAqIDAuNTtcbiAgcHkgPSBjb3NfdGggKiAob3kgLSB5KSAqIDAuNSAtIHNpbl90aCAqIChveCAtIHgpICogMC41O1xuICBsZXQgcGwgPSBweCAqIHB4IC8gKHJ4ICogcngpICsgcHkgKiBweSAvIChyeSAqIHJ5KTtcbiAgaWYgKHBsID4gMSkge1xuICAgIHBsID0gTWF0aC5zcXJ0KHBsKTtcbiAgICByeCAqPSBwbDtcbiAgICByeSAqPSBwbDtcbiAgfVxuICBjb25zdCBhMDAgPSBjb3NfdGggLyByeDtcbiAgY29uc3QgYTAxID0gc2luX3RoIC8gcng7XG4gIGNvbnN0IGExMCA9IC1zaW5fdGggLyByeTtcbiAgY29uc3QgYTExID0gY29zX3RoIC8gcnk7XG4gIGNvbnN0IHgwID0gYTAwICogb3ggKyBhMDEgKiBveTtcbiAgY29uc3QgeTAgPSBhMTAgKiBveCArIGExMSAqIG95O1xuICBjb25zdCB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICBjb25zdCB5MSA9IGExMCAqIHggKyBhMTEgKiB5O1xuICBjb25zdCBkID0gKHgxIC0geDApICogKHgxIC0geDApICsgKHkxIC0geTApICogKHkxIC0geTApO1xuICBsZXQgc2ZhY3Rvcl9zcSA9IDEgLyBkIC0gMC4yNTtcbiAgaWYgKHNmYWN0b3Jfc3EgPCAwKSB7XG4gICAgc2ZhY3Rvcl9zcSA9IDA7XG4gIH1cbiAgbGV0IHNmYWN0b3IgPSBNYXRoLnNxcnQoc2ZhY3Rvcl9zcSk7XG4gIGlmIChzd2VlcCA9PT0gbGFyZ2UpIHtcbiAgICBzZmFjdG9yID0gLXNmYWN0b3I7XG4gIH1cbiAgY29uc3QgeGMgPSAwLjUgKiAoeDAgKyB4MSkgLSBzZmFjdG9yICogKHkxIC0geTApO1xuICBjb25zdCB5YyA9IDAuNSAqICh5MCArIHkxKSArIHNmYWN0b3IgKiAoeDEgLSB4MCk7XG4gIGNvbnN0IHRoMCA9IE1hdGguYXRhbjIoeTAgLSB5YywgeDAgLSB4Yyk7XG4gIGNvbnN0IHRoMSA9IE1hdGguYXRhbjIoeTEgLSB5YywgeDEgLSB4Yyk7XG4gIGxldCB0aF9hcmMgPSB0aDEgLSB0aDA7XG4gIGlmICh0aF9hcmMgPCAwICYmIHN3ZWVwID09PSAxKSB7XG4gICAgdGhfYXJjICs9IDIgKiBNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHRoX2FyYyA+IDAgJiYgc3dlZXAgPT09IDApIHtcbiAgICB0aF9hcmMgLT0gMiAqIE1hdGguUEk7XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnModGhfYXJjIC8gKE1hdGguUEkgKiAwLjUgKyAwLjAwMSkpKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgIGNvbnN0IHRoMiA9IHRoMCArIGkgKiB0aF9hcmMgLyBzZWdtZW50cztcbiAgICBjb25zdCB0aDMgPSB0aDAgKyAoaSArIDEpICogdGhfYXJjIC8gc2VnbWVudHM7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3Qgc2VnbWVudFRvQmV6aWVyID0gZnVuY3Rpb24gKGN4LCBjeSwgdGgwLCB0aDEsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGgpIHtcbiAgY29uc3QgYTAwID0gY29zX3RoICogcng7XG4gIGNvbnN0IGEwMSA9IC1zaW5fdGggKiByeTtcbiAgY29uc3QgYTEwID0gc2luX3RoICogcng7XG4gIGNvbnN0IGExMSA9IGNvc190aCAqIHJ5O1xuICBjb25zdCB0aF9oYWxmID0gMC41ICogKHRoMSAtIHRoMCk7XG4gIGNvbnN0IHQgPSA4IC8gMyAqIE1hdGguc2luKHRoX2hhbGYgKiAwLjUpICogTWF0aC5zaW4odGhfaGFsZiAqIDAuNSkgLyBNYXRoLnNpbih0aF9oYWxmKTtcbiAgY29uc3QgeDEgPSBjeCArIE1hdGguY29zKHRoMCkgLSB0ICogTWF0aC5zaW4odGgwKTtcbiAgY29uc3QgeTEgPSBjeSArIE1hdGguc2luKHRoMCkgKyB0ICogTWF0aC5jb3ModGgwKTtcbiAgY29uc3QgeDMgPSBjeCArIE1hdGguY29zKHRoMSk7XG4gIGNvbnN0IHkzID0gY3kgKyBNYXRoLnNpbih0aDEpO1xuICBjb25zdCB4MiA9IHgzICsgdCAqIE1hdGguc2luKHRoMSk7XG4gIGNvbnN0IHkyID0geTMgLSB0ICogTWF0aC5jb3ModGgxKTtcbiAgcmV0dXJuIFthMDAgKiB4MSArIGEwMSAqIHkxLCBhMTAgKiB4MSArIGExMSAqIHkxLCBhMDAgKiB4MiArIGEwMSAqIHkyLCBhMTAgKiB4MiArIGExMSAqIHkyLCBhMDAgKiB4MyArIGEwMSAqIHkzLCBhMTAgKiB4MyArIGExMSAqIHkzXTtcbn07XG5jbGFzcyBTVkdQYXRoIHtcbiAgc3RhdGljIGFwcGx5KGRvYywgcGF0aCkge1xuICAgIGNvbnN0IGNvbW1hbmRzID0gcGFyc2UocGF0aCk7XG4gICAgYXBwbHkoY29tbWFuZHMsIGRvYyk7XG4gIH1cbn1cblxuY29uc3Qge1xuICBudW1iZXI6IG51bWJlciQxXG59ID0gUERGT2JqZWN0O1xuY29uc3QgS0FQUEEgPSA0LjAgKiAoKE1hdGguc3FydCgyKSAtIDEuMCkgLyAzLjApO1xudmFyIFZlY3Rvck1peGluID0ge1xuICBpbml0VmVjdG9yKCkge1xuICAgIHRoaXMuX2N0bSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB0aGlzLl9jdG1TdGFjayA9IFtdO1xuICB9LFxuICBzYXZlKCkge1xuICAgIHRoaXMuX2N0bVN0YWNrLnB1c2godGhpcy5fY3RtLnNsaWNlKCkpO1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoJ3EnKTtcbiAgfSxcbiAgcmVzdG9yZSgpIHtcbiAgICB0aGlzLl9jdG0gPSB0aGlzLl9jdG1TdGFjay5wb3AoKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnUScpO1xuICB9LFxuICBjbG9zZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnaCcpO1xuICB9LFxuICBsaW5lV2lkdGgodykge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7bnVtYmVyJDEodyl9IHdgKTtcbiAgfSxcbiAgX0NBUF9TVFlMRVM6IHtcbiAgICBCVVRUOiAwLFxuICAgIFJPVU5EOiAxLFxuICAgIFNRVUFSRTogMlxuICB9LFxuICBsaW5lQ2FwKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjID0gdGhpcy5fQ0FQX1NUWUxFU1tjLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke2N9IEpgKTtcbiAgfSxcbiAgX0pPSU5fU1RZTEVTOiB7XG4gICAgTUlURVI6IDAsXG4gICAgUk9VTkQ6IDEsXG4gICAgQkVWRUw6IDJcbiAgfSxcbiAgbGluZUpvaW4oaikge1xuICAgIGlmICh0eXBlb2YgaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGogPSB0aGlzLl9KT0lOX1NUWUxFU1tqLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke2p9IGpgKTtcbiAgfSxcbiAgbWl0ZXJMaW1pdChtKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgJHtudW1iZXIkMShtKX0gTWApO1xuICB9LFxuICBkYXNoKGxlbmd0aCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IGxlbmd0aDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gW2xlbmd0aCwgb3B0aW9ucy5zcGFjZSB8fCBsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IGxlbmd0aC5ldmVyeSh4ID0+IE51bWJlci5pc0Zpbml0ZSh4KSAmJiB4ID4gMCk7XG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBkYXNoKCR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxMZW5ndGgpfSwgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX0pIGludmFsaWQsIGxlbmd0aHMgbXVzdCBiZSBudW1lcmljIGFuZCBncmVhdGVyIHRoYW4gemVyb2ApO1xuICAgIH1cbiAgICBsZW5ndGggPSBsZW5ndGgubWFwKG51bWJlciQxKS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgWyR7bGVuZ3RofV0gJHtudW1iZXIkMShvcHRpb25zLnBoYXNlIHx8IDApfSBkYCk7XG4gIH0sXG4gIHVuZGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KCdbXSAwIGQnKTtcbiAgfSxcbiAgbW92ZVRvKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSBtYCk7XG4gIH0sXG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgJHtudW1iZXIkMSh4KX0gJHtudW1iZXIkMSh5KX0gbGApO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKGNwMXgpfSAke251bWJlciQxKGNwMXkpfSAke251bWJlciQxKGNwMngpfSAke251bWJlciQxKGNwMnkpfSAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSBjYCk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKGNweCl9ICR7bnVtYmVyJDEoY3B5KX0gJHtudW1iZXIkMSh4KX0gJHtudW1iZXIkMSh5KX0gdmApO1xuICB9LFxuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSAke251bWJlciQxKHcpfSAke251bWJlciQxKGgpfSByZWApO1xuICB9LFxuICByb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKSB7XG4gICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgciA9IDA7XG4gICAgfVxuICAgIHIgPSBNYXRoLm1pbihyLCAwLjUgKiB3LCAwLjUgKiBoKTtcbiAgICBjb25zdCBjID0gciAqICgxLjAgLSBLQVBQQSk7XG4gICAgdGhpcy5tb3ZlVG8oeCArIHIsIHkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHggKyB3IC0gYywgeSwgeCArIHcsIHkgKyBjLCB4ICsgdywgeSArIHIpO1xuICAgIHRoaXMubGluZVRvKHggKyB3LCB5ICsgaCAtIHIpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ICsgdywgeSArIGggLSBjLCB4ICsgdyAtIGMsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgciwgeSArIGgpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ICsgYywgeSArIGgsIHgsIHkgKyBoIC0gYywgeCwgeSArIGggLSByKTtcbiAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHgsIHkgKyBjLCB4ICsgYywgeSwgeCArIHIsIHkpO1xuICAgIHJldHVybiB0aGlzLmNsb3NlUGF0aCgpO1xuICB9LFxuICBlbGxpcHNlKHgsIHksIHIxLCByMikge1xuICAgIGlmIChyMiA9PSBudWxsKSB7XG4gICAgICByMiA9IHIxO1xuICAgIH1cbiAgICB4IC09IHIxO1xuICAgIHkgLT0gcjI7XG4gICAgY29uc3Qgb3ggPSByMSAqIEtBUFBBO1xuICAgIGNvbnN0IG95ID0gcjIgKiBLQVBQQTtcbiAgICBjb25zdCB4ZSA9IHggKyByMSAqIDI7XG4gICAgY29uc3QgeWUgPSB5ICsgcjIgKiAyO1xuICAgIGNvbnN0IHhtID0geCArIHIxO1xuICAgIGNvbnN0IHltID0geSArIHIyO1xuICAgIHRoaXMubW92ZVRvKHgsIHltKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICAgIHJldHVybiB0aGlzLmNsb3NlUGF0aCgpO1xuICB9LFxuICBjaXJjbGUoeCwgeSwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxsaXBzZSh4LCB5LCByYWRpdXMpO1xuICB9LFxuICBhcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIGlmIChhbnRpY2xvY2t3aXNlID09IG51bGwpIHtcbiAgICAgIGFudGljbG9ja3dpc2UgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgVFdPX1BJID0gMi4wICogTWF0aC5QSTtcbiAgICBjb25zdCBIQUxGX1BJID0gMC41ICogTWF0aC5QSTtcbiAgICBsZXQgZGVsdGFBbmcgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgaWYgKE1hdGguYWJzKGRlbHRhQW5nKSA+IFRXT19QSSkge1xuICAgICAgZGVsdGFBbmcgPSBUV09fUEk7XG4gICAgfSBlbHNlIGlmIChkZWx0YUFuZyAhPT0gMCAmJiBhbnRpY2xvY2t3aXNlICE9PSBkZWx0YUFuZyA8IDApIHtcbiAgICAgIGNvbnN0IGRpciA9IGFudGljbG9ja3dpc2UgPyAtMSA6IDE7XG4gICAgICBkZWx0YUFuZyA9IGRpciAqIFRXT19QSSArIGRlbHRhQW5nO1xuICAgIH1cbiAgICBjb25zdCBudW1TZWdzID0gTWF0aC5jZWlsKE1hdGguYWJzKGRlbHRhQW5nKSAvIEhBTEZfUEkpO1xuICAgIGNvbnN0IHNlZ0FuZyA9IGRlbHRhQW5nIC8gbnVtU2VncztcbiAgICBjb25zdCBoYW5kbGVMZW4gPSBzZWdBbmcgLyBIQUxGX1BJICogS0FQUEEgKiByYWRpdXM7XG4gICAgbGV0IGN1ckFuZyA9IHN0YXJ0QW5nbGU7XG4gICAgbGV0IGRlbHRhQ3ggPSAtTWF0aC5zaW4oY3VyQW5nKSAqIGhhbmRsZUxlbjtcbiAgICBsZXQgZGVsdGFDeSA9IE1hdGguY29zKGN1ckFuZykgKiBoYW5kbGVMZW47XG4gICAgbGV0IGF4ID0geCArIE1hdGguY29zKGN1ckFuZykgKiByYWRpdXM7XG4gICAgbGV0IGF5ID0geSArIE1hdGguc2luKGN1ckFuZykgKiByYWRpdXM7XG4gICAgdGhpcy5tb3ZlVG8oYXgsIGF5KTtcbiAgICBmb3IgKGxldCBzZWdJZHggPSAwOyBzZWdJZHggPCBudW1TZWdzOyBzZWdJZHgrKykge1xuICAgICAgY29uc3QgY3AxeCA9IGF4ICsgZGVsdGFDeDtcbiAgICAgIGNvbnN0IGNwMXkgPSBheSArIGRlbHRhQ3k7XG4gICAgICBjdXJBbmcgKz0gc2VnQW5nO1xuICAgICAgYXggPSB4ICsgTWF0aC5jb3MoY3VyQW5nKSAqIHJhZGl1cztcbiAgICAgIGF5ID0geSArIE1hdGguc2luKGN1ckFuZykgKiByYWRpdXM7XG4gICAgICBkZWx0YUN4ID0gLU1hdGguc2luKGN1ckFuZykgKiBoYW5kbGVMZW47XG4gICAgICBkZWx0YUN5ID0gTWF0aC5jb3MoY3VyQW5nKSAqIGhhbmRsZUxlbjtcbiAgICAgIGNvbnN0IGNwMnggPSBheCAtIGRlbHRhQ3g7XG4gICAgICBjb25zdCBjcDJ5ID0gYXkgLSBkZWx0YUN5O1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGF4LCBheSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwb2x5Z29uKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwb2ludHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwb2ludHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHRoaXMubW92ZVRvKC4uLihwb2ludHMuc2hpZnQoKSB8fCBbXSkpO1xuICAgIGZvciAobGV0IHBvaW50IG9mIHBvaW50cykge1xuICAgICAgdGhpcy5saW5lVG8oLi4uKHBvaW50IHx8IFtdKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlUGF0aCgpO1xuICB9LFxuICBwYXRoKHBhdGgpIHtcbiAgICBTVkdQYXRoLmFwcGx5KHRoaXMsIHBhdGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfd2luZGluZ1J1bGUocnVsZSkge1xuICAgIGlmICgvZXZlbi0/b2RkLy50ZXN0KHJ1bGUpKSB7XG4gICAgICByZXR1cm4gJyonO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIGZpbGwoY29sb3IsIHJ1bGUpIHtcbiAgICBpZiAoLyhldmVuLT9vZGQpfChub24tP3plcm8pLy50ZXN0KGNvbG9yKSkge1xuICAgICAgcnVsZSA9IGNvbG9yO1xuICAgICAgY29sb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuZmlsbENvbG9yKGNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgZiR7dGhpcy5fd2luZGluZ1J1bGUocnVsZSl9YCk7XG4gIH0sXG4gIHN0cm9rZShjb2xvcikge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5zdHJva2VDb2xvcihjb2xvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoJ1MnKTtcbiAgfSxcbiAgZmlsbEFuZFN0cm9rZShmaWxsQ29sb3IsIHN0cm9rZUNvbG9yLCBydWxlKSB7XG4gICAgaWYgKHN0cm9rZUNvbG9yID09IG51bGwpIHtcbiAgICAgIHN0cm9rZUNvbG9yID0gZmlsbENvbG9yO1xuICAgIH1cbiAgICBjb25zdCBpc0ZpbGxSdWxlID0gLyhldmVuLT9vZGQpfChub24tP3plcm8pLztcbiAgICBpZiAoaXNGaWxsUnVsZS50ZXN0KGZpbGxDb2xvcikpIHtcbiAgICAgIHJ1bGUgPSBmaWxsQ29sb3I7XG4gICAgICBmaWxsQ29sb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNGaWxsUnVsZS50ZXN0KHN0cm9rZUNvbG9yKSkge1xuICAgICAgcnVsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgc3Ryb2tlQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgfVxuICAgIGlmIChmaWxsQ29sb3IpIHtcbiAgICAgIHRoaXMuZmlsbENvbG9yKGZpbGxDb2xvcik7XG4gICAgICB0aGlzLnN0cm9rZUNvbG9yKHN0cm9rZUNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgQiR7dGhpcy5fd2luZGluZ1J1bGUocnVsZSl9YCk7XG4gIH0sXG4gIGNsaXAocnVsZSkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYFcke3RoaXMuX3dpbmRpbmdSdWxlKHJ1bGUpfSBuYCk7XG4gIH0sXG4gIHRyYW5zZm9ybShtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSkge1xuICAgIGlmIChtMTEgPT09IDEgJiYgbTEyID09PSAwICYmIG0yMSA9PT0gMCAmJiBtMjIgPT09IDEgJiYgZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBtID0gdGhpcy5fY3RtO1xuICAgIGNvbnN0IFttMCwgbTEsIG0yLCBtMywgbTQsIG01XSA9IG07XG4gICAgbVswXSA9IG0wICogbTExICsgbTIgKiBtMTI7XG4gICAgbVsxXSA9IG0xICogbTExICsgbTMgKiBtMTI7XG4gICAgbVsyXSA9IG0wICogbTIxICsgbTIgKiBtMjI7XG4gICAgbVszXSA9IG0xICogbTIxICsgbTMgKiBtMjI7XG4gICAgbVs0XSA9IG0wICogZHggKyBtMiAqIGR5ICsgbTQ7XG4gICAgbVs1XSA9IG0xICogZHggKyBtMyAqIGR5ICsgbTU7XG4gICAgY29uc3QgdmFsdWVzID0gW20xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5XS5tYXAodiA9PiBudW1iZXIkMSh2KSkuam9pbignICcpO1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7dmFsdWVzfSBjbWApO1xuICB9LFxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAxLCB4LCB5KTtcbiAgfSxcbiAgcm90YXRlKGFuZ2xlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCB5O1xuICAgIGNvbnN0IHJhZCA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyYWQpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHJhZCk7XG4gICAgbGV0IHggPSB5ID0gMDtcbiAgICBpZiAob3B0aW9ucy5vcmlnaW4gIT0gbnVsbCkge1xuICAgICAgW3gsIHldID0gb3B0aW9ucy5vcmlnaW47XG4gICAgICBjb25zdCB4MSA9IHggKiBjb3MgLSB5ICogc2luO1xuICAgICAgY29uc3QgeTEgPSB4ICogc2luICsgeSAqIGNvcztcbiAgICAgIHggLT0geDE7XG4gICAgICB5IC09IHkxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oY29zLCBzaW4sIC1zaW4sIGNvcywgeCwgeSk7XG4gIH0sXG4gIHNjYWxlKHhGYWN0b3IsIHlGYWN0b3IpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IHk7XG4gICAgaWYgKHlGYWN0b3IgPT0gbnVsbCkge1xuICAgICAgeUZhY3RvciA9IHhGYWN0b3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeUZhY3RvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSB5RmFjdG9yO1xuICAgICAgeUZhY3RvciA9IHhGYWN0b3I7XG4gICAgfVxuICAgIGxldCB4ID0geSA9IDA7XG4gICAgaWYgKG9wdGlvbnMub3JpZ2luICE9IG51bGwpIHtcbiAgICAgIFt4LCB5XSA9IG9wdGlvbnMub3JpZ2luO1xuICAgICAgeCAtPSB4RmFjdG9yICogeDtcbiAgICAgIHkgLT0geUZhY3RvciAqIHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh4RmFjdG9yLCAwLCAwLCB5RmFjdG9yLCB4LCB5KTtcbiAgfVxufTtcblxuY29uc3QgV0lOX0FOU0lfTUFQID0ge1xuICA0MDI6IDEzMSxcbiAgODIxMTogMTUwLFxuICA4MjEyOiAxNTEsXG4gIDgyMTY6IDE0NSxcbiAgODIxNzogMTQ2LFxuICA4MjE4OiAxMzAsXG4gIDgyMjA6IDE0NyxcbiAgODIyMTogMTQ4LFxuICA4MjIyOiAxMzIsXG4gIDgyMjQ6IDEzNCxcbiAgODIyNTogMTM1LFxuICA4MjI2OiAxNDksXG4gIDgyMzA6IDEzMyxcbiAgODM2NDogMTI4LFxuICA4MjQwOiAxMzcsXG4gIDgyNDk6IDEzOSxcbiAgODI1MDogMTU1LFxuICA3MTA6IDEzNixcbiAgODQ4MjogMTUzLFxuICAzMzg6IDE0MCxcbiAgMzM5OiAxNTYsXG4gIDczMjogMTUyLFxuICAzNTI6IDEzOCxcbiAgMzUzOiAxNTQsXG4gIDM3NjogMTU5LFxuICAzODE6IDE0MixcbiAgMzgyOiAxNThcbn07XG5jb25zdCBjaGFyYWN0ZXJzID0gYFxcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuICBcbnNwYWNlICAgICAgICAgZXhjbGFtICAgICAgICAgcXVvdGVkYmwgICAgICAgbnVtYmVyc2lnblxuZG9sbGFyICAgICAgICBwZXJjZW50ICAgICAgICBhbXBlcnNhbmQgICAgICBxdW90ZXNpbmdsZVxucGFyZW5sZWZ0ICAgICBwYXJlbnJpZ2h0ICAgICBhc3RlcmlzayAgICAgICBwbHVzXG5jb21tYSAgICAgICAgIGh5cGhlbiAgICAgICAgIHBlcmlvZCAgICAgICAgIHNsYXNoXG56ZXJvICAgICAgICAgIG9uZSAgICAgICAgICAgIHR3byAgICAgICAgICAgIHRocmVlXG5mb3VyICAgICAgICAgIGZpdmUgICAgICAgICAgIHNpeCAgICAgICAgICAgIHNldmVuXG5laWdodCAgICAgICAgIG5pbmUgICAgICAgICAgIGNvbG9uICAgICAgICAgIHNlbWljb2xvblxubGVzcyAgICAgICAgICBlcXVhbCAgICAgICAgICBncmVhdGVyICAgICAgICBxdWVzdGlvblxuICBcbmF0ICAgICAgICAgICAgQSAgICAgICAgICAgICAgQiAgICAgICAgICAgICAgQ1xuRCAgICAgICAgICAgICBFICAgICAgICAgICAgICBGICAgICAgICAgICAgICBHXG5IICAgICAgICAgICAgIEkgICAgICAgICAgICAgIEogICAgICAgICAgICAgIEtcbkwgICAgICAgICAgICAgTSAgICAgICAgICAgICAgTiAgICAgICAgICAgICAgT1xuUCAgICAgICAgICAgICBRICAgICAgICAgICAgICBSICAgICAgICAgICAgICBTXG5UICAgICAgICAgICAgIFUgICAgICAgICAgICAgIFYgICAgICAgICAgICAgIFdcblggICAgICAgICAgICAgWSAgICAgICAgICAgICAgWiAgICAgICAgICAgICAgYnJhY2tldGxlZnRcbmJhY2tzbGFzaCAgICAgYnJhY2tldHJpZ2h0ICAgYXNjaWljaXJjdW0gICAgdW5kZXJzY29yZVxuICBcbmdyYXZlICAgICAgICAgYSAgICAgICAgICAgICAgYiAgICAgICAgICAgICAgY1xuZCAgICAgICAgICAgICBlICAgICAgICAgICAgICBmICAgICAgICAgICAgICBnXG5oICAgICAgICAgICAgIGkgICAgICAgICAgICAgIGogICAgICAgICAgICAgIGtcbmwgICAgICAgICAgICAgbSAgICAgICAgICAgICAgbiAgICAgICAgICAgICAgb1xucCAgICAgICAgICAgICBxICAgICAgICAgICAgICByICAgICAgICAgICAgICBzXG50ICAgICAgICAgICAgIHUgICAgICAgICAgICAgIHYgICAgICAgICAgICAgIHdcbnggICAgICAgICAgICAgeSAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgYnJhY2VsZWZ0XG5iYXIgICAgICAgICAgIGJyYWNlcmlnaHQgICAgIGFzY2lpdGlsZGUgICAgIC5ub3RkZWZcbiAgXG5FdXJvICAgICAgICAgIC5ub3RkZWYgICAgICAgIHF1b3Rlc2luZ2xiYXNlIGZsb3JpblxucXVvdGVkYmxiYXNlICBlbGxpcHNpcyAgICAgICBkYWdnZXIgICAgICAgICBkYWdnZXJkYmxcbmNpcmN1bWZsZXggICAgcGVydGhvdXNhbmQgICAgU2Nhcm9uICAgICAgICAgZ3VpbHNpbmdsbGVmdFxuT0UgICAgICAgICAgICAubm90ZGVmICAgICAgICBaY2Fyb24gICAgICAgICAubm90ZGVmXG4ubm90ZGVmICAgICAgIHF1b3RlbGVmdCAgICAgIHF1b3RlcmlnaHQgICAgIHF1b3RlZGJsbGVmdFxucXVvdGVkYmxyaWdodCBidWxsZXQgICAgICAgICBlbmRhc2ggICAgICAgICBlbWRhc2hcbnRpbGRlICAgICAgICAgdHJhZGVtYXJrICAgICAgc2Nhcm9uICAgICAgICAgZ3VpbHNpbmdscmlnaHRcbm9lICAgICAgICAgICAgLm5vdGRlZiAgICAgICAgemNhcm9uICAgICAgICAgeWRpZXJlc2lzXG4gIFxuc3BhY2UgICAgICAgICBleGNsYW1kb3duICAgICBjZW50ICAgICAgICAgICBzdGVybGluZ1xuY3VycmVuY3kgICAgICB5ZW4gICAgICAgICAgICBicm9rZW5iYXIgICAgICBzZWN0aW9uXG5kaWVyZXNpcyAgICAgIGNvcHlyaWdodCAgICAgIG9yZGZlbWluaW5lICAgIGd1aWxsZW1vdGxlZnRcbmxvZ2ljYWxub3QgICAgaHlwaGVuICAgICAgICAgcmVnaXN0ZXJlZCAgICAgbWFjcm9uXG5kZWdyZWUgICAgICAgIHBsdXNtaW51cyAgICAgIHR3b3N1cGVyaW9yICAgIHRocmVlc3VwZXJpb3JcbmFjdXRlICAgICAgICAgbXUgICAgICAgICAgICAgcGFyYWdyYXBoICAgICAgcGVyaW9kY2VudGVyZWRcbmNlZGlsbGEgICAgICAgb25lc3VwZXJpb3IgICAgb3JkbWFzY3VsaW5lICAgZ3VpbGxlbW90cmlnaHRcbm9uZXF1YXJ0ZXIgICAgb25laGFsZiAgICAgICAgdGhyZWVxdWFydGVycyAgcXVlc3Rpb25kb3duXG4gIFxuQWdyYXZlICAgICAgICBBYWN1dGUgICAgICAgICBBY2lyY3VtZmxleCAgICBBdGlsZGVcbkFkaWVyZXNpcyAgICAgQXJpbmcgICAgICAgICAgQUUgICAgICAgICAgICAgQ2NlZGlsbGFcbkVncmF2ZSAgICAgICAgRWFjdXRlICAgICAgICAgRWNpcmN1bWZsZXggICAgRWRpZXJlc2lzXG5JZ3JhdmUgICAgICAgIElhY3V0ZSAgICAgICAgIEljaXJjdW1mbGV4ICAgIElkaWVyZXNpc1xuRXRoICAgICAgICAgICBOdGlsZGUgICAgICAgICBPZ3JhdmUgICAgICAgICBPYWN1dGVcbk9jaXJjdW1mbGV4ICAgT3RpbGRlICAgICAgICAgT2RpZXJlc2lzICAgICAgbXVsdGlwbHlcbk9zbGFzaCAgICAgICAgVWdyYXZlICAgICAgICAgVWFjdXRlICAgICAgICAgVWNpcmN1bWZsZXhcblVkaWVyZXNpcyAgICAgWWFjdXRlICAgICAgICAgVGhvcm4gICAgICAgICAgZ2VybWFuZGJsc1xuICBcbmFncmF2ZSAgICAgICAgYWFjdXRlICAgICAgICAgYWNpcmN1bWZsZXggICAgYXRpbGRlXG5hZGllcmVzaXMgICAgIGFyaW5nICAgICAgICAgIGFlICAgICAgICAgICAgIGNjZWRpbGxhXG5lZ3JhdmUgICAgICAgIGVhY3V0ZSAgICAgICAgIGVjaXJjdW1mbGV4ICAgIGVkaWVyZXNpc1xuaWdyYXZlICAgICAgICBpYWN1dGUgICAgICAgICBpY2lyY3VtZmxleCAgICBpZGllcmVzaXNcbmV0aCAgICAgICAgICAgbnRpbGRlICAgICAgICAgb2dyYXZlICAgICAgICAgb2FjdXRlXG5vY2lyY3VtZmxleCAgIG90aWxkZSAgICAgICAgIG9kaWVyZXNpcyAgICAgIGRpdmlkZVxub3NsYXNoICAgICAgICB1Z3JhdmUgICAgICAgICB1YWN1dGUgICAgICAgICB1Y2lyY3VtZmxleFxudWRpZXJlc2lzICAgICB5YWN1dGUgICAgICAgICB0aG9ybiAgICAgICAgICB5ZGllcmVzaXNcXFxuYC5zcGxpdCgvXFxzKy8pO1xuY2xhc3MgQUZNRm9udCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRlbnRzKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5nbHlwaFdpZHRocyA9IHt9O1xuICAgIHRoaXMuYm91bmRpbmdCb3hlcyA9IHt9O1xuICAgIHRoaXMua2VyblBhaXJzID0ge307XG4gICAgdGhpcy5wYXJzZShjb250ZW50cyk7XG4gICAgdGhpcy5iYm94ID0gdGhpcy5hdHRyaWJ1dGVzWydGb250QkJveCddLnNwbGl0KC9cXHMrLykubWFwKGUgPT4gK2UpO1xuICAgIHRoaXMuYXNjZW5kZXIgPSArKHRoaXMuYXR0cmlidXRlc1snQXNjZW5kZXInXSB8fCAwKTtcbiAgICB0aGlzLmRlc2NlbmRlciA9ICsodGhpcy5hdHRyaWJ1dGVzWydEZXNjZW5kZXInXSB8fCAwKTtcbiAgICB0aGlzLnhIZWlnaHQgPSArKHRoaXMuYXR0cmlidXRlc1snWEhlaWdodCddIHx8IDApO1xuICAgIHRoaXMuY2FwSGVpZ2h0ID0gKyh0aGlzLmF0dHJpYnV0ZXNbJ0NhcEhlaWdodCddIHx8IDApO1xuICAgIHRoaXMubGluZUdhcCA9IHRoaXMuYmJveFszXSAtIHRoaXMuYmJveFsxXSAtICh0aGlzLmFzY2VuZGVyIC0gdGhpcy5kZXNjZW5kZXIpO1xuICB9XG4gIHBhcnNlKGNvbnRlbnRzKSB7XG4gICAgbGV0IHNlY3Rpb24gPSAnJztcbiAgICBmb3IgKGxldCBsaW5lIG9mIGNvbnRlbnRzLnNwbGl0KCdcXG4nKSkge1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIGE7XG4gICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKC9eU3RhcnQoXFx3KykvKSkge1xuICAgICAgICBzZWN0aW9uID0gbWF0Y2hbMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goL15FbmQoXFx3KykvKSkge1xuICAgICAgICBzZWN0aW9uID0gJyc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ0ZvbnRNZXRyaWNzJzpcbiAgICAgICAgICBtYXRjaCA9IGxpbmUubWF0Y2goLyheXFx3KylcXHMrKC4qKS8pO1xuICAgICAgICAgIHZhciBrZXkgPSBtYXRjaFsxXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRjaFsyXTtcbiAgICAgICAgICBpZiAoYSA9IHRoaXMuYXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgICAgYSA9IHRoaXMuYXR0cmlidXRlc1trZXldID0gW2FdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0NoYXJNZXRyaWNzJzpcbiAgICAgICAgICBpZiAoIS9eQ0g/XFxzLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSBsaW5lLm1hdGNoKC9cXGJOXFxzKyhcXC4/XFx3KylcXHMqOy8pWzFdO1xuICAgICAgICAgIHRoaXMuZ2x5cGhXaWR0aHNbbmFtZV0gPSArbGluZS5tYXRjaCgvXFxiV1hcXHMrKFxcZCspXFxzKjsvKVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS2VyblBhaXJzJzpcbiAgICAgICAgICBtYXRjaCA9IGxpbmUubWF0Y2goL15LUFhcXHMrKFxcLj9cXHcrKVxccysoXFwuP1xcdyspXFxzKygtP1xcZCspLyk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0aGlzLmtlcm5QYWlyc1ttYXRjaFsxXSArICdcXDAnICsgbWF0Y2hbMl1dID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5jb2RlVGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBjaGFyID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgY2hhciA9IFdJTl9BTlNJX01BUFtjaGFyXSB8fCBjaGFyO1xuICAgICAgcmVzLnB1c2goY2hhci50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGdseXBoc0ZvclN0cmluZyhzdHJpbmcpIHtcbiAgICBjb25zdCBnbHlwaHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyQ29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgZ2x5cGhzLnB1c2godGhpcy5jaGFyYWN0ZXJUb0dseXBoKGNoYXJDb2RlKSk7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaHM7XG4gIH1cbiAgY2hhcmFjdGVyVG9HbHlwaChjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyc1tXSU5fQU5TSV9NQVBbY2hhcmFjdGVyXSB8fCBjaGFyYWN0ZXJdIHx8ICcubm90ZGVmJztcbiAgfVxuICB3aWR0aE9mR2x5cGgoZ2x5cGgpIHtcbiAgICByZXR1cm4gdGhpcy5nbHlwaFdpZHRoc1tnbHlwaF0gfHwgMDtcbiAgfVxuICBnZXRLZXJuUGFpcihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB0aGlzLmtlcm5QYWlyc1tsZWZ0ICsgJ1xcMCcgKyByaWdodF0gfHwgMDtcbiAgfVxuICBhZHZhbmNlc0ZvckdseXBocyhnbHlwaHMpIHtcbiAgICBjb25zdCBhZHZhbmNlcyA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBnbHlwaHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gZ2x5cGhzW2luZGV4XTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZ2x5cGhzW2luZGV4ICsgMV07XG4gICAgICBhZHZhbmNlcy5wdXNoKHRoaXMud2lkdGhPZkdseXBoKGxlZnQpICsgdGhpcy5nZXRLZXJuUGFpcihsZWZ0LCByaWdodCkpO1xuICAgIH1cbiAgICByZXR1cm4gYWR2YW5jZXM7XG4gIH1cbn1cblxuY2xhc3MgUERGRm9udCB7XG4gIGNvbnN0cnVjdG9yKCkge31cbiAgZW5jb2RlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgd2lkdGhPZlN0cmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcycpO1xuICB9XG4gIHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5ICE9IG51bGwgPyB0aGlzLmRpY3Rpb25hcnkgOiB0aGlzLmRpY3Rpb25hcnkgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICB9XG4gIGZpbmFsaXplKCkge1xuICAgIGlmICh0aGlzLmVtYmVkZGVkIHx8IHRoaXMuZGljdGlvbmFyeSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1iZWQoKTtcbiAgICB0aGlzLmVtYmVkZGVkID0gdHJ1ZTtcbiAgfVxuICBlbWJlZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcycpO1xuICB9XG4gIGxpbmVIZWlnaHQoc2l6ZSkge1xuICAgIGxldCBpbmNsdWRlR2FwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBjb25zdCBnYXAgPSBpbmNsdWRlR2FwID8gdGhpcy5saW5lR2FwIDogMDtcbiAgICByZXR1cm4gKHRoaXMuYXNjZW5kZXIgKyBnYXAgLSB0aGlzLmRlc2NlbmRlcikgLyAxMDAwICogc2l6ZTtcbiAgfVxufVxuXG5jb25zdCBTVEFOREFSRF9GT05UUyA9IHtcbiAgQ291cmllcigpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9Db3VyaWVyLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdDb3VyaWVyLUJvbGQnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0NvdXJpZXItQm9sZC5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnQ291cmllci1PYmxpcXVlJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9Db3VyaWVyLU9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0NvdXJpZXItQm9sZE9ibGlxdWUnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0NvdXJpZXItQm9sZE9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgSGVsdmV0aWNhKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0hlbHZldGljYS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnSGVsdmV0aWNhLUJvbGQnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0hlbHZldGljYS1Cb2xkLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdIZWx2ZXRpY2EtT2JsaXF1ZScoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvSGVsdmV0aWNhLU9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0hlbHZldGljYS1Cb2xkT2JsaXF1ZScoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvSGVsdmV0aWNhLUJvbGRPYmxpcXVlLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdUaW1lcy1Sb21hbicoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvVGltZXMtUm9tYW4uYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ1RpbWVzLUJvbGQnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1RpbWVzLUJvbGQuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ1RpbWVzLUl0YWxpYycoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvVGltZXMtSXRhbGljLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdUaW1lcy1Cb2xkSXRhbGljJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9UaW1lcy1Cb2xkSXRhbGljLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gIFN5bWJvbCgpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9TeW1ib2wuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgWmFwZkRpbmdiYXRzKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1phcGZEaW5nYmF0cy5hZm0nLCAndXRmOCcpO1xuICB9XG59O1xuY2xhc3MgU3RhbmRhcmRGb250IGV4dGVuZHMgUERGRm9udCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBuYW1lLCBpZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZm9udCA9IG5ldyBBRk1Gb250KFNUQU5EQVJEX0ZPTlRTW3RoaXMubmFtZV0oKSk7XG4gICAgKHtcbiAgICAgIGFzY2VuZGVyOiB0aGlzLmFzY2VuZGVyLFxuICAgICAgZGVzY2VuZGVyOiB0aGlzLmRlc2NlbmRlcixcbiAgICAgIGJib3g6IHRoaXMuYmJveCxcbiAgICAgIGxpbmVHYXA6IHRoaXMubGluZUdhcCxcbiAgICAgIHhIZWlnaHQ6IHRoaXMueEhlaWdodCxcbiAgICAgIGNhcEhlaWdodDogdGhpcy5jYXBIZWlnaHRcbiAgICB9ID0gdGhpcy5mb250KTtcbiAgfVxuICBlbWJlZCgpIHtcbiAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YSA9IHtcbiAgICAgIFR5cGU6ICdGb250JyxcbiAgICAgIEJhc2VGb250OiB0aGlzLm5hbWUsXG4gICAgICBTdWJ0eXBlOiAnVHlwZTEnLFxuICAgICAgRW5jb2Rpbmc6ICdXaW5BbnNpRW5jb2RpbmcnXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmVuZCgpO1xuICB9XG4gIGVuY29kZSh0ZXh0KSB7XG4gICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuZm9udC5lbmNvZGVUZXh0KHRleHQpO1xuICAgIGNvbnN0IGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHNGb3JTdHJpbmcoYCR7dGV4dH1gKTtcbiAgICBjb25zdCBhZHZhbmNlcyA9IHRoaXMuZm9udC5hZHZhbmNlc0ZvckdseXBocyhnbHlwaHMpO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgeEFkdmFuY2U6IGFkdmFuY2VzW2ldLFxuICAgICAgICB5QWR2YW5jZTogMCxcbiAgICAgICAgeE9mZnNldDogMCxcbiAgICAgICAgeU9mZnNldDogMCxcbiAgICAgICAgYWR2YW5jZVdpZHRoOiB0aGlzLmZvbnQud2lkdGhPZkdseXBoKGdseXBoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbZW5jb2RlZCwgcG9zaXRpb25zXTtcbiAgfVxuICB3aWR0aE9mU3RyaW5nKHN0cmluZywgc2l6ZSkge1xuICAgIGNvbnN0IGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHNGb3JTdHJpbmcoYCR7c3RyaW5nfWApO1xuICAgIGNvbnN0IGFkdmFuY2VzID0gdGhpcy5mb250LmFkdmFuY2VzRm9yR2x5cGhzKGdseXBocyk7XG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBhZHZhbmNlIG9mIGFkdmFuY2VzKSB7XG4gICAgICB3aWR0aCArPSBhZHZhbmNlO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZSA9IHNpemUgLyAxMDAwO1xuICAgIHJldHVybiB3aWR0aCAqIHNjYWxlO1xuICB9XG4gIHN0YXRpYyBpc1N0YW5kYXJkRm9udChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gU1RBTkRBUkRfRk9OVFM7XG4gIH1cbn1cblxuY29uc3QgdG9IZXggPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBgMDAwMCR7bnVtLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC00KTtcbn07XG5jbGFzcyBFbWJlZGRlZEZvbnQgZXh0ZW5kcyBQREZGb250IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIGZvbnQsIGlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zdWJzZXQgPSB0aGlzLmZvbnQuY3JlYXRlU3Vic2V0KCk7XG4gICAgdGhpcy51bmljb2RlID0gW1swXV07XG4gICAgdGhpcy53aWR0aHMgPSBbdGhpcy5mb250LmdldEdseXBoKDApLmFkdmFuY2VXaWR0aF07XG4gICAgdGhpcy5uYW1lID0gdGhpcy5mb250LnBvc3RzY3JpcHROYW1lO1xuICAgIHRoaXMuc2NhbGUgPSAxMDAwIC8gdGhpcy5mb250LnVuaXRzUGVyRW07XG4gICAgdGhpcy5hc2NlbmRlciA9IHRoaXMuZm9udC5hc2NlbnQgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMuZGVzY2VuZGVyID0gdGhpcy5mb250LmRlc2NlbnQgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMueEhlaWdodCA9IHRoaXMuZm9udC54SGVpZ2h0ICogdGhpcy5zY2FsZTtcbiAgICB0aGlzLmNhcEhlaWdodCA9IHRoaXMuZm9udC5jYXBIZWlnaHQgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMubGluZUdhcCA9IHRoaXMuZm9udC5saW5lR2FwICogdGhpcy5zY2FsZTtcbiAgICB0aGlzLmJib3ggPSB0aGlzLmZvbnQuYmJveDtcbiAgICBpZiAoZG9jdW1lbnQub3B0aW9ucy5mb250TGF5b3V0Q2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxheW91dENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH1cbiAgbGF5b3V0UnVuKHRleHQsIGZlYXR1cmVzKSB7XG4gICAgY29uc3QgcnVuID0gdGhpcy5mb250LmxheW91dCh0ZXh0LCBmZWF0dXJlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydW4ucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJ1bi5wb3NpdGlvbnNbaV07XG4gICAgICBmb3IgKGxldCBrZXkgaW4gcG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb25ba2V5XSAqPSB0aGlzLnNjYWxlO1xuICAgICAgfVxuICAgICAgcG9zaXRpb24uYWR2YW5jZVdpZHRoID0gcnVuLmdseXBoc1tpXS5hZHZhbmNlV2lkdGggKiB0aGlzLnNjYWxlO1xuICAgIH1cbiAgICByZXR1cm4gcnVuO1xuICB9XG4gIGxheW91dENhY2hlZCh0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmxheW91dENhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXRSdW4odGV4dCk7XG4gICAgfVxuICAgIGxldCBjYWNoZWQ7XG4gICAgaWYgKGNhY2hlZCA9IHRoaXMubGF5b3V0Q2FjaGVbdGV4dF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJ1biA9IHRoaXMubGF5b3V0UnVuKHRleHQpO1xuICAgIHRoaXMubGF5b3V0Q2FjaGVbdGV4dF0gPSBydW47XG4gICAgcmV0dXJuIHJ1bjtcbiAgfVxuICBsYXlvdXQodGV4dCwgZmVhdHVyZXMsIG9ubHlXaWR0aCkge1xuICAgIGlmIChmZWF0dXJlcykge1xuICAgICAgcmV0dXJuIHRoaXMubGF5b3V0UnVuKHRleHQsIGZlYXR1cmVzKTtcbiAgICB9XG4gICAgbGV0IGdseXBocyA9IG9ubHlXaWR0aCA/IG51bGwgOiBbXTtcbiAgICBsZXQgcG9zaXRpb25zID0gb25seVdpZHRoID8gbnVsbCA6IFtdO1xuICAgIGxldCBhZHZhbmNlV2lkdGggPSAwO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgdmFyIG5lZWRsZTtcbiAgICAgIGlmIChpbmRleCA9PT0gdGV4dC5sZW5ndGggJiYgbGFzdCA8IGluZGV4IHx8IChuZWVkbGUgPSB0ZXh0LmNoYXJBdChpbmRleCksIFsnICcsICdcXHQnXS5pbmNsdWRlcyhuZWVkbGUpKSkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmxheW91dENhY2hlZCh0ZXh0LnNsaWNlKGxhc3QsICsraW5kZXgpKTtcbiAgICAgICAgaWYgKCFvbmx5V2lkdGgpIHtcbiAgICAgICAgICBnbHlwaHMgPSBnbHlwaHMuY29uY2F0KHJ1bi5nbHlwaHMpO1xuICAgICAgICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5jb25jYXQocnVuLnBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZVdpZHRoICs9IHJ1bi5hZHZhbmNlV2lkdGg7XG4gICAgICAgIGxhc3QgPSBpbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBnbHlwaHMsXG4gICAgICBwb3NpdGlvbnMsXG4gICAgICBhZHZhbmNlV2lkdGhcbiAgICB9O1xuICB9XG4gIGVuY29kZSh0ZXh0LCBmZWF0dXJlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdseXBocyxcbiAgICAgIHBvc2l0aW9uc1xuICAgIH0gPSB0aGlzLmxheW91dCh0ZXh0LCBmZWF0dXJlcyk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgY29uc3QgZ2lkID0gdGhpcy5zdWJzZXQuaW5jbHVkZUdseXBoKGdseXBoLmlkKTtcbiAgICAgIHJlcy5wdXNoKGAwMDAwJHtnaWQudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTQpKTtcbiAgICAgIGlmICh0aGlzLndpZHRoc1tnaWRdID09IG51bGwpIHtcbiAgICAgICAgdGhpcy53aWR0aHNbZ2lkXSA9IGdseXBoLmFkdmFuY2VXaWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51bmljb2RlW2dpZF0gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuaWNvZGVbZ2lkXSA9IGdseXBoLmNvZGVQb2ludHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcmVzLCBwb3NpdGlvbnNdO1xuICB9XG4gIHdpZHRoT2ZTdHJpbmcoc3RyaW5nLCBzaXplLCBmZWF0dXJlcykge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5sYXlvdXQoc3RyaW5nLCBmZWF0dXJlcywgdHJ1ZSkuYWR2YW5jZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlID0gc2l6ZSAvIDEwMDA7XG4gICAgcmV0dXJuIHdpZHRoICogc2NhbGU7XG4gIH1cbiAgZW1iZWQoKSB7XG4gICAgY29uc3QgaXNDRkYgPSB0aGlzLnN1YnNldC5jZmYgIT0gbnVsbDtcbiAgICBjb25zdCBmb250RmlsZSA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gICAgaWYgKGlzQ0ZGKSB7XG4gICAgICBmb250RmlsZS5kYXRhLlN1YnR5cGUgPSAnQ0lERm9udFR5cGUwQyc7XG4gICAgfVxuICAgIGZvbnRGaWxlLmVuZCh0aGlzLnN1YnNldC5lbmNvZGUoKSk7XG4gICAgY29uc3QgZmFtaWx5Q2xhc3MgPSAoKHRoaXMuZm9udFsnT1MvMiddICE9IG51bGwgPyB0aGlzLmZvbnRbJ09TLzInXS5zRmFtaWx5Q2xhc3MgOiB1bmRlZmluZWQpIHx8IDApID4+IDg7XG4gICAgbGV0IGZsYWdzID0gMDtcbiAgICBpZiAodGhpcy5mb250LnBvc3QuaXNGaXhlZFBpdGNoKSB7XG4gICAgICBmbGFncyB8PSAxIDw8IDA7XG4gICAgfVxuICAgIGlmICgxIDw9IGZhbWlseUNsYXNzICYmIGZhbWlseUNsYXNzIDw9IDcpIHtcbiAgICAgIGZsYWdzIHw9IDEgPDwgMTtcbiAgICB9XG4gICAgZmxhZ3MgfD0gMSA8PCAyO1xuICAgIGlmIChmYW1pbHlDbGFzcyA9PT0gMTApIHtcbiAgICAgIGZsYWdzIHw9IDEgPDwgMztcbiAgICB9XG4gICAgaWYgKHRoaXMuZm9udC5oZWFkLm1hY1N0eWxlLml0YWxpYykge1xuICAgICAgZmxhZ3MgfD0gMSA8PCA2O1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBbMSwgMiwgMywgNCwgNSwgNl0ubWFwKGkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSgodGhpcy5pZC5jaGFyQ29kZUF0KGkpIHx8IDczKSArIDE3KSkuam9pbignJyk7XG4gICAgY29uc3QgbmFtZSA9IHRhZyArICcrJyArIHRoaXMuZm9udC5wb3N0c2NyaXB0TmFtZT8ucmVwbGFjZUFsbCgnICcsICdfJyk7XG4gICAgY29uc3Qge1xuICAgICAgYmJveFxuICAgIH0gPSB0aGlzLmZvbnQ7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgIFR5cGU6ICdGb250RGVzY3JpcHRvcicsXG4gICAgICBGb250TmFtZTogbmFtZSxcbiAgICAgIEZsYWdzOiBmbGFncyxcbiAgICAgIEZvbnRCQm94OiBbYmJveC5taW5YICogdGhpcy5zY2FsZSwgYmJveC5taW5ZICogdGhpcy5zY2FsZSwgYmJveC5tYXhYICogdGhpcy5zY2FsZSwgYmJveC5tYXhZICogdGhpcy5zY2FsZV0sXG4gICAgICBJdGFsaWNBbmdsZTogdGhpcy5mb250Lml0YWxpY0FuZ2xlLFxuICAgICAgQXNjZW50OiB0aGlzLmFzY2VuZGVyLFxuICAgICAgRGVzY2VudDogdGhpcy5kZXNjZW5kZXIsXG4gICAgICBDYXBIZWlnaHQ6ICh0aGlzLmZvbnQuY2FwSGVpZ2h0IHx8IHRoaXMuZm9udC5hc2NlbnQpICogdGhpcy5zY2FsZSxcbiAgICAgIFhIZWlnaHQ6ICh0aGlzLmZvbnQueEhlaWdodCB8fCAwKSAqIHRoaXMuc2NhbGUsXG4gICAgICBTdGVtVjogMFxuICAgIH0pO1xuICAgIGlmIChpc0NGRikge1xuICAgICAgZGVzY3JpcHRvci5kYXRhLkZvbnRGaWxlMyA9IGZvbnRGaWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXNjcmlwdG9yLmRhdGEuRm9udEZpbGUyID0gZm9udEZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLmRvY3VtZW50LnN1YnNldCAmJiB0aGlzLmRvY3VtZW50LnN1YnNldCA9PT0gMSkge1xuICAgICAgY29uc3QgQ0lEU2V0ID0gQnVmZmVyLmZyb20oJ0ZGRkZGRkZGQzAnLCAnaGV4Jyk7XG4gICAgICBjb25zdCBDSURTZXRSZWYgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICAgICAgQ0lEU2V0UmVmLndyaXRlKENJRFNldCk7XG4gICAgICBDSURTZXRSZWYuZW5kKCk7XG4gICAgICBkZXNjcmlwdG9yLmRhdGEuQ0lEU2V0ID0gQ0lEU2V0UmVmO1xuICAgIH1cbiAgICBkZXNjcmlwdG9yLmVuZCgpO1xuICAgIGNvbnN0IGRlc2NlbmRhbnRGb250RGF0YSA9IHtcbiAgICAgIFR5cGU6ICdGb250JyxcbiAgICAgIFN1YnR5cGU6ICdDSURGb250VHlwZTAnLFxuICAgICAgQmFzZUZvbnQ6IG5hbWUsXG4gICAgICBDSURTeXN0ZW1JbmZvOiB7XG4gICAgICAgIFJlZ2lzdHJ5OiBuZXcgU3RyaW5nKCdBZG9iZScpLFxuICAgICAgICBPcmRlcmluZzogbmV3IFN0cmluZygnSWRlbnRpdHknKSxcbiAgICAgICAgU3VwcGxlbWVudDogMFxuICAgICAgfSxcbiAgICAgIEZvbnREZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgVzogWzAsIHRoaXMud2lkdGhzXVxuICAgIH07XG4gICAgaWYgKCFpc0NGRikge1xuICAgICAgZGVzY2VuZGFudEZvbnREYXRhLlN1YnR5cGUgPSAnQ0lERm9udFR5cGUyJztcbiAgICAgIGRlc2NlbmRhbnRGb250RGF0YS5DSURUb0dJRE1hcCA9ICdJZGVudGl0eSc7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NlbmRhbnRGb250ID0gdGhpcy5kb2N1bWVudC5yZWYoZGVzY2VuZGFudEZvbnREYXRhKTtcbiAgICBkZXNjZW5kYW50Rm9udC5lbmQoKTtcbiAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YSA9IHtcbiAgICAgIFR5cGU6ICdGb250JyxcbiAgICAgIFN1YnR5cGU6ICdUeXBlMCcsXG4gICAgICBCYXNlRm9udDogbmFtZSxcbiAgICAgIEVuY29kaW5nOiAnSWRlbnRpdHktSCcsXG4gICAgICBEZXNjZW5kYW50Rm9udHM6IFtkZXNjZW5kYW50Rm9udF0sXG4gICAgICBUb1VuaWNvZGU6IHRoaXMudG9Vbmljb2RlQ21hcCgpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmVuZCgpO1xuICB9XG4gIHRvVW5pY29kZUNtYXAoKSB7XG4gICAgY29uc3QgY21hcCA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAobGV0IGNvZGVQb2ludHMgb2YgdGhpcy51bmljb2RlKSB7XG4gICAgICBjb25zdCBlbmNvZGVkID0gW107XG4gICAgICBmb3IgKGxldCB2YWx1ZSBvZiBjb2RlUG9pbnRzKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IDB4ZmZmZikge1xuICAgICAgICAgIHZhbHVlIC09IDB4MTAwMDA7XG4gICAgICAgICAgZW5jb2RlZC5wdXNoKHRvSGV4KHZhbHVlID4+PiAxMCAmIDB4M2ZmIHwgMHhkODAwKSk7XG4gICAgICAgICAgdmFsdWUgPSAweGRjMDAgfCB2YWx1ZSAmIDB4M2ZmO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQucHVzaCh0b0hleCh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgZW50cmllcy5wdXNoKGA8JHtlbmNvZGVkLmpvaW4oJyAnKX0+YCk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDI1NjtcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZW50cmllcy5sZW5ndGggLyBjaHVua1NpemUpO1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaSAqIGNodW5rU2l6ZTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKChpICsgMSkgKiBjaHVua1NpemUsIGVudHJpZXMubGVuZ3RoKTtcbiAgICAgIHJhbmdlcy5wdXNoKGA8JHt0b0hleChzdGFydCl9PiA8JHt0b0hleChlbmQgLSAxKX0+IFske2VudHJpZXMuc2xpY2Uoc3RhcnQsIGVuZCkuam9pbignICcpfV1gKTtcbiAgICB9XG4gICAgY21hcC5lbmQoYFxcXG4vQ0lESW5pdCAvUHJvY1NldCBmaW5kcmVzb3VyY2UgYmVnaW5cbjEyIGRpY3QgYmVnaW5cbmJlZ2luY21hcFxuL0NJRFN5c3RlbUluZm8gPDxcbiAgL1JlZ2lzdHJ5IChBZG9iZSlcbiAgL09yZGVyaW5nIChVQ1MpXG4gIC9TdXBwbGVtZW50IDBcbj4+IGRlZlxuL0NNYXBOYW1lIC9BZG9iZS1JZGVudGl0eS1VQ1MgZGVmXG4vQ01hcFR5cGUgMiBkZWZcbjEgYmVnaW5jb2Rlc3BhY2VyYW5nZVxuPDAwMDA+PGZmZmY+XG5lbmRjb2Rlc3BhY2VyYW5nZVxuMSBiZWdpbmJmcmFuZ2VcbiR7cmFuZ2VzLmpvaW4oJ1xcbicpfVxuZW5kYmZyYW5nZVxuZW5kY21hcFxuQ01hcE5hbWUgY3VycmVudGRpY3QgL0NNYXAgZGVmaW5lcmVzb3VyY2UgcG9wXG5lbmRcbmVuZFxcXG5gKTtcbiAgICByZXR1cm4gY21hcDtcbiAgfVxufVxuXG5jbGFzcyBQREZGb250RmFjdG9yeSB7XG4gIHN0YXRpYyBvcGVuKGRvY3VtZW50LCBzcmMsIGZhbWlseSwgaWQpIHtcbiAgICBsZXQgZm9udDtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChTdGFuZGFyZEZvbnQuaXNTdGFuZGFyZEZvbnQoc3JjKSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YW5kYXJkRm9udChkb2N1bWVudCwgc3JjLCBpZCk7XG4gICAgICB9XG4gICAgICBzcmMgPSBmcy5yZWFkRmlsZVN5bmMoc3JjKTtcbiAgICB9XG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZvbnQgPSBmb250a2l0LmNyZWF0ZShzcmMsIGZhbWlseSk7XG4gICAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgZm9udCA9IGZvbnRraXQuY3JlYXRlKG5ldyBVaW50OEFycmF5KHNyYyksIGZhbWlseSk7XG4gICAgfVxuICAgIGlmIChmb250ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgc3VwcG9ydGVkIGZvbnQgZm9ybWF0IG9yIHN0YW5kYXJkIFBERiBmb250LicpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVtYmVkZGVkRm9udChkb2N1bWVudCwgZm9udCwgaWQpO1xuICB9XG59XG5cbmNvbnN0IGlzRXF1YWxGb250ID0gKGZvbnQxLCBmb250MikgPT4ge1xuICBpZiAoZm9udDEuZm9udC5fdGFibGVzPy5oZWFkPy5jaGVja1N1bUFkanVzdG1lbnQgIT09IGZvbnQyLmZvbnQuX3RhYmxlcz8uaGVhZD8uY2hlY2tTdW1BZGp1c3RtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChKU09OLnN0cmluZ2lmeShmb250MS5mb250Ll90YWJsZXM/Lm5hbWU/LnJlY29yZHMpICE9PSBKU09OLnN0cmluZ2lmeShmb250Mi5mb250Ll90YWJsZXM/Lm5hbWU/LnJlY29yZHMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGb250c01peGluID0ge1xuICBpbml0Rm9udHMoKSB7XG4gICAgbGV0IGRlZmF1bHRGb250ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnSGVsdmV0aWNhJztcbiAgICBsZXQgZGVmYXVsdEZvbnRGYW1pbHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgbGV0IGRlZmF1bHRGb250U2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTI7XG4gICAgdGhpcy5fZm9udEZhbWlsaWVzID0ge307XG4gICAgdGhpcy5fZm9udENvdW50ID0gMDtcbiAgICB0aGlzLl9mb250U291cmNlID0gZGVmYXVsdEZvbnQ7XG4gICAgdGhpcy5fZm9udEZhbWlseSA9IGRlZmF1bHRGb250RmFtaWx5O1xuICAgIHRoaXMuX2ZvbnRTaXplID0gZGVmYXVsdEZvbnRTaXplO1xuICAgIHRoaXMuX2ZvbnQgPSBudWxsO1xuICAgIHRoaXMuX3JlbVNpemUgPSBkZWZhdWx0Rm9udFNpemU7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEZvbnRzID0ge307XG4gICAgaWYgKGRlZmF1bHRGb250KSB7XG4gICAgICB0aGlzLmZvbnQoZGVmYXVsdEZvbnQsIGRlZmF1bHRGb250RmFtaWx5KTtcbiAgICB9XG4gIH0sXG4gIGZvbnQoc3JjLCBmYW1pbHksIHNpemUpIHtcbiAgICBsZXQgY2FjaGVLZXksIGZvbnQ7XG4gICAgaWYgKHR5cGVvZiBmYW1pbHkgPT09ICdudW1iZXInKSB7XG4gICAgICBzaXplID0gZmFtaWx5O1xuICAgICAgZmFtaWx5ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHRoaXMuX3JlZ2lzdGVyZWRGb250c1tzcmNdKSB7XG4gICAgICBjYWNoZUtleSA9IHNyYztcbiAgICAgICh7XG4gICAgICAgIHNyYyxcbiAgICAgICAgZmFtaWx5XG4gICAgICB9ID0gdGhpcy5fcmVnaXN0ZXJlZEZvbnRzW3NyY10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZUtleSA9IGZhbWlseSB8fCBzcmM7XG4gICAgICBpZiAodHlwZW9mIGNhY2hlS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjYWNoZUtleSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ZvbnRTb3VyY2UgPSBzcmM7XG4gICAgdGhpcy5fZm9udEZhbWlseSA9IGZhbWlseTtcbiAgICBpZiAoc2l6ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZvbnRTaXplKHNpemUpO1xuICAgIH1cbiAgICBpZiAoZm9udCA9IHRoaXMuX2ZvbnRGYW1pbGllc1tjYWNoZUtleV0pIHtcbiAgICAgIHRoaXMuX2ZvbnQgPSBmb250O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYEYkeysrdGhpcy5fZm9udENvdW50fWA7XG4gICAgdGhpcy5fZm9udCA9IFBERkZvbnRGYWN0b3J5Lm9wZW4odGhpcywgc3JjLCBmYW1pbHksIGlkKTtcbiAgICBpZiAoKGZvbnQgPSB0aGlzLl9mb250RmFtaWxpZXNbdGhpcy5fZm9udC5uYW1lXSkgJiYgaXNFcXVhbEZvbnQodGhpcy5fZm9udCwgZm9udCkpIHtcbiAgICAgIHRoaXMuX2ZvbnQgPSBmb250O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgdGhpcy5fZm9udEZhbWlsaWVzW2NhY2hlS2V5XSA9IHRoaXMuX2ZvbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLl9mb250Lm5hbWUpIHtcbiAgICAgIHRoaXMuX2ZvbnRGYW1pbGllc1t0aGlzLl9mb250Lm5hbWVdID0gdGhpcy5fZm9udDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZvbnRTaXplKF9mb250U2l6ZSkge1xuICAgIHRoaXMuX2ZvbnRTaXplID0gdGhpcy5zaXplVG9Qb2ludChfZm9udFNpemUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjdXJyZW50TGluZUhlaWdodChpbmNsdWRlR2FwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnQubGluZUhlaWdodCh0aGlzLl9mb250U2l6ZSwgaW5jbHVkZUdhcCk7XG4gIH0sXG4gIHJlZ2lzdGVyRm9udChuYW1lLCBzcmMsIGZhbWlseSkge1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRGb250c1tuYW1lXSA9IHtcbiAgICAgIHNyYyxcbiAgICAgIGZhbWlseVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNpemVUb1BvaW50KHNpemUpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIGxldCBwYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnBhZ2U7XG4gICAgbGV0IHBlcmNlbnRhZ2VXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGlmICghcGVyY2VudGFnZVdpZHRoKSBwZXJjZW50YWdlV2lkdGggPSB0aGlzLl9mb250U2l6ZTtcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPT0gJ251bWJlcicpIGRlZmF1bHRWYWx1ZSA9IHRoaXMuc2l6ZVRvUG9pbnQoZGVmYXVsdFZhbHVlKTtcbiAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHJldHVybiBzaXplO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gTnVtYmVyKHNpemUpO1xuICAgIGNvbnN0IG1hdGNoID0gU3RyaW5nKHNpemUpLm1hdGNoKC8oKFxcZCspPyhcXC5cXGQrKT8pKGVtfGlufHB4fGNtfG1tfHBjfGV4fGNofHJlbXx2d3x2aHx2bWlufHZtYXh8JXxwdCk/Lyk7XG4gICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzaXplICcke3NpemV9J2ApO1xuICAgIGxldCBtdWx0aXBsaWVyO1xuICAgIHN3aXRjaCAobWF0Y2hbNF0pIHtcbiAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgbXVsdGlwbGllciA9IHRoaXMuX2ZvbnRTaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgbXVsdGlwbGllciA9IElOX1RPX1BUO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3B4JzpcbiAgICAgICAgbXVsdGlwbGllciA9IFBYX1RPX0lOICogSU5fVE9fUFQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY20nOlxuICAgICAgICBtdWx0aXBsaWVyID0gQ01fVE9fSU4gKiBJTl9UT19QVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtbSc6XG4gICAgICAgIG11bHRpcGxpZXIgPSBNTV9UT19DTSAqIENNX1RPX0lOICogSU5fVE9fUFQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGMnOlxuICAgICAgICBtdWx0aXBsaWVyID0gUENfVE9fUFQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXgnOlxuICAgICAgICBtdWx0aXBsaWVyID0gdGhpcy5jdXJyZW50TGluZUhlaWdodCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoJzpcbiAgICAgICAgbXVsdGlwbGllciA9IHRoaXMud2lkdGhPZlN0cmluZygnMCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbSc6XG4gICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLl9yZW1TaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Z3JzpcbiAgICAgICAgbXVsdGlwbGllciA9IHBhZ2Uud2lkdGggLyAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndmgnOlxuICAgICAgICBtdWx0aXBsaWVyID0gcGFnZS5oZWlnaHQgLyAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndm1pbic6XG4gICAgICAgIG11bHRpcGxpZXIgPSBNYXRoLm1pbihwYWdlLndpZHRoLCBwYWdlLmhlaWdodCkgLyAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndm1heCc6XG4gICAgICAgIG11bHRpcGxpZXIgPSBNYXRoLm1heChwYWdlLndpZHRoLCBwYWdlLmhlaWdodCkgLyAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICAgIG11bHRpcGxpZXIgPSBwZXJjZW50YWdlV2lkdGggLyAxMDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHQnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbXVsdGlwbGllciA9IDE7XG4gICAgfVxuICAgIHJldHVybiBtdWx0aXBsaWVyICogTnVtYmVyKG1hdGNoWzFdKTtcbiAgfVxufTtcblxuY29uc3QgU09GVF9IWVBIRU4gPSAnXFx1MDBBRCc7XG5jb25zdCBIWVBIRU4gPSAnLSc7XG5jbGFzcyBMaW5lV3JhcHBlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5ob3Jpem9udGFsU2NhbGluZyA9IG9wdGlvbnMuaG9yaXpvbnRhbFNjYWxpbmcgfHwgMTAwO1xuICAgIHRoaXMuaW5kZW50ID0gKG9wdGlvbnMuaW5kZW50IHx8IDApICogdGhpcy5ob3Jpem9udGFsU2NhbGluZyAvIDEwMDtcbiAgICB0aGlzLmNoYXJhY3RlclNwYWNpbmcgPSAob3B0aW9ucy5jaGFyYWN0ZXJTcGFjaW5nIHx8IDApICogdGhpcy5ob3Jpem9udGFsU2NhbGluZyAvIDEwMDtcbiAgICB0aGlzLndvcmRTcGFjaW5nID0gKG9wdGlvbnMud29yZFNwYWNpbmcgPT09IDApICogdGhpcy5ob3Jpem9udGFsU2NhbGluZyAvIDEwMDtcbiAgICB0aGlzLmNvbHVtbnMgPSBvcHRpb25zLmNvbHVtbnMgfHwgMTtcbiAgICB0aGlzLmNvbHVtbkdhcCA9IChvcHRpb25zLmNvbHVtbkdhcCAhPSBudWxsID8gb3B0aW9ucy5jb2x1bW5HYXAgOiAxOCkgKiB0aGlzLmhvcml6b250YWxTY2FsaW5nIC8gMTAwO1xuICAgIHRoaXMubGluZVdpZHRoID0gKG9wdGlvbnMud2lkdGggKiB0aGlzLmhvcml6b250YWxTY2FsaW5nIC8gMTAwIC0gdGhpcy5jb2x1bW5HYXAgKiAodGhpcy5jb2x1bW5zIC0gMSkpIC8gdGhpcy5jb2x1bW5zO1xuICAgIHRoaXMuc3BhY2VMZWZ0ID0gdGhpcy5saW5lV2lkdGg7XG4gICAgdGhpcy5zdGFydFggPSB0aGlzLmRvY3VtZW50Lng7XG4gICAgdGhpcy5zdGFydFkgPSB0aGlzLmRvY3VtZW50Lnk7XG4gICAgdGhpcy5jb2x1bW4gPSAxO1xuICAgIHRoaXMuZWxsaXBzaXMgPSBvcHRpb25zLmVsbGlwc2lzO1xuICAgIHRoaXMuY29udGludWVkWCA9IDA7XG4gICAgdGhpcy5mZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7XG4gICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICB0aGlzLm1heFkgPSBQREZOdW1iZXIodGhpcy5zdGFydFkgKyBvcHRpb25zLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWF4WSA9IFBERk51bWJlcih0aGlzLmRvY3VtZW50LnBhZ2UubWF4WSgpKTtcbiAgICB9XG4gICAgdGhpcy5vbignZmlyc3RMaW5lJywgb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBpbmRlbnQgPSB0aGlzLmNvbnRpbnVlZFggfHwgdGhpcy5pbmRlbnQ7XG4gICAgICB0aGlzLmRvY3VtZW50LnggKz0gaW5kZW50O1xuICAgICAgdGhpcy5saW5lV2lkdGggLT0gaW5kZW50O1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZW50QWxsTGluZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vbmNlKCdsaW5lJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmRvY3VtZW50LnggLT0gaW5kZW50O1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCArPSBpbmRlbnQ7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRpbnVlZCAmJiAhdGhpcy5jb250aW51ZWRYKSB7XG4gICAgICAgICAgdGhpcy5jb250aW51ZWRYID0gdGhpcy5pbmRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmNvbnRpbnVlZCkge1xuICAgICAgICAgIHRoaXMuY29udGludWVkWCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ2xhc3RMaW5lJywgb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsaWduXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgIG9wdGlvbnMuYWxpZ24gPSAnbGVmdCc7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RMaW5lID0gdHJ1ZTtcbiAgICAgIHRoaXMub25jZSgnbGluZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC55ICs9IG9wdGlvbnMucGFyYWdyYXBoR2FwIHx8IDA7XG4gICAgICAgIG9wdGlvbnMuYWxpZ24gPSBhbGlnbjtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdExpbmUgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHdvcmRXaWR0aCh3b3JkKSB7XG4gICAgcmV0dXJuIFBERk51bWJlcih0aGlzLmRvY3VtZW50LndpZHRoT2ZTdHJpbmcod29yZCwgdGhpcykgKyB0aGlzLmNoYXJhY3RlclNwYWNpbmcgKyB0aGlzLndvcmRTcGFjaW5nKTtcbiAgfVxuICBjYW5GaXQod29yZCwgdykge1xuICAgIGlmICh3b3JkW3dvcmQubGVuZ3RoIC0gMV0gIT0gU09GVF9IWVBIRU4pIHtcbiAgICAgIHJldHVybiB3IDw9IHRoaXMuc3BhY2VMZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gdyArIHRoaXMud29yZFdpZHRoKEhZUEhFTikgPD0gdGhpcy5zcGFjZUxlZnQ7XG4gIH1cbiAgZWFjaFdvcmQodGV4dCwgZm4pIHtcbiAgICBsZXQgYms7XG4gICAgY29uc3QgYnJlYWtlciA9IG5ldyBMaW5lQnJlYWtlcih0ZXh0KTtcbiAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgY29uc3Qgd29yZFdpZHRocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgd2hpbGUgKGJrID0gYnJlYWtlci5uZXh0QnJlYWsoKSkge1xuICAgICAgdmFyIHNob3VsZENvbnRpbnVlO1xuICAgICAgbGV0IHdvcmQgPSB0ZXh0LnNsaWNlKChsYXN0ICE9IG51bGwgPyBsYXN0LnBvc2l0aW9uIDogdW5kZWZpbmVkKSB8fCAwLCBiay5wb3NpdGlvbik7XG4gICAgICBsZXQgdyA9IHdvcmRXaWR0aHNbd29yZF0gIT0gbnVsbCA/IHdvcmRXaWR0aHNbd29yZF0gOiB3b3JkV2lkdGhzW3dvcmRdID0gdGhpcy53b3JkV2lkdGgod29yZCk7XG4gICAgICBpZiAodyA+IHRoaXMubGluZVdpZHRoICsgdGhpcy5jb250aW51ZWRYKSB7XG4gICAgICAgIGxldCBsYmsgPSBsYXN0O1xuICAgICAgICBjb25zdCBmYmsgPSB7fTtcbiAgICAgICAgd2hpbGUgKHdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGwsIG1pZ2h0R3JvdztcbiAgICAgICAgICBpZiAodyA+IHRoaXMuc3BhY2VMZWZ0KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5jZWlsKHRoaXMuc3BhY2VMZWZ0IC8gKHcgLyB3b3JkLmxlbmd0aCkpO1xuICAgICAgICAgICAgdyA9IHRoaXMud29yZFdpZHRoKHdvcmQuc2xpY2UoMCwgbCkpO1xuICAgICAgICAgICAgbWlnaHRHcm93ID0gdyA8PSB0aGlzLnNwYWNlTGVmdCAmJiBsIDwgd29yZC5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSB3b3JkLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG11c3RTaHJpbmsgPSB3ID4gdGhpcy5zcGFjZUxlZnQgJiYgbCA+IDA7XG4gICAgICAgICAgd2hpbGUgKG11c3RTaHJpbmsgfHwgbWlnaHRHcm93KSB7XG4gICAgICAgICAgICBpZiAobXVzdFNocmluaykge1xuICAgICAgICAgICAgICB3ID0gdGhpcy53b3JkV2lkdGgod29yZC5zbGljZSgwLCAtLWwpKTtcbiAgICAgICAgICAgICAgbXVzdFNocmluayA9IHcgPiB0aGlzLnNwYWNlTGVmdCAmJiBsID4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHcgPSB0aGlzLndvcmRXaWR0aCh3b3JkLnNsaWNlKDAsICsrbCkpO1xuICAgICAgICAgICAgICBtdXN0U2hyaW5rID0gdyA+IHRoaXMuc3BhY2VMZWZ0ICYmIGwgPiAwO1xuICAgICAgICAgICAgICBtaWdodEdyb3cgPSB3IDw9IHRoaXMuc3BhY2VMZWZ0ICYmIGwgPCB3b3JkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGwgPT09IDAgJiYgdGhpcy5zcGFjZUxlZnQgPT09IHRoaXMubGluZVdpZHRoKSB7XG4gICAgICAgICAgICBsID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmJrLnJlcXVpcmVkID0gYmsucmVxdWlyZWQgfHwgbCA8IHdvcmQubGVuZ3RoO1xuICAgICAgICAgIHNob3VsZENvbnRpbnVlID0gZm4od29yZC5zbGljZSgwLCBsKSwgdywgZmJrLCBsYmspO1xuICAgICAgICAgIGxiayA9IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgICAgd29yZCA9IHdvcmQuc2xpY2UobCk7XG4gICAgICAgICAgdyA9IHRoaXMud29yZFdpZHRoKHdvcmQpO1xuICAgICAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hvdWxkQ29udGludWUgPSBmbih3b3JkLCB3LCBiaywgbGFzdCk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQ29udGludWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGFzdCA9IGJrO1xuICAgIH1cbiAgfVxuICB3cmFwKHRleHQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhvcml6b250YWxTY2FsaW5nID0gb3B0aW9ucy5ob3Jpem9udGFsU2NhbGluZyB8fCAxMDA7XG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQgKiB0aGlzLmhvcml6b250YWxTY2FsaW5nIC8gMTAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJTcGFjaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyU3BhY2luZyA9IG9wdGlvbnMuY2hhcmFjdGVyU3BhY2luZyAqIHRoaXMuaG9yaXpvbnRhbFNjYWxpbmcgLyAxMDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndvcmRTcGFjaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMud29yZFNwYWNpbmcgPSBvcHRpb25zLndvcmRTcGFjaW5nICogdGhpcy5ob3Jpem9udGFsU2NhbGluZyAvIDEwMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZWxsaXBzaXMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5lbGxpcHNpcyA9IG9wdGlvbnMuZWxsaXBzaXM7XG4gICAgfVxuICAgIGNvbnN0IG5leHRZID0gdGhpcy5kb2N1bWVudC55ICsgdGhpcy5kb2N1bWVudC5jdXJyZW50TGluZUhlaWdodCh0cnVlKTtcbiAgICBpZiAodGhpcy5kb2N1bWVudC55ID4gdGhpcy5tYXhZIHx8IG5leHRZID4gdGhpcy5tYXhZKSB7XG4gICAgICB0aGlzLm5leHRTZWN0aW9uKCk7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSAnJztcbiAgICBsZXQgdGV4dFdpZHRoID0gMDtcbiAgICBsZXQgd2MgPSAwO1xuICAgIGxldCBsYyA9IDA7XG4gICAgbGV0IHtcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5kb2N1bWVudDtcbiAgICBjb25zdCBlbWl0TGluZSA9ICgpID0+IHtcbiAgICAgIG9wdGlvbnMudGV4dFdpZHRoID0gdGV4dFdpZHRoICsgdGhpcy53b3JkU3BhY2luZyAqICh3YyAtIDEpO1xuICAgICAgb3B0aW9ucy53b3JkQ291bnQgPSB3YztcbiAgICAgIG9wdGlvbnMubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG4gICAgICAoe1xuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5kb2N1bWVudCk7XG4gICAgICB0aGlzLmVtaXQoJ2xpbmUnLCBidWZmZXIsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgcmV0dXJuIGxjKys7XG4gICAgfTtcbiAgICB0aGlzLmVtaXQoJ3NlY3Rpb25TdGFydCcsIG9wdGlvbnMsIHRoaXMpO1xuICAgIHRoaXMuZWFjaFdvcmQodGV4dCwgKHdvcmQsIHcsIGJrLCBsYXN0KSA9PiB7XG4gICAgICBpZiAobGFzdCA9PSBudWxsIHx8IGxhc3QucmVxdWlyZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdmaXJzdExpbmUnLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zcGFjZUxlZnQgPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbkZpdCh3b3JkLCB3KSkge1xuICAgICAgICBidWZmZXIgKz0gd29yZDtcbiAgICAgICAgdGV4dFdpZHRoICs9IHc7XG4gICAgICAgIHdjKys7XG4gICAgICB9XG4gICAgICBpZiAoYmsucmVxdWlyZWQgfHwgIXRoaXMuY2FuRml0KHdvcmQsIHcpKSB7XG4gICAgICAgIGNvbnN0IGxoID0gdGhpcy5kb2N1bWVudC5jdXJyZW50TGluZUhlaWdodCh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IG51bGwgJiYgdGhpcy5lbGxpcHNpcyAmJiBQREZOdW1iZXIodGhpcy5kb2N1bWVudC55ICsgbGggKiAyKSA+IHRoaXMubWF4WSAmJiB0aGlzLmNvbHVtbiA+PSB0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGxpcHNpcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5lbGxpcHNpcyA9ICfigKYnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy53b3JkV2lkdGgoYnVmZmVyICsgdGhpcy5lbGxpcHNpcyk7XG4gICAgICAgICAgd2hpbGUgKGJ1ZmZlciAmJiB0ZXh0V2lkdGggPiB0aGlzLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIC0xKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMud29yZFdpZHRoKGJ1ZmZlciArIHRoaXMuZWxsaXBzaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dFdpZHRoIDw9IHRoaXMubGluZVdpZHRoKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIgKyB0aGlzLmVsbGlwc2lzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLndvcmRXaWR0aChidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiay5yZXF1aXJlZCkge1xuICAgICAgICAgIGlmICh3ID4gdGhpcy5zcGFjZUxlZnQpIHtcbiAgICAgICAgICAgIGVtaXRMaW5lKCk7XG4gICAgICAgICAgICBidWZmZXIgPSB3b3JkO1xuICAgICAgICAgICAgdGV4dFdpZHRoID0gdztcbiAgICAgICAgICAgIHdjID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KCdsYXN0TGluZScsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdID09IFNPRlRfSFlQSEVOKSB7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIC0xKSArIEhZUEhFTjtcbiAgICAgICAgICB0aGlzLnNwYWNlTGVmdCAtPSB0aGlzLndvcmRXaWR0aChIWVBIRU4pO1xuICAgICAgICB9XG4gICAgICAgIGVtaXRMaW5lKCk7XG4gICAgICAgIGlmIChQREZOdW1iZXIodGhpcy5kb2N1bWVudC55ICsgbGgpID4gdGhpcy5tYXhZKSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSB0aGlzLm5leHRTZWN0aW9uKCk7XG4gICAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZSkge1xuICAgICAgICAgICAgd2MgPSAwO1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiay5yZXF1aXJlZCkge1xuICAgICAgICAgIHRoaXMuc3BhY2VMZWZ0ID0gdGhpcy5saW5lV2lkdGg7XG4gICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgdGV4dFdpZHRoID0gMDtcbiAgICAgICAgICByZXR1cm4gd2MgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3BhY2VMZWZ0ID0gdGhpcy5saW5lV2lkdGggLSB3O1xuICAgICAgICAgIGJ1ZmZlciA9IHdvcmQ7XG4gICAgICAgICAgdGV4dFdpZHRoID0gdztcbiAgICAgICAgICByZXR1cm4gd2MgPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFjZUxlZnQgLT0gdztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAod2MgPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2xhc3RMaW5lJywgb3B0aW9ucywgdGhpcyk7XG4gICAgICBlbWl0TGluZSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3NlY3Rpb25FbmQnLCBvcHRpb25zLCB0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5jb250aW51ZWQgPT09IHRydWUpIHtcbiAgICAgIGlmIChsYyA+IDEpIHtcbiAgICAgICAgdGhpcy5jb250aW51ZWRYID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGludWVkWCArPSBvcHRpb25zLnRleHRXaWR0aCB8fCAwO1xuICAgICAgdGhpcy5kb2N1bWVudC55ID0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb2N1bWVudC54ID0gdGhpcy5zdGFydFg7XG4gICAgfVxuICB9XG4gIG5leHRTZWN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ3NlY3Rpb25FbmQnLCBvcHRpb25zLCB0aGlzKTtcbiAgICBpZiAoKyt0aGlzLmNvbHVtbiA+IHRoaXMuY29sdW1ucykge1xuICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5kb2N1bWVudC5jb250aW51ZU9uTmV3UGFnZSgpO1xuICAgICAgdGhpcy5jb2x1bW4gPSAxO1xuICAgICAgdGhpcy5zdGFydFkgPSB0aGlzLmRvY3VtZW50LnBhZ2UubWFyZ2lucy50b3A7XG4gICAgICB0aGlzLm1heFkgPSB0aGlzLmRvY3VtZW50LnBhZ2UubWF4WSgpO1xuICAgICAgdGhpcy5kb2N1bWVudC54ID0gdGhpcy5zdGFydFg7XG4gICAgICBpZiAodGhpcy5kb2N1bWVudC5fZmlsbENvbG9yKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQuZmlsbENvbG9yKC4uLnRoaXMuZG9jdW1lbnQuX2ZpbGxDb2xvcik7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ3BhZ2VCcmVhaycsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvY3VtZW50LnggKz0gdGhpcy5saW5lV2lkdGggKyB0aGlzLmNvbHVtbkdhcDtcbiAgICAgIHRoaXMuZG9jdW1lbnQueSA9IHRoaXMuc3RhcnRZO1xuICAgICAgdGhpcy5lbWl0KCdjb2x1bW5CcmVhaycsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3NlY3Rpb25TdGFydCcsIG9wdGlvbnMsIHRoaXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmNvbnN0IHtcbiAgbnVtYmVyXG59ID0gUERGT2JqZWN0O1xudmFyIFRleHRNaXhpbiA9IHtcbiAgaW5pdFRleHQoKSB7XG4gICAgdGhpcy5fbGluZSA9IHRoaXMuX2xpbmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5fbGluZUdhcCA9IDA7XG4gIH0sXG4gIGxpbmVHYXAoX2xpbmVHYXApIHtcbiAgICB0aGlzLl9saW5lR2FwID0gX2xpbmVHYXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1vdmVEb3duKGxpbmVzKSB7XG4gICAgaWYgKGxpbmVzID09IG51bGwpIHtcbiAgICAgIGxpbmVzID0gMTtcbiAgICB9XG4gICAgdGhpcy55ICs9IHRoaXMuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKiBsaW5lcyArIHRoaXMuX2xpbmVHYXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1vdmVVcChsaW5lcykge1xuICAgIGlmIChsaW5lcyA9PSBudWxsKSB7XG4gICAgICBsaW5lcyA9IDE7XG4gICAgfVxuICAgIHRoaXMueSAtPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpICogbGluZXMgKyB0aGlzLl9saW5lR2FwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfdGV4dCh0ZXh0LCB4LCB5LCBvcHRpb25zLCBsaW5lQ2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gdGhpcy5faW5pdE9wdGlvbnMoeCwgeSwgb3B0aW9ucyk7XG4gICAgdGV4dCA9IHRleHQgPT0gbnVsbCA/ICcnIDogYCR7dGV4dH1gO1xuICAgIGlmIChvcHRpb25zLndvcmRTcGFjaW5nKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHN7Mix9L2csICcgJyk7XG4gICAgfVxuICAgIGNvbnN0IGFkZFN0cnVjdHVyZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnN0cnVjdFBhcmVudCkge1xuICAgICAgICBvcHRpb25zLnN0cnVjdFBhcmVudC5hZGQodGhpcy5zdHJ1Y3Qob3B0aW9ucy5zdHJ1Y3RUeXBlIHx8ICdQJywgW3RoaXMubWFya1N0cnVjdHVyZUNvbnRlbnQob3B0aW9ucy5zdHJ1Y3RUeXBlIHx8ICdQJyldKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5yb3RhdGlvbiAhPT0gMCkge1xuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICB0aGlzLnJvdGF0ZSgtb3B0aW9ucy5yb3RhdGlvbiwge1xuICAgICAgICBvcmlnaW46IFt0aGlzLngsIHRoaXMueV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aWR0aCkge1xuICAgICAgbGV0IHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyO1xuICAgICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICAgIHdyYXBwZXIgPSBuZXcgTGluZVdyYXBwZXIodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHdyYXBwZXIub24oJ2xpbmUnLCBsaW5lQ2FsbGJhY2spO1xuICAgICAgICB3cmFwcGVyLm9uKCdmaXJzdExpbmUnLCBhZGRTdHJ1Y3R1cmUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fd3JhcHBlciA9IG9wdGlvbnMuY29udGludWVkID8gd3JhcHBlciA6IG51bGw7XG4gICAgICB0aGlzLl90ZXh0T3B0aW9ucyA9IG9wdGlvbnMuY29udGludWVkID8gb3B0aW9ucyA6IG51bGw7XG4gICAgICB3cmFwcGVyLndyYXAodGV4dCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dC5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgYWRkU3RydWN0dXJlKCk7XG4gICAgICAgIGxpbmVDYWxsYmFjayhsaW5lLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucm90YXRpb24gIT09IDApIHRoaXMucmVzdG9yZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB0ZXh0KHRleHQsIHgsIHksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dCh0ZXh0LCB4LCB5LCBvcHRpb25zLCB0aGlzLl9saW5lKTtcbiAgfSxcbiAgd2lkdGhPZlN0cmluZyhzdHJpbmcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgaG9yaXpvbnRhbFNjYWxpbmcgPSBvcHRpb25zLmhvcml6b250YWxTY2FsaW5nIHx8IDEwMDtcbiAgICByZXR1cm4gKHRoaXMuX2ZvbnQud2lkdGhPZlN0cmluZyhzdHJpbmcsIHRoaXMuX2ZvbnRTaXplLCBvcHRpb25zLmZlYXR1cmVzKSArIChvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgfHwgMCkgKiAoc3RyaW5nLmxlbmd0aCAtIDEpKSAqIGhvcml6b250YWxTY2FsaW5nIC8gMTAwO1xuICB9LFxuICBib3VuZHNPZlN0cmluZyhzdHJpbmcsIHgsIHksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5faW5pdE9wdGlvbnMoeCwgeSwgb3B0aW9ucyk7XG4gICAgKHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMpO1xuICAgIGNvbnN0IGxpbmVHYXAgPSBvcHRpb25zLmxpbmVHYXAgPz8gdGhpcy5fbGluZUdhcCA/PyAwO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpICsgbGluZUdhcDtcbiAgICBsZXQgY29udGVudFdpZHRoID0gMDtcbiAgICBzdHJpbmcgPSBTdHJpbmcoc3RyaW5nID8/ICcnKTtcbiAgICBpZiAob3B0aW9ucy53b3JkU3BhY2luZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIGxldCB3cmFwcGVyID0gbmV3IExpbmVXcmFwcGVyKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgd3JhcHBlci5vbignbGluZScsICh0ZXh0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgIHRoaXMueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgd29yZFNwYWNpbmcgPSBvcHRpb25zLndvcmRTcGFjaW5nID8/IDA7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU3BhY2luZyA9IG9wdGlvbnMuY2hhcmFjdGVyU3BhY2luZyA/PyAwO1xuICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuYWxpZ24gPT09ICdqdXN0aWZ5Jykge1xuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSB0ZXh0LnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGhpcy53aWR0aE9mU3RyaW5nKHRleHQucmVwbGFjZSgvXFxzKy9nLCAnJyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VXaWR0aCA9IHRoaXMud2lkdGhPZlN0cmluZygnICcpICsgY2hhcmFjdGVyU3BhY2luZztcbiAgICAgICAgICAgIHdvcmRTcGFjaW5nID0gTWF0aC5tYXgoMCwgKG9wdGlvbnMubGluZVdpZHRoIC0gdGV4dFdpZHRoKSAvIE1hdGgubWF4KDEsIHdvcmRzLmxlbmd0aCAtIDEpIC0gc3BhY2VXaWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KGNvbnRlbnRXaWR0aCwgb3B0aW9ucy50ZXh0V2lkdGggKyB3b3JkU3BhY2luZyAqIChvcHRpb25zLndvcmRDb3VudCAtIDEpICsgY2hhcmFjdGVyU3BhY2luZyAqICh0ZXh0Lmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3cmFwcGVyLndyYXAoc3RyaW5nLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgbGluZSBvZiBzdHJpbmcuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMud2lkdGhPZlN0cmluZyhsaW5lLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KGNvbnRlbnRXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbnRlbnRIZWlnaHQgPSB0aGlzLnkgLSB5O1xuICAgIGlmIChvcHRpb25zLmhlaWdodCkgY29udGVudEhlaWdodCA9IE1hdGgubWluKGNvbnRlbnRIZWlnaHQsIG9wdGlvbnMuaGVpZ2h0KTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgaWYgKG9wdGlvbnMucm90YXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoOiBjb250ZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogY29udGVudEhlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucm90YXRpb24gPT09IDkwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5IC0gY29udGVudFdpZHRoLFxuICAgICAgICB3aWR0aDogY29udGVudEhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiBjb250ZW50V2lkdGhcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnJvdGF0aW9uID09PSAxODApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBjb250ZW50V2lkdGgsXG4gICAgICAgIHk6IHkgLSBjb250ZW50SGVpZ2h0LFxuICAgICAgICB3aWR0aDogY29udGVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbnRlbnRIZWlnaHRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBjb250ZW50SGVpZ2h0LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogY29udGVudEhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiBjb250ZW50V2lkdGhcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNvcyA9IGNvc2luZShvcHRpb25zLnJvdGF0aW9uKTtcbiAgICBjb25zdCBzaW4gPSBzaW5lKG9wdGlvbnMucm90YXRpb24pO1xuICAgIGNvbnN0IHgxID0geDtcbiAgICBjb25zdCB5MSA9IHk7XG4gICAgY29uc3QgeDIgPSB4ICsgY29udGVudFdpZHRoICogY29zO1xuICAgIGNvbnN0IHkyID0geSAtIGNvbnRlbnRXaWR0aCAqIHNpbjtcbiAgICBjb25zdCB4MyA9IHggKyBjb250ZW50V2lkdGggKiBjb3MgKyBjb250ZW50SGVpZ2h0ICogc2luO1xuICAgIGNvbnN0IHkzID0geSAtIGNvbnRlbnRXaWR0aCAqIHNpbiArIGNvbnRlbnRIZWlnaHQgKiBjb3M7XG4gICAgY29uc3QgeDQgPSB4ICsgY29udGVudEhlaWdodCAqIHNpbjtcbiAgICBjb25zdCB5NCA9IHkgKyBjb250ZW50SGVpZ2h0ICogY29zO1xuICAgIGNvbnN0IHhNaW4gPSBNYXRoLm1pbih4MSwgeDIsIHgzLCB4NCk7XG4gICAgY29uc3QgeE1heCA9IE1hdGgubWF4KHgxLCB4MiwgeDMsIHg0KTtcbiAgICBjb25zdCB5TWluID0gTWF0aC5taW4oeTEsIHkyLCB5MywgeTQpO1xuICAgIGNvbnN0IHlNYXggPSBNYXRoLm1heCh5MSwgeTIsIHkzLCB5NCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhNaW4sXG4gICAgICB5OiB5TWluLFxuICAgICAgd2lkdGg6IHhNYXggLSB4TWluLFxuICAgICAgaGVpZ2h0OiB5TWF4IC0geU1pblxuICAgIH07XG4gIH0sXG4gIGhlaWdodE9mU3RyaW5nKHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9pbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBvcHRpb25zLmhlaWdodCA9IEluZmluaXR5O1xuICAgIGNvbnN0IGxpbmVHYXAgPSBvcHRpb25zLmxpbmVHYXAgfHwgdGhpcy5fbGluZUdhcCB8fCAwO1xuICAgIHRoaXMuX3RleHQodGV4dCwgdGhpcy54LCB0aGlzLnksIG9wdGlvbnMsICgpID0+IHtcbiAgICAgIHRoaXMueSArPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpICsgbGluZUdhcDtcbiAgICB9KTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnkgLSB5O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9LFxuICBsaXN0KGxpc3QsIHgsIHksIG9wdGlvbnMsIHdyYXBwZXIpIHtcbiAgICBvcHRpb25zID0gdGhpcy5faW5pdE9wdGlvbnMoeCwgeSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbGlzdFR5cGUgPSBvcHRpb25zLmxpc3RUeXBlIHx8ICdidWxsZXQnO1xuICAgIGNvbnN0IHVuaXQgPSBNYXRoLnJvdW5kKHRoaXMuX2ZvbnQuYXNjZW5kZXIgLyAxMDAwICogdGhpcy5fZm9udFNpemUpO1xuICAgIGNvbnN0IG1pZExpbmUgPSB1bml0IC8gMjtcbiAgICBjb25zdCByID0gb3B0aW9ucy5idWxsZXRSYWRpdXMgfHwgdW5pdCAvIDM7XG4gICAgY29uc3QgaW5kZW50ID0gb3B0aW9ucy50ZXh0SW5kZW50IHx8IChsaXN0VHlwZSA9PT0gJ2J1bGxldCcgPyByICogNSA6IHVuaXQgKiAyKTtcbiAgICBjb25zdCBpdGVtSW5kZW50ID0gb3B0aW9ucy5idWxsZXRJbmRlbnQgfHwgKGxpc3RUeXBlID09PSAnYnVsbGV0JyA/IHIgKiA4IDogdW5pdCAqIDIpO1xuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBsZXZlbHMgPSBbXTtcbiAgICBjb25zdCBudW1iZXJzID0gW107XG4gICAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgbGV0IG4gPSAxO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgZmxhdHRlbihpdGVtKTtcbiAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgICAgIGlmIChsaXN0VHlwZSAhPT0gJ2J1bGxldCcpIHtcbiAgICAgICAgICAgIG51bWJlcnMucHVzaChuKyspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZmxhdHRlbihsaXN0KTtcbiAgICBjb25zdCBsYWJlbCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICBzd2l0Y2ggKGxpc3RUeXBlKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcmVkJzpcbiAgICAgICAgICByZXR1cm4gYCR7bn0uYDtcbiAgICAgICAgY2FzZSAnbGV0dGVyZWQnOlxuICAgICAgICAgIHZhciBsZXR0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChuIC0gMSkgJSAyNiArIDY1KTtcbiAgICAgICAgICB2YXIgdGltZXMgPSBNYXRoLmZsb29yKChuIC0gMSkgLyAyNiArIDEpO1xuICAgICAgICAgIHZhciB0ZXh0ID0gQXJyYXkodGltZXMgKyAxKS5qb2luKGxldHRlcik7XG4gICAgICAgICAgcmV0dXJuIGAke3RleHR9LmA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkcmF3TGlzdEl0ZW0gPSBmdW5jdGlvbiAobGlzdEl0ZW0sIGkpIHtcbiAgICAgIHdyYXBwZXIgPSBuZXcgTGluZVdyYXBwZXIodGhpcywgb3B0aW9ucyk7XG4gICAgICB3cmFwcGVyLm9uKCdsaW5lJywgdGhpcy5fbGluZSk7XG4gICAgICBsZXZlbCA9IDE7XG4gICAgICB3cmFwcGVyLm9uY2UoJ2ZpcnN0TGluZScsICgpID0+IHtcbiAgICAgICAgbGV0IGl0ZW0sIGl0ZW1UeXBlLCBsYWJlbFR5cGUsIGJvZHlUeXBlO1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJ1Y3RQYXJlbnQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5zdHJ1Y3RUeXBlcykge1xuICAgICAgICAgICAgW2l0ZW1UeXBlLCBsYWJlbFR5cGUsIGJvZHlUeXBlXSA9IG9wdGlvbnMuc3RydWN0VHlwZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFtpdGVtVHlwZSwgbGFiZWxUeXBlLCBib2R5VHlwZV0gPSBbJ0xJJywgJ0xibCcsICdMQm9keSddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbVR5cGUpIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5zdHJ1Y3QoaXRlbVR5cGUpO1xuICAgICAgICAgIG9wdGlvbnMuc3RydWN0UGFyZW50LmFkZChpdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnN0cnVjdFBhcmVudCkge1xuICAgICAgICAgIGl0ZW0gPSBvcHRpb25zLnN0cnVjdFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbDtcbiAgICAgICAgaWYgKChsID0gbGV2ZWxzW2krK10pICE9PSBsZXZlbCkge1xuICAgICAgICAgIGNvbnN0IGRpZmYgPSBpdGVtSW5kZW50ICogKGwgLSBsZXZlbCk7XG4gICAgICAgICAgdGhpcy54ICs9IGRpZmY7XG4gICAgICAgICAgd3JhcHBlci5saW5lV2lkdGggLT0gZGlmZjtcbiAgICAgICAgICBsZXZlbCA9IGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gJiYgKGxhYmVsVHlwZSB8fCBib2R5VHlwZSkpIHtcbiAgICAgICAgICBpdGVtLmFkZCh0aGlzLnN0cnVjdChsYWJlbFR5cGUgfHwgYm9keVR5cGUsIFt0aGlzLm1hcmtTdHJ1Y3R1cmVDb250ZW50KGxhYmVsVHlwZSB8fCBib2R5VHlwZSldKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChsaXN0VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2J1bGxldCc6XG4gICAgICAgICAgICB0aGlzLmNpcmNsZSh0aGlzLnggLSBpbmRlbnQgKyByLCB0aGlzLnkgKyBtaWRMaW5lLCByKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbnVtYmVyZWQnOlxuICAgICAgICAgIGNhc2UgJ2xldHRlcmVkJzpcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gbGFiZWwobnVtYmVyc1tpIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnQodGV4dCwgdGhpcy54IC0gaW5kZW50LCB0aGlzLnksIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gJiYgbGFiZWxUeXBlICYmIGJvZHlUeXBlKSB7XG4gICAgICAgICAgaXRlbS5hZGQodGhpcy5zdHJ1Y3QoYm9keVR5cGUsIFt0aGlzLm1hcmtTdHJ1Y3R1cmVDb250ZW50KGJvZHlUeXBlKV0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtICE9PSBvcHRpb25zLnN0cnVjdFBhcmVudCkge1xuICAgICAgICAgIGl0ZW0uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd3JhcHBlci5vbignc2VjdGlvblN0YXJ0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBpbmRlbnQgKyBpdGVtSW5kZW50ICogKGxldmVsIC0gMSk7XG4gICAgICAgIHRoaXMueCArPSBwb3M7XG4gICAgICAgIHdyYXBwZXIubGluZVdpZHRoIC09IHBvcztcbiAgICAgIH0pO1xuICAgICAgd3JhcHBlci5vbignc2VjdGlvbkVuZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gaW5kZW50ICsgaXRlbUluZGVudCAqIChsZXZlbCAtIDEpO1xuICAgICAgICB0aGlzLnggLT0gcG9zO1xuICAgICAgICB3cmFwcGVyLmxpbmVXaWR0aCArPSBwb3M7XG4gICAgICB9KTtcbiAgICAgIHdyYXBwZXIud3JhcChsaXN0SXRlbSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkcmF3TGlzdEl0ZW0uY2FsbCh0aGlzLCBpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfaW5pdE9wdGlvbnMoKSB7XG4gICAgbGV0IHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSB4O1xuICAgICAgeCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLl90ZXh0T3B0aW9ucykge1xuICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX3RleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuX3RleHRPcHRpb25zW2tleV07XG4gICAgICAgIGlmIChrZXkgIT09ICdjb250aW51ZWQnKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgIH1cbiAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmxpbmVCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChyZXN1bHQud2lkdGggPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQud2lkdGggPSB0aGlzLnBhZ2Uud2lkdGggLSB0aGlzLnggLSB0aGlzLnBhZ2UubWFyZ2lucy5yaWdodDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC53aWR0aCA9IE1hdGgubWF4KHJlc3VsdC53aWR0aCwgMCk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0LmNvbHVtbnMpIHtcbiAgICAgIHJlc3VsdC5jb2x1bW5zID0gMDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5jb2x1bW5HYXAgPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmNvbHVtbkdhcCA9IDE4O1xuICAgIH1cbiAgICByZXN1bHQucm90YXRpb24gPSBOdW1iZXIob3B0aW9ucy5yb3RhdGlvbiA/PyAwKSAlIDM2MDtcbiAgICBpZiAocmVzdWx0LnJvdGF0aW9uIDwgMCkgcmVzdWx0LnJvdGF0aW9uICs9IDM2MDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBfbGluZSh0ZXh0KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCB3cmFwcGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJhZ21lbnQodGV4dCwgdGhpcy54LCB0aGlzLnksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpbmVHYXAgPSBvcHRpb25zLmxpbmVHYXAgfHwgdGhpcy5fbGluZUdhcCB8fCAwO1xuICAgIGlmICghd3JhcHBlcikge1xuICAgICAgdGhpcy54ICs9IHRoaXMud2lkdGhPZlN0cmluZyh0ZXh0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55ICs9IHRoaXMuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKyBsaW5lR2FwO1xuICAgIH1cbiAgfSxcbiAgX2ZyYWdtZW50KHRleHQsIHgsIHksIG9wdGlvbnMpIHtcbiAgICBsZXQgZHksIGVuY29kZWQsIGksIHBvc2l0aW9ucywgdGV4dFdpZHRoLCB3b3JkcztcbiAgICB0ZXh0ID0gYCR7dGV4dH1gLnJlcGxhY2UoL1xcbi9nLCAnJyk7XG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbiB8fCAnbGVmdCc7XG4gICAgbGV0IHdvcmRTcGFjaW5nID0gb3B0aW9ucy53b3JkU3BhY2luZyB8fCAwO1xuICAgIGNvbnN0IGNoYXJhY3RlclNwYWNpbmcgPSBvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgfHwgMDtcbiAgICBjb25zdCBob3Jpem9udGFsU2NhbGluZyA9IG9wdGlvbnMuaG9yaXpvbnRhbFNjYWxpbmcgfHwgMTAwO1xuICAgIGlmIChvcHRpb25zLndpZHRoKSB7XG4gICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLndpZHRoT2ZTdHJpbmcodGV4dC5yZXBsYWNlKC9cXHMrJC8sICcnKSwgb3B0aW9ucyk7XG4gICAgICAgICAgeCArPSBvcHRpb25zLmxpbmVXaWR0aCAtIHRleHRXaWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICB4ICs9IG9wdGlvbnMubGluZVdpZHRoIC8gMiAtIG9wdGlvbnMudGV4dFdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnanVzdGlmeSc6XG4gICAgICAgICAgd29yZHMgPSB0ZXh0LnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMud2lkdGhPZlN0cmluZyh0ZXh0LnJlcGxhY2UoL1xccysvZywgJycpLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgc3BhY2VXaWR0aCA9IHRoaXMud2lkdGhPZlN0cmluZygnICcpICsgY2hhcmFjdGVyU3BhY2luZztcbiAgICAgICAgICB3b3JkU3BhY2luZyA9IE1hdGgubWF4KDAsIChvcHRpb25zLmxpbmVXaWR0aCAtIHRleHRXaWR0aCkgLyBNYXRoLm1heCgxLCB3b3Jkcy5sZW5ndGggLSAxKSAtIHNwYWNlV2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZWxpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICBkeSA9IC1vcHRpb25zLmJhc2VsaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnc3ZnLW1pZGRsZSc6XG4gICAgICAgICAgZHkgPSAwLjUgKiB0aGlzLl9mb250LnhIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIGNhc2UgJ3N2Zy1jZW50cmFsJzpcbiAgICAgICAgICBkeSA9IDAuNSAqICh0aGlzLl9mb250LmRlc2NlbmRlciArIHRoaXMuX2ZvbnQuYXNjZW5kZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgICAgICAgZHkgPSB0aGlzLl9mb250LmRlc2NlbmRlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXRoZW1hdGljYWwnOlxuICAgICAgICAgIGR5ID0gMC41ICogdGhpcy5fZm9udC5hc2NlbmRlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGFuZ2luZyc6XG4gICAgICAgICAgZHkgPSAwLjggKiB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGR5ID0gdGhpcy5fZm9udC5hc2NlbmRlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkeSA9IHRoaXMuX2ZvbnQuYXNjZW5kZXI7XG4gICAgICB9XG4gICAgICBkeSA9IGR5IC8gMTAwMCAqIHRoaXMuX2ZvbnRTaXplO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJlZFdpZHRoID0gb3B0aW9ucy50ZXh0V2lkdGggKyB3b3JkU3BhY2luZyAqIChvcHRpb25zLndvcmRDb3VudCAtIDEpICsgY2hhcmFjdGVyU3BhY2luZyAqICh0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgIGlmIChvcHRpb25zLmxpbmsgIT0gbnVsbCkge1xuICAgICAgdGhpcy5saW5rKHgsIHksIHJlbmRlcmVkV2lkdGgsIHRoaXMuY3VycmVudExpbmVIZWlnaHQoKSwgb3B0aW9ucy5saW5rKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZ29UbyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmdvVG8oeCwgeSwgcmVuZGVyZWRXaWR0aCwgdGhpcy5jdXJyZW50TGluZUhlaWdodCgpLCBvcHRpb25zLmdvVG8pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kZXN0aW5hdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFkZE5hbWVkRGVzdGluYXRpb24ob3B0aW9ucy5kZXN0aW5hdGlvbiwgJ1hZWicsIHgsIHksIG51bGwpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51bmRlcmxpbmUpIHtcbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgaWYgKCFvcHRpb25zLnN0cm9rZSkge1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yKC4uLih0aGlzLl9maWxsQ29sb3IgfHwgW10pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMuX2ZvbnRTaXplIDwgMTAgPyAwLjUgOiBNYXRoLmZsb29yKHRoaXMuX2ZvbnRTaXplIC8gMTApO1xuICAgICAgdGhpcy5saW5lV2lkdGgobGluZVdpZHRoKTtcbiAgICAgIGxldCBsaW5lWSA9IHkgKyB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KCkgLSBsaW5lV2lkdGg7XG4gICAgICB0aGlzLm1vdmVUbyh4LCBsaW5lWSk7XG4gICAgICB0aGlzLmxpbmVUbyh4ICsgcmVuZGVyZWRXaWR0aCwgbGluZVkpO1xuICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHJpa2UpIHtcbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgaWYgKCFvcHRpb25zLnN0cm9rZSkge1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yKC4uLih0aGlzLl9maWxsQ29sb3IgfHwgW10pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRoaXMuX2ZvbnRTaXplIDwgMTAgPyAwLjUgOiBNYXRoLmZsb29yKHRoaXMuX2ZvbnRTaXplIC8gMTApO1xuICAgICAgdGhpcy5saW5lV2lkdGgobGluZVdpZHRoKTtcbiAgICAgIGxldCBsaW5lWSA9IHkgKyB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KCkgLyAyO1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgbGluZVkpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHJlbmRlcmVkV2lkdGgsIGxpbmVZKTtcbiAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKG9wdGlvbnMub2JsaXF1ZSkge1xuICAgICAgbGV0IHNrZXc7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMub2JsaXF1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2tldyA9IC1NYXRoLnRhbihvcHRpb25zLm9ibGlxdWUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNrZXcgPSAtMC4yNTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHgsIHkpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oMSwgMCwgc2tldywgMSwgLXNrZXcgKiBkeSwgMCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAxLCAteCwgLXkpO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgdGhpcy5wYWdlLmhlaWdodCk7XG4gICAgeSA9IHRoaXMucGFnZS5oZWlnaHQgLSB5IC0gZHk7XG4gICAgaWYgKHRoaXMucGFnZS5mb250c1t0aGlzLl9mb250LmlkXSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2UuZm9udHNbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgIH1cbiAgICB0aGlzLmFkZENvbnRlbnQoJ0JUJyk7XG4gICAgdGhpcy5hZGRDb250ZW50KGAxIDAgMCAxICR7bnVtYmVyKHgpfSAke251bWJlcih5KX0gVG1gKTtcbiAgICB0aGlzLmFkZENvbnRlbnQoYC8ke3RoaXMuX2ZvbnQuaWR9ICR7bnVtYmVyKHRoaXMuX2ZvbnRTaXplKX0gVGZgKTtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5maWxsICYmIG9wdGlvbnMuc3Ryb2tlID8gMiA6IG9wdGlvbnMuc3Ryb2tlID8gMSA6IDA7XG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIHRoaXMuYWRkQ29udGVudChgJHttb2RlfSBUcmApO1xuICAgIH1cbiAgICBpZiAoY2hhcmFjdGVyU3BhY2luZykge1xuICAgICAgdGhpcy5hZGRDb250ZW50KGAke251bWJlcihjaGFyYWN0ZXJTcGFjaW5nKX0gVGNgKTtcbiAgICB9XG4gICAgaWYgKGhvcml6b250YWxTY2FsaW5nICE9PSAxMDApIHtcbiAgICAgIHRoaXMuYWRkQ29udGVudChgJHtob3Jpem9udGFsU2NhbGluZ30gVHpgKTtcbiAgICB9XG4gICAgaWYgKHdvcmRTcGFjaW5nKSB7XG4gICAgICB3b3JkcyA9IHRleHQudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICB3b3JkU3BhY2luZyArPSB0aGlzLndpZHRoT2ZTdHJpbmcoJyAnKSArIGNoYXJhY3RlclNwYWNpbmc7XG4gICAgICB3b3JkU3BhY2luZyAqPSAxMDAwIC8gdGhpcy5fZm9udFNpemU7XG4gICAgICBlbmNvZGVkID0gW107XG4gICAgICBwb3NpdGlvbnMgPSBbXTtcbiAgICAgIGZvciAobGV0IHdvcmQgb2Ygd29yZHMpIHtcbiAgICAgICAgY29uc3QgW2VuY29kZWRXb3JkLCBwb3NpdGlvbnNXb3JkXSA9IHRoaXMuX2ZvbnQuZW5jb2RlKHdvcmQsIG9wdGlvbnMuZmVhdHVyZXMpO1xuICAgICAgICBlbmNvZGVkID0gZW5jb2RlZC5jb25jYXQoZW5jb2RlZFdvcmQpO1xuICAgICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuY29uY2F0KHBvc2l0aW9uc1dvcmQpO1xuICAgICAgICBjb25zdCBzcGFjZSA9IHt9O1xuICAgICAgICBjb25zdCBvYmplY3QgPSBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgc3BhY2Vba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBzcGFjZS54QWR2YW5jZSArPSB3b3JkU3BhY2luZztcbiAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSA9IHNwYWNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBbZW5jb2RlZCwgcG9zaXRpb25zXSA9IHRoaXMuX2ZvbnQuZW5jb2RlKHRleHQsIG9wdGlvbnMuZmVhdHVyZXMpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2ZvbnRTaXplIC8gMTAwMDtcbiAgICBjb25zdCBjb21tYW5kcyA9IFtdO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICBsZXQgaGFkT2Zmc2V0ID0gZmFsc2U7XG4gICAgY29uc3QgYWRkU2VnbWVudCA9IGN1ciA9PiB7XG4gICAgICBpZiAobGFzdCA8IGN1cikge1xuICAgICAgICBjb25zdCBoZXggPSBlbmNvZGVkLnNsaWNlKGxhc3QsIGN1cikuam9pbignJyk7XG4gICAgICAgIGNvbnN0IGFkdmFuY2UgPSBwb3NpdGlvbnNbY3VyIC0gMV0ueEFkdmFuY2UgLSBwb3NpdGlvbnNbY3VyIC0gMV0uYWR2YW5jZVdpZHRoO1xuICAgICAgICBjb21tYW5kcy5wdXNoKGA8JHtoZXh9PiAke251bWJlcigtYWR2YW5jZSl9YCk7XG4gICAgICB9XG4gICAgICBsYXN0ID0gY3VyO1xuICAgIH07XG4gICAgY29uc3QgZmx1c2ggPSBpID0+IHtcbiAgICAgIGFkZFNlZ21lbnQoaSk7XG4gICAgICBpZiAoY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmFkZENvbnRlbnQoYFske2NvbW1hbmRzLmpvaW4oJyAnKX1dIFRKYCk7XG4gICAgICAgIGNvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgICBpZiAocG9zLnhPZmZzZXQgfHwgcG9zLnlPZmZzZXQpIHtcbiAgICAgICAgZmx1c2goaSk7XG4gICAgICAgIHRoaXMuYWRkQ29udGVudChgMSAwIDAgMSAke251bWJlcih4ICsgcG9zLnhPZmZzZXQgKiBzY2FsZSl9ICR7bnVtYmVyKHkgKyBwb3MueU9mZnNldCAqIHNjYWxlKX0gVG1gKTtcbiAgICAgICAgZmx1c2goaSArIDEpO1xuICAgICAgICBoYWRPZmZzZXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhhZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYWRkQ29udGVudChgMSAwIDAgMSAke251bWJlcih4KX0gJHtudW1iZXIoeSl9IFRtYCk7XG4gICAgICAgICAgaGFkT2Zmc2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcy54QWR2YW5jZSAtIHBvcy5hZHZhbmNlV2lkdGggIT09IDApIHtcbiAgICAgICAgICBhZGRTZWdtZW50KGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeCArPSBwb3MueEFkdmFuY2UgKiBzY2FsZTtcbiAgICB9XG4gICAgZmx1c2goaSk7XG4gICAgdGhpcy5hZGRDb250ZW50KCdFVCcpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG59O1xuXG5jb25zdCBNQVJLRVJTID0gWzB4ZmZjMCwgMHhmZmMxLCAweGZmYzIsIDB4ZmZjMywgMHhmZmM1LCAweGZmYzYsIDB4ZmZjNywgMHhmZmM4LCAweGZmYzksIDB4ZmZjYSwgMHhmZmNiLCAweGZmY2MsIDB4ZmZjZCwgMHhmZmNlLCAweGZmY2ZdO1xuY29uc3QgQ09MT1JfU1BBQ0VfTUFQID0ge1xuICAxOiAnRGV2aWNlR3JheScsXG4gIDM6ICdEZXZpY2VSR0InLFxuICA0OiAnRGV2aWNlQ01ZSydcbn07XG5jbGFzcyBKUEVHIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgbGFiZWwpIHtcbiAgICBsZXQgbWFya2VyO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIGlmICh0aGlzLmRhdGEucmVhZFVJbnQxNkJFKDApICE9PSAweGZmZDgpIHtcbiAgICAgIHRocm93ICdTT0kgbm90IGZvdW5kIGluIEpQRUcnO1xuICAgIH1cbiAgICB0aGlzLm9yaWVudGF0aW9uID0gZXhpZi5mcm9tQnVmZmVyKHRoaXMuZGF0YSkuT3JpZW50YXRpb24gfHwgMTtcbiAgICBsZXQgcG9zID0gMjtcbiAgICB3aGlsZSAocG9zIDwgdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgbWFya2VyID0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBpZiAoTUFSS0VSUy5pbmNsdWRlcyhtYXJrZXIpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcG9zICs9IHRoaXMuZGF0YS5yZWFkVUludDE2QkUocG9zKTtcbiAgICB9XG4gICAgaWYgKCFNQVJLRVJTLmluY2x1ZGVzKG1hcmtlcikpIHtcbiAgICAgIHRocm93ICdJbnZhbGlkIEpQRUcuJztcbiAgICB9XG4gICAgcG9zICs9IDI7XG4gICAgdGhpcy5iaXRzID0gdGhpcy5kYXRhW3BvcysrXTtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuZGF0YS5yZWFkVUludDE2QkUocG9zKTtcbiAgICBwb3MgKz0gMjtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgIHBvcyArPSAyO1xuICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5kYXRhW3BvcysrXTtcbiAgICB0aGlzLmNvbG9yU3BhY2UgPSBDT0xPUl9TUEFDRV9NQVBbY2hhbm5lbHNdO1xuICAgIHRoaXMub2JqID0gbnVsbDtcbiAgfVxuICBlbWJlZChkb2N1bWVudCkge1xuICAgIGlmICh0aGlzLm9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9iaiA9IGRvY3VtZW50LnJlZih7XG4gICAgICBUeXBlOiAnWE9iamVjdCcsXG4gICAgICBTdWJ0eXBlOiAnSW1hZ2UnLFxuICAgICAgQml0c1BlckNvbXBvbmVudDogdGhpcy5iaXRzLFxuICAgICAgV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBIZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgQ29sb3JTcGFjZTogdGhpcy5jb2xvclNwYWNlLFxuICAgICAgRmlsdGVyOiAnRENURGVjb2RlJ1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmNvbG9yU3BhY2UgPT09ICdEZXZpY2VDTVlLJykge1xuICAgICAgdGhpcy5vYmouZGF0YVsnRGVjb2RlJ10gPSBbMS4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDAuMCwgMS4wLCAwLjBdO1xuICAgIH1cbiAgICB0aGlzLm9iai5lbmQodGhpcy5kYXRhKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxufVxuXG5jbGFzcyBQTkdJbWFnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGxhYmVsKSB7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMuaW1hZ2UgPSBuZXcgUE5HKGRhdGEpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmltYWdlLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5pbWFnZS5oZWlnaHQ7XG4gICAgdGhpcy5pbWdEYXRhID0gdGhpcy5pbWFnZS5pbWdEYXRhO1xuICAgIHRoaXMub2JqID0gbnVsbDtcbiAgfVxuICBlbWJlZChkb2N1bWVudCkge1xuICAgIGxldCBkYXRhRGVjb2RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICBpZiAodGhpcy5vYmopIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFzQWxwaGFDaGFubmVsID0gdGhpcy5pbWFnZS5oYXNBbHBoYUNoYW5uZWw7XG4gICAgY29uc3QgaXNJbnRlcmxhY2VkID0gdGhpcy5pbWFnZS5pbnRlcmxhY2VNZXRob2QgPT09IDE7XG4gICAgdGhpcy5vYmogPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICBUeXBlOiAnWE9iamVjdCcsXG4gICAgICBTdWJ0eXBlOiAnSW1hZ2UnLFxuICAgICAgQml0c1BlckNvbXBvbmVudDogaGFzQWxwaGFDaGFubmVsID8gOCA6IHRoaXMuaW1hZ2UuYml0cyxcbiAgICAgIFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgSGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIEZpbHRlcjogJ0ZsYXRlRGVjb2RlJ1xuICAgIH0pO1xuICAgIGlmICghaGFzQWxwaGFDaGFubmVsKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICAgIFByZWRpY3RvcjogaXNJbnRlcmxhY2VkID8gMSA6IDE1LFxuICAgICAgICBDb2xvcnM6IHRoaXMuaW1hZ2UuY29sb3JzLFxuICAgICAgICBCaXRzUGVyQ29tcG9uZW50OiB0aGlzLmltYWdlLmJpdHMsXG4gICAgICAgIENvbHVtbnM6IHRoaXMud2lkdGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vYmouZGF0YVsnRGVjb2RlUGFybXMnXSA9IHBhcmFtcztcbiAgICAgIHBhcmFtcy5lbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2UucGFsZXR0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub2JqLmRhdGFbJ0NvbG9yU3BhY2UnXSA9IHRoaXMuaW1hZ2UuY29sb3JTcGFjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFsZXR0ZSA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gICAgICBwYWxldHRlLmVuZChCdWZmZXIuZnJvbSh0aGlzLmltYWdlLnBhbGV0dGUpKTtcbiAgICAgIHRoaXMub2JqLmRhdGFbJ0NvbG9yU3BhY2UnXSA9IFsnSW5kZXhlZCcsICdEZXZpY2VSR0InLCB0aGlzLmltYWdlLnBhbGV0dGUubGVuZ3RoIC8gMyAtIDEsIHBhbGV0dGVdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuZ3JheXNjYWxlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMuaW1hZ2UudHJhbnNwYXJlbmN5LmdyYXlzY2FsZTtcbiAgICAgIHRoaXMub2JqLmRhdGFbJ01hc2snXSA9IFt2YWwsIHZhbF07XG4gICAgfSBlbHNlIGlmICh0aGlzLmltYWdlLnRyYW5zcGFyZW5jeS5yZ2IpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmdiXG4gICAgICB9ID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3k7XG4gICAgICBjb25zdCBtYXNrID0gW107XG4gICAgICBmb3IgKGxldCB4IG9mIHJnYikge1xuICAgICAgICBtYXNrLnB1c2goeCwgeCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9iai5kYXRhWydNYXNrJ10gPSBtYXNrO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuaW5kZXhlZCkge1xuICAgICAgZGF0YURlY29kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMubG9hZEluZGV4ZWRBbHBoYUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGhhc0FscGhhQ2hhbm5lbCkge1xuICAgICAgZGF0YURlY29kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaXRBbHBoYUNoYW5uZWwoKTtcbiAgICB9XG4gICAgaWYgKGlzSW50ZXJsYWNlZCAmJiAhZGF0YURlY29kZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZURhdGEoKTtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICB9XG4gIGZpbmFsaXplKCkge1xuICAgIGlmICh0aGlzLmFscGhhQ2hhbm5lbCkge1xuICAgICAgY29uc3Qgc01hc2sgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICAgIFR5cGU6ICdYT2JqZWN0JyxcbiAgICAgICAgU3VidHlwZTogJ0ltYWdlJyxcbiAgICAgICAgSGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIEJpdHNQZXJDb21wb25lbnQ6IDgsXG4gICAgICAgIEZpbHRlcjogJ0ZsYXRlRGVjb2RlJyxcbiAgICAgICAgQ29sb3JTcGFjZTogJ0RldmljZUdyYXknLFxuICAgICAgICBEZWNvZGU6IFswLCAxXVxuICAgICAgfSk7XG4gICAgICBzTWFzay5lbmQodGhpcy5hbHBoYUNoYW5uZWwpO1xuICAgICAgdGhpcy5vYmouZGF0YVsnU01hc2snXSA9IHNNYXNrO1xuICAgIH1cbiAgICB0aGlzLm9iai5lbmQodGhpcy5pbWdEYXRhKTtcbiAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5pbWdEYXRhID0gbnVsbDtcbiAgfVxuICBzcGxpdEFscGhhQ2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZS5kZWNvZGVQaXhlbHMocGl4ZWxzID0+IHtcbiAgICAgIGxldCBhLCBwO1xuICAgICAgY29uc3QgY29sb3JDb3VudCA9IHRoaXMuaW1hZ2UuY29sb3JzO1xuICAgICAgY29uc3QgcGl4ZWxDb3VudCA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICAgIGNvbnN0IGltZ0RhdGEgPSBCdWZmZXIuYWxsb2MocGl4ZWxDb3VudCAqIGNvbG9yQ291bnQpO1xuICAgICAgY29uc3QgYWxwaGFDaGFubmVsID0gQnVmZmVyLmFsbG9jKHBpeGVsQ291bnQpO1xuICAgICAgbGV0IGkgPSBwID0gYSA9IDA7XG4gICAgICBjb25zdCBsZW4gPSBwaXhlbHMubGVuZ3RoO1xuICAgICAgY29uc3Qgc2tpcEJ5dGVDb3VudCA9IHRoaXMuaW1hZ2UuYml0cyA9PT0gMTYgPyAxIDogMDtcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGZvciAobGV0IGNvbG9ySW5kZXggPSAwOyBjb2xvckluZGV4IDwgY29sb3JDb3VudDsgY29sb3JJbmRleCsrKSB7XG4gICAgICAgICAgaW1nRGF0YVtwKytdID0gcGl4ZWxzW2krK107XG4gICAgICAgICAgaSArPSBza2lwQnl0ZUNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGFscGhhQ2hhbm5lbFthKytdID0gcGl4ZWxzW2krK107XG4gICAgICAgIGkgKz0gc2tpcEJ5dGVDb3VudDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1nRGF0YSA9IHpsaWIuZGVmbGF0ZVN5bmMoaW1nRGF0YSk7XG4gICAgICB0aGlzLmFscGhhQ2hhbm5lbCA9IHpsaWIuZGVmbGF0ZVN5bmMoYWxwaGFDaGFubmVsKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZEluZGV4ZWRBbHBoYUNoYW5uZWwoKSB7XG4gICAgY29uc3QgdHJhbnNwYXJlbmN5ID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuaW5kZXhlZDtcbiAgICByZXR1cm4gdGhpcy5pbWFnZS5kZWNvZGVQaXhlbHMocGl4ZWxzID0+IHtcbiAgICAgIGNvbnN0IGFscGhhQ2hhbm5lbCA9IEJ1ZmZlci5hbGxvYyh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGVuZCA9IHBpeGVscy5sZW5ndGg7IGogPCBlbmQ7IGorKykge1xuICAgICAgICBhbHBoYUNoYW5uZWxbaSsrXSA9IHRyYW5zcGFyZW5jeVtwaXhlbHNbal1dO1xuICAgICAgfVxuICAgICAgdGhpcy5hbHBoYUNoYW5uZWwgPSB6bGliLmRlZmxhdGVTeW5jKGFscGhhQ2hhbm5lbCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpO1xuICAgIH0pO1xuICB9XG4gIGRlY29kZURhdGEoKSB7XG4gICAgdGhpcy5pbWFnZS5kZWNvZGVQaXhlbHMocGl4ZWxzID0+IHtcbiAgICAgIHRoaXMuaW1nRGF0YSA9IHpsaWIuZGVmbGF0ZVN5bmMocGl4ZWxzKTtcbiAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBQREZJbWFnZSB7XG4gIHN0YXRpYyBvcGVuKHNyYywgbGFiZWwpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNyYykpIHtcbiAgICAgIGRhdGEgPSBzcmM7XG4gICAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNyYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXRjaCA9IC9eZGF0YTouKz87YmFzZTY0LCguKikkLy5leGVjKHNyYyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG1hdGNoWzFdLCAnYmFzZTY0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YVswXSA9PT0gMHhmZiAmJiBkYXRhWzFdID09PSAweGQ4KSB7XG4gICAgICByZXR1cm4gbmV3IEpQRUcoZGF0YSwgbGFiZWwpO1xuICAgIH0gZWxzZSBpZiAoZGF0YVswXSA9PT0gMHg4OSAmJiBkYXRhLnRvU3RyaW5nKCdhc2NpaScsIDEsIDQpID09PSAnUE5HJykge1xuICAgICAgcmV0dXJuIG5ldyBQTkdJbWFnZShkYXRhLCBsYWJlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbWFnZSBmb3JtYXQuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBJbWFnZXNNaXhpbiA9IHtcbiAgaW5pdEltYWdlcygpIHtcbiAgICB0aGlzLl9pbWFnZVJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5faW1hZ2VDb3VudCA9IDA7XG4gIH0sXG4gIGltYWdlKHNyYywgeCwgeSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBsZXQgYmgsIGJwLCBidywgaW1hZ2UsIGlwLCBsZWZ0LCBsZWZ0MSwgb3JpZ2luWCwgb3JpZ2luWTtcbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0geDtcbiAgICAgIHggPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpZ25vcmVPcmllbnRhdGlvbiA9IG9wdGlvbnMuaWdub3JlT3JpZW50YXRpb24gfHwgb3B0aW9ucy5pZ25vcmVPcmllbnRhdGlvbiAhPT0gZmFsc2UgJiYgdGhpcy5vcHRpb25zLmlnbm9yZU9yaWVudGF0aW9uO1xuICAgIGNvbnN0IGluRG9jdW1lbnRGbG93ID0gdHlwZW9mIHkgIT09ICdudW1iZXInO1xuICAgIHggPSAobGVmdCA9IHggIT0gbnVsbCA/IHggOiBvcHRpb25zLngpICE9IG51bGwgPyBsZWZ0IDogdGhpcy54O1xuICAgIHkgPSAobGVmdDEgPSB5ICE9IG51bGwgPyB5IDogb3B0aW9ucy55KSAhPSBudWxsID8gbGVmdDEgOiB0aGlzLnk7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbWFnZSA9IHRoaXMuX2ltYWdlUmVnaXN0cnlbc3JjXTtcbiAgICB9XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgaWYgKHNyYy53aWR0aCAmJiBzcmMuaGVpZ2h0KSB7XG4gICAgICAgIGltYWdlID0gc3JjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2UgPSB0aGlzLm9wZW5JbWFnZShzcmMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWltYWdlLm9iaikge1xuICAgICAgaW1hZ2UuZW1iZWQodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhZ2UueG9iamVjdHNbaW1hZ2UubGFiZWxdID09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZS54b2JqZWN0c1tpbWFnZS5sYWJlbF0gPSBpbWFnZS5vYmo7XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWFnZTtcbiAgICBpZiAoIWlnbm9yZU9yaWVudGF0aW9uICYmIGltYWdlLm9yaWVudGF0aW9uID4gNCkge1xuICAgICAgW3dpZHRoLCBoZWlnaHRdID0gW2hlaWdodCwgd2lkdGhdO1xuICAgIH1cbiAgICBsZXQgdyA9IG9wdGlvbnMud2lkdGggfHwgd2lkdGg7XG4gICAgbGV0IGggPSBvcHRpb25zLmhlaWdodCB8fCBoZWlnaHQ7XG4gICAgaWYgKG9wdGlvbnMud2lkdGggJiYgIW9wdGlvbnMuaGVpZ2h0KSB7XG4gICAgICBjb25zdCB3cCA9IHcgLyB3aWR0aDtcbiAgICAgIHcgPSB3aWR0aCAqIHdwO1xuICAgICAgaCA9IGhlaWdodCAqIHdwO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgJiYgIW9wdGlvbnMud2lkdGgpIHtcbiAgICAgIGNvbnN0IGhwID0gaCAvIGhlaWdodDtcbiAgICAgIHcgPSB3aWR0aCAqIGhwO1xuICAgICAgaCA9IGhlaWdodCAqIGhwO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zY2FsZSkge1xuICAgICAgdyA9IHdpZHRoICogb3B0aW9ucy5zY2FsZTtcbiAgICAgIGggPSBoZWlnaHQgKiBvcHRpb25zLnNjYWxlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgIFtidywgYmhdID0gb3B0aW9ucy5maXQ7XG4gICAgICBicCA9IGJ3IC8gYmg7XG4gICAgICBpcCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKGlwID4gYnApIHtcbiAgICAgICAgdyA9IGJ3O1xuICAgICAgICBoID0gYncgLyBpcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSBiaDtcbiAgICAgICAgdyA9IGJoICogaXA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNvdmVyKSB7XG4gICAgICBbYncsIGJoXSA9IG9wdGlvbnMuY292ZXI7XG4gICAgICBicCA9IGJ3IC8gYmg7XG4gICAgICBpcCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKGlwID4gYnApIHtcbiAgICAgICAgaCA9IGJoO1xuICAgICAgICB3ID0gYmggKiBpcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcgPSBidztcbiAgICAgICAgaCA9IGJ3IC8gaXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpdCB8fCBvcHRpb25zLmNvdmVyKSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9IHggKyBidyAvIDIgLSB3IC8gMjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4ID0geCArIGJ3IC0gdztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnZhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9IHkgKyBiaCAvIDIgLSBoIC8gMjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHkgPSB5ICsgYmggLSBoO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcm90YXRlQW5nbGUgPSAwO1xuICAgIGxldCB4VHJhbnNmb3JtID0geDtcbiAgICBsZXQgeVRyYW5zZm9ybSA9IHk7XG4gICAgbGV0IGhUcmFuc2Zvcm0gPSBoO1xuICAgIGxldCB3VHJhbnNmb3JtID0gdztcbiAgICBpZiAoIWlnbm9yZU9yaWVudGF0aW9uKSB7XG4gICAgICBzd2l0Y2ggKGltYWdlLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBoVHJhbnNmb3JtID0gLWg7XG4gICAgICAgICAgeVRyYW5zZm9ybSArPSBoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgd1RyYW5zZm9ybSA9IC13O1xuICAgICAgICAgIGhUcmFuc2Zvcm0gPSAtaDtcbiAgICAgICAgICB4VHJhbnNmb3JtICs9IHc7XG4gICAgICAgICAgeVRyYW5zZm9ybSArPSBoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgb3JpZ2luWCA9IHg7XG4gICAgICAgICAgb3JpZ2luWSA9IHk7XG4gICAgICAgICAgaFRyYW5zZm9ybSA9IC1oO1xuICAgICAgICAgIHhUcmFuc2Zvcm0gLT0gdztcbiAgICAgICAgICByb3RhdGVBbmdsZSA9IDE4MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgb3JpZ2luWCA9IHg7XG4gICAgICAgICAgb3JpZ2luWSA9IHk7XG4gICAgICAgICAgd1RyYW5zZm9ybSA9IGg7XG4gICAgICAgICAgaFRyYW5zZm9ybSA9IHc7XG4gICAgICAgICAgeVRyYW5zZm9ybSAtPSBoVHJhbnNmb3JtO1xuICAgICAgICAgIHJvdGF0ZUFuZ2xlID0gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBvcmlnaW5YID0geDtcbiAgICAgICAgICBvcmlnaW5ZID0geTtcbiAgICAgICAgICB3VHJhbnNmb3JtID0gaDtcbiAgICAgICAgICBoVHJhbnNmb3JtID0gLXc7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIG9yaWdpblggPSB4O1xuICAgICAgICAgIG9yaWdpblkgPSB5O1xuICAgICAgICAgIGhUcmFuc2Zvcm0gPSAtdztcbiAgICAgICAgICB3VHJhbnNmb3JtID0gLWg7XG4gICAgICAgICAgeFRyYW5zZm9ybSArPSBoO1xuICAgICAgICAgIHJvdGF0ZUFuZ2xlID0gOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBvcmlnaW5YID0geDtcbiAgICAgICAgICBvcmlnaW5ZID0geTtcbiAgICAgICAgICB3VHJhbnNmb3JtID0gaDtcbiAgICAgICAgICBoVHJhbnNmb3JtID0gLXc7XG4gICAgICAgICAgeFRyYW5zZm9ybSAtPSBoO1xuICAgICAgICAgIHlUcmFuc2Zvcm0gKz0gdztcbiAgICAgICAgICByb3RhdGVBbmdsZSA9IC05MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaFRyYW5zZm9ybSA9IC1oO1xuICAgICAgeVRyYW5zZm9ybSArPSBoO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW5rICE9IG51bGwpIHtcbiAgICAgIHRoaXMubGluayh4LCB5LCB3LCBoLCBvcHRpb25zLmxpbmspO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5nb1RvICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZ29Ubyh4LCB5LCB3LCBoLCBvcHRpb25zLmdvVG8pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kZXN0aW5hdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFkZE5hbWVkRGVzdGluYXRpb24ob3B0aW9ucy5kZXN0aW5hdGlvbiwgJ1hZWicsIHgsIHksIG51bGwpO1xuICAgIH1cbiAgICBpZiAoaW5Eb2N1bWVudEZsb3cpIHtcbiAgICAgIHRoaXMueSArPSBoO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAocm90YXRlQW5nbGUpIHtcbiAgICAgIHRoaXMucm90YXRlKHJvdGF0ZUFuZ2xlLCB7XG4gICAgICAgIG9yaWdpbjogW29yaWdpblgsIG9yaWdpblldXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm0od1RyYW5zZm9ybSwgMCwgMCwgaFRyYW5zZm9ybSwgeFRyYW5zZm9ybSwgeVRyYW5zZm9ybSk7XG4gICAgdGhpcy5hZGRDb250ZW50KGAvJHtpbWFnZS5sYWJlbH0gRG9gKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb3BlbkltYWdlKHNyYykge1xuICAgIGxldCBpbWFnZTtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGltYWdlID0gdGhpcy5faW1hZ2VSZWdpc3RyeVtzcmNdO1xuICAgIH1cbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICBpbWFnZSA9IFBERkltYWdlLm9wZW4oc3JjLCBgSSR7Kyt0aGlzLl9pbWFnZUNvdW50fWApO1xuICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2ltYWdlUmVnaXN0cnlbc3JjXSA9IGltYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbn07XG5cbnZhciBBbm5vdGF0aW9uc01peGluID0ge1xuICBhbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5UeXBlID0gJ0Fubm90JztcbiAgICBvcHRpb25zLlJlY3QgPSB0aGlzLl9jb252ZXJ0UmVjdCh4LCB5LCB3LCBoKTtcbiAgICBvcHRpb25zLkJvcmRlciA9IFswLCAwLCAwXTtcbiAgICBpZiAob3B0aW9ucy5TdWJ0eXBlID09PSAnTGluaycgJiYgdHlwZW9mIG9wdGlvbnMuRiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuRiA9IDEgPDwgMjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuU3VidHlwZSAhPT0gJ0xpbmsnKSB7XG4gICAgICBpZiAob3B0aW9ucy5DID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5DID0gdGhpcy5fbm9ybWFsaXplQ29sb3Iob3B0aW9ucy5jb2xvciB8fCBbMCwgMCwgMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5jb2xvcjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuRGVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMuRGVzdCA9IG5ldyBTdHJpbmcob3B0aW9ucy5EZXN0KTtcbiAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbCA9IG9wdGlvbnNba2V5XTtcbiAgICAgIG9wdGlvbnNba2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSldID0gdmFsO1xuICAgIH1cbiAgICBjb25zdCByZWYgPSB0aGlzLnJlZihvcHRpb25zKTtcbiAgICB0aGlzLnBhZ2UuYW5ub3RhdGlvbnMucHVzaChyZWYpO1xuICAgIHJlZi5lbmQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm90ZSh4LCB5LCB3LCBoLCBjb250ZW50cykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICBvcHRpb25zLlN1YnR5cGUgPSAnVGV4dCc7XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcoY29udGVudHMpO1xuICAgIGlmIChvcHRpb25zLk5hbWUgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5OYW1lID0gJ0NvbW1lbnQnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jb2xvciA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLmNvbG9yID0gWzI0MywgMjIzLCA5Ml07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBnb1RvKHgsIHksIHcsIGgsIG5hbWUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0xpbmsnO1xuICAgIG9wdGlvbnMuQSA9IHRoaXMucmVmKHtcbiAgICAgIFM6ICdHb1RvJyxcbiAgICAgIEQ6IG5ldyBTdHJpbmcobmFtZSlcbiAgICB9KTtcbiAgICBvcHRpb25zLkEuZW5kKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGxpbmsoeCwgeSwgdywgaCwgdXJsKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdMaW5rJztcbiAgICBpZiAodHlwZW9mIHVybCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5fcm9vdC5kYXRhLlBhZ2VzLmRhdGE7XG4gICAgICBpZiAodXJsID49IDAgJiYgdXJsIDwgcGFnZXMuS2lkcy5sZW5ndGgpIHtcbiAgICAgICAgb3B0aW9ucy5BID0gdGhpcy5yZWYoe1xuICAgICAgICAgIFM6ICdHb1RvJyxcbiAgICAgICAgICBEOiBbcGFnZXMuS2lkc1t1cmxdLCAnWFlaJywgbnVsbCwgbnVsbCwgbnVsbF1cbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuQS5lbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRvY3VtZW50IGhhcyBubyBwYWdlICR7dXJsfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLkEgPSB0aGlzLnJlZih7XG4gICAgICAgIFM6ICdVUkknLFxuICAgICAgICBVUkk6IG5ldyBTdHJpbmcodXJsKVxuICAgICAgfSk7XG4gICAgICBvcHRpb25zLkEuZW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBfbWFya3VwKHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuX2NvbnZlcnRSZWN0KHgsIHksIHcsIGgpO1xuICAgIG9wdGlvbnMuUXVhZFBvaW50cyA9IFt4MSwgeTIsIHgyLCB5MiwgeDEsIHkxLCB4MiwgeTFdO1xuICAgIG9wdGlvbnMuQ29udGVudHMgPSBuZXcgU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGhpZ2hsaWdodCh4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdIaWdobGlnaHQnO1xuICAgIGlmIChvcHRpb25zLmNvbG9yID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuY29sb3IgPSBbMjQxLCAyMzgsIDE0OF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXJrdXAoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIHVuZGVybGluZSh4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdVbmRlcmxpbmUnO1xuICAgIHJldHVybiB0aGlzLl9tYXJrdXAoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0cmlrZSh4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdTdHJpa2VPdXQnO1xuICAgIHJldHVybiB0aGlzLl9tYXJrdXAoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGxpbmVBbm5vdGF0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdMaW5lJztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZygpO1xuICAgIG9wdGlvbnMuTCA9IFt4MSwgdGhpcy5wYWdlLmhlaWdodCAtIHkxLCB4MiwgdGhpcy5wYWdlLmhlaWdodCAtIHkyXTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucyk7XG4gIH0sXG4gIHJlY3RBbm5vdGF0aW9uKHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ1NxdWFyZSc7XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZWxsaXBzZUFubm90YXRpb24oeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgICBvcHRpb25zLlN1YnR5cGUgPSAnQ2lyY2xlJztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZygpO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICB0ZXh0QW5ub3RhdGlvbih4LCB5LCB3LCBoLCB0ZXh0KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdGcmVlVGV4dCc7XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcodGV4dCk7XG4gICAgb3B0aW9ucy5EQSA9IG5ldyBTdHJpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZmlsZUFubm90YXRpb24oeCwgeSwgdywgaCkge1xuICAgIGxldCBmaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgY29uc3QgZmlsZXNwZWMgPSB0aGlzLmZpbGUoZmlsZS5zcmMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSwgZmlsZSkpO1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdGaWxlQXR0YWNobWVudCc7XG4gICAgb3B0aW9ucy5GUyA9IGZpbGVzcGVjO1xuICAgIGlmIChvcHRpb25zLkNvbnRlbnRzKSB7XG4gICAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZyhvcHRpb25zLkNvbnRlbnRzKTtcbiAgICB9IGVsc2UgaWYgKGZpbGVzcGVjLmRhdGEuRGVzYykge1xuICAgICAgb3B0aW9ucy5Db250ZW50cyA9IGZpbGVzcGVjLmRhdGEuRGVzYztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIF9jb252ZXJ0UmVjdCh4MSwgeTEsIHcsIGgpIHtcbiAgICBsZXQgeTIgPSB5MTtcbiAgICB5MSArPSBoO1xuICAgIGxldCB4MiA9IHgxICsgdztcbiAgICBjb25zdCBbbTAsIG0xLCBtMiwgbTMsIG00LCBtNV0gPSB0aGlzLl9jdG07XG4gICAgeDEgPSBtMCAqIHgxICsgbTIgKiB5MSArIG00O1xuICAgIHkxID0gbTEgKiB4MSArIG0zICogeTEgKyBtNTtcbiAgICB4MiA9IG0wICogeDIgKyBtMiAqIHkyICsgbTQ7XG4gICAgeTIgPSBtMSAqIHgyICsgbTMgKiB5MiArIG01O1xuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xuICB9XG59O1xuXG5jbGFzcyBQREZPdXRsaW5lIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHBhcmVudCwgdGl0bGUsIGRlc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge1xuICAgICAgZXhwYW5kZWQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm91dGxpbmVEYXRhID0ge307XG4gICAgaWYgKGRlc3QgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3V0bGluZURhdGFbJ0Rlc3QnXSA9IFtkZXN0LmRpY3Rpb25hcnksICdGaXQnXTtcbiAgICB9XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRsaW5lRGF0YVsnUGFyZW50J10gPSBwYXJlbnQ7XG4gICAgfVxuICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRsaW5lRGF0YVsnVGl0bGUnXSA9IG5ldyBTdHJpbmcodGl0bGUpO1xuICAgIH1cbiAgICB0aGlzLmRpY3Rpb25hcnkgPSB0aGlzLmRvY3VtZW50LnJlZih0aGlzLm91dGxpbmVEYXRhKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gIH1cbiAgYWRkSXRlbSh0aXRsZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBleHBhbmRlZDogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQREZPdXRsaW5lKHRoaXMuZG9jdW1lbnQsIHRoaXMuZGljdGlvbmFyeSwgdGl0bGUsIHRoaXMuZG9jdW1lbnQucGFnZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBlbmRPdXRsaW5lKCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwYW5kZWQpIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lRGF0YS5Db3VudCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLmNoaWxkcmVuWzBdLFxuICAgICAgICBsYXN0ID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5vdXRsaW5lRGF0YS5GaXJzdCA9IGZpcnN0LmRpY3Rpb25hcnk7XG4gICAgICB0aGlzLm91dGxpbmVEYXRhLkxhc3QgPSBsYXN0LmRpY3Rpb25hcnk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGNoaWxkLm91dGxpbmVEYXRhLlByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXS5kaWN0aW9uYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY2hpbGQub3V0bGluZURhdGEuTmV4dCA9IHRoaXMuY2hpbGRyZW5baSArIDFdLmRpY3Rpb25hcnk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuZW5kT3V0bGluZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmVuZCgpO1xuICB9XG59XG5cbnZhciBPdXRsaW5lTWl4aW4gPSB7XG4gIGluaXRPdXRsaW5lKCkge1xuICAgIHRoaXMub3V0bGluZSA9IG5ldyBQREZPdXRsaW5lKHRoaXMsIG51bGwsIG51bGwsIG51bGwpO1xuICB9LFxuICBlbmRPdXRsaW5lKCkge1xuICAgIHRoaXMub3V0bGluZS5lbmRPdXRsaW5lKCk7XG4gICAgaWYgKHRoaXMub3V0bGluZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuT3V0bGluZXMgPSB0aGlzLm91dGxpbmUuZGljdGlvbmFyeTtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LmRhdGEuUGFnZU1vZGUgPSAnVXNlT3V0bGluZXMnO1xuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUERGU3RydWN0dXJlQ29udGVudCB7XG4gIGNvbnN0cnVjdG9yKHBhZ2VSZWYsIG1jaWQpIHtcbiAgICB0aGlzLnJlZnMgPSBbe1xuICAgICAgcGFnZVJlZixcbiAgICAgIG1jaWRcbiAgICB9XTtcbiAgfVxuICBwdXNoKHN0cnVjdENvbnRlbnQpIHtcbiAgICBzdHJ1Y3RDb250ZW50LnJlZnMuZm9yRWFjaChyZWYgPT4gdGhpcy5yZWZzLnB1c2gocmVmKSk7XG4gIH1cbn1cblxuY2xhc3MgUERGU3RydWN0dXJlRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCB0eXBlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGxldCBjaGlsZHJlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5fYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsdXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRpY3Rpb25hcnkgPSBkb2N1bWVudC5yZWYoe1xuICAgICAgUzogdHlwZVxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRpY3Rpb25hcnkuZGF0YTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fCB0aGlzLl9pc1ZhbGlkQ2hpbGQob3B0aW9ucykpIHtcbiAgICAgIGNoaWxkcmVuID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpdGxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5UID0gbmV3IFN0cmluZyhvcHRpb25zLnRpdGxlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxhbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLkxhbmcgPSBuZXcgU3RyaW5nKG9wdGlvbnMubGFuZyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLkFsdCA9IG5ldyBTdHJpbmcob3B0aW9ucy5hbHQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwYW5kZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLkUgPSBuZXcgU3RyaW5nKG9wdGlvbnMuZXhwYW5kZWQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWN0dWFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5BY3R1YWxUZXh0ID0gbmV3IFN0cmluZyhvcHRpb25zLmFjdHVhbCk7XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdGhpcy5hZGQoY2hpbGQpKTtcbiAgICAgIHRoaXMuZW5kKCk7XG4gICAgfVxuICB9XG4gIGFkZChjaGlsZCkge1xuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIGNoaWxkIHRvIGFscmVhZHktZW5kZWQgc3RydWN0dXJlIGVsZW1lbnRgKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkQ2hpbGQoY2hpbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RydWN0dXJlIGVsZW1lbnQgY2hpbGRgKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCkge1xuICAgICAgY2hpbGQuc2V0UGFyZW50KHRoaXMuZGljdGlvbmFyeSk7XG4gICAgICBpZiAodGhpcy5fYXR0YWNoZWQpIHtcbiAgICAgICAgY2hpbGQuc2V0QXR0YWNoZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlQ29udGVudCkge1xuICAgICAgdGhpcy5fYWRkQ29udGVudFRvUGFyZW50VHJlZShjaGlsZCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5fYXR0YWNoZWQpIHtcbiAgICAgIGNoaWxkID0gdGhpcy5fY29udGVudEZvckNsb3N1cmUoY2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfYWRkQ29udGVudFRvUGFyZW50VHJlZShjb250ZW50KSB7XG4gICAgY29udGVudC5yZWZzLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBwYWdlUmVmLFxuICAgICAgICBtY2lkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IHBhZ2VTdHJ1Y3RQYXJlbnRzID0gdGhpcy5kb2N1bWVudC5nZXRTdHJ1Y3RQYXJlbnRUcmVlKCkuZ2V0KHBhZ2VSZWYuZGF0YS5TdHJ1Y3RQYXJlbnRzKTtcbiAgICAgIHBhZ2VTdHJ1Y3RQYXJlbnRzW21jaWRdID0gdGhpcy5kaWN0aW9uYXJ5O1xuICAgIH0pO1xuICB9XG4gIHNldFBhcmVudChwYXJlbnRSZWYpIHtcbiAgICBpZiAodGhpcy5kaWN0aW9uYXJ5LmRhdGEuUCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJ1Y3R1cmUgZWxlbWVudCBhZGRlZCB0byBtb3JlIHRoYW4gb25lIHBhcmVudGApO1xuICAgIH1cbiAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5QID0gcGFyZW50UmVmO1xuICAgIHRoaXMuX2ZsdXNoKCk7XG4gIH1cbiAgc2V0QXR0YWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2F0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCkge1xuICAgICAgICBjaGlsZC5zZXRBdHRhY2hlZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbltpbmRleF0gPSB0aGlzLl9jb250ZW50Rm9yQ2xvc3VyZShjaGlsZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fYXR0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMuX2ZsdXNoKCk7XG4gIH1cbiAgZW5kKCkge1xuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KS5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLmVuZCgpKTtcbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgfVxuICBfaXNWYWxpZENoaWxkKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUNvbnRlbnQgfHwgdHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nO1xuICB9XG4gIF9jb250ZW50Rm9yQ2xvc3VyZShjbG9zdXJlKSB7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuZG9jdW1lbnQubWFya1N0cnVjdHVyZUNvbnRlbnQodGhpcy5kaWN0aW9uYXJ5LmRhdGEuUyk7XG4gICAgY2xvc3VyZSgpO1xuICAgIHRoaXMuZG9jdW1lbnQuZW5kTWFya2VkQ29udGVudCgpO1xuICAgIHRoaXMuX2FkZENvbnRlbnRUb1BhcmVudFRyZWUoY29udGVudCk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgX2lzRmx1c2hhYmxlKCkge1xuICAgIGlmICghdGhpcy5kaWN0aW9uYXJ5LmRhdGEuUCB8fCAhdGhpcy5fZW5kZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuX2lzRmx1c2hhYmxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICBfZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoZWQgfHwgIXRoaXMuX2lzRmx1c2hhYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuSyA9IFtdO1xuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdGhpcy5fZmx1c2hDaGlsZChjaGlsZCkpO1xuICAgIHRoaXMuZGljdGlvbmFyeS5lbmQoKTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLksgPSBudWxsO1xuICAgIHRoaXMuX2ZsdXNoZWQgPSB0cnVlO1xuICB9XG4gIF9mbHVzaENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCkge1xuICAgICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuSy5wdXNoKGNoaWxkLmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVDb250ZW50KSB7XG4gICAgICBjaGlsZC5yZWZzLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHBhZ2VSZWYsXG4gICAgICAgICAgbWNpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIGlmICghdGhpcy5kaWN0aW9uYXJ5LmRhdGEuUGcpIHtcbiAgICAgICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5QZyA9IHBhZ2VSZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGljdGlvbmFyeS5kYXRhLlBnID09PSBwYWdlUmVmKSB7XG4gICAgICAgICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuSy5wdXNoKG1jaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLksucHVzaCh7XG4gICAgICAgICAgICBUeXBlOiAnTUNSJyxcbiAgICAgICAgICAgIFBnOiBwYWdlUmVmLFxuICAgICAgICAgICAgTUNJRDogbWNpZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUERGTnVtYmVyVHJlZSBleHRlbmRzIFBERlRyZWUge1xuICBfY29tcGFyZUtleXMoYSwgYikge1xuICAgIHJldHVybiBwYXJzZUludChhKSAtIHBhcnNlSW50KGIpO1xuICB9XG4gIF9rZXlzTmFtZSgpIHtcbiAgICByZXR1cm4gJ051bXMnO1xuICB9XG4gIF9kYXRhRm9yS2V5KGspIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoayk7XG4gIH1cbn1cblxudmFyIE1hcmtpbmdzTWl4aW4gPSB7XG4gIGluaXRNYXJraW5ncyhvcHRpb25zKSB7XG4gICAgdGhpcy5zdHJ1Y3RDaGlsZHJlbiA9IFtdO1xuICAgIGlmIChvcHRpb25zLnRhZ2dlZCkge1xuICAgICAgdGhpcy5nZXRNYXJrSW5mb0RpY3Rpb25hcnkoKS5kYXRhLk1hcmtlZCA9IHRydWU7XG4gICAgICB0aGlzLmdldFN0cnVjdFRyZWVSb290KCk7XG4gICAgfVxuICB9LFxuICBtYXJrQ29udGVudCh0YWcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBpZiAodGFnID09PSAnQXJ0aWZhY3QnIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5tY2lkKSB7XG4gICAgICBsZXQgdG9DbG9zZSA9IDA7XG4gICAgICB0aGlzLnBhZ2UubWFya2luZ3MuZm9yRWFjaChtYXJraW5nID0+IHtcbiAgICAgICAgaWYgKHRvQ2xvc2UgfHwgbWFya2luZy5zdHJ1Y3RDb250ZW50IHx8IG1hcmtpbmcudGFnID09PSAnQXJ0aWZhY3QnKSB7XG4gICAgICAgICAgdG9DbG9zZSsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdoaWxlICh0b0Nsb3NlLS0pIHtcbiAgICAgICAgdGhpcy5lbmRNYXJrZWRDb250ZW50KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgdGhpcy5wYWdlLm1hcmtpbmdzLnB1c2goe1xuICAgICAgICB0YWdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRDb250ZW50KGAvJHt0YWd9IEJNQ2ApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMucGFnZS5tYXJraW5ncy5wdXNoKHtcbiAgICAgIHRhZyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgICBjb25zdCBkaWN0aW9uYXJ5ID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm1jaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkaWN0aW9uYXJ5Lk1DSUQgPSBvcHRpb25zLm1jaWQ7XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdBcnRpZmFjdCcpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBkaWN0aW9uYXJ5LlR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmJib3gpKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuQkJveCA9IFtvcHRpb25zLmJib3hbMF0sIHRoaXMucGFnZS5oZWlnaHQgLSBvcHRpb25zLmJib3hbM10sIG9wdGlvbnMuYmJveFsyXSwgdGhpcy5wYWdlLmhlaWdodCAtIG9wdGlvbnMuYmJveFsxXV07XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmF0dGFjaGVkKSAmJiBvcHRpb25zLmF0dGFjaGVkLmV2ZXJ5KHZhbCA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgZGljdGlvbmFyeS5BdHRhY2hlZCA9IG9wdGlvbnMuYXR0YWNoZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdTcGFuJykge1xuICAgICAgaWYgKG9wdGlvbnMubGFuZykge1xuICAgICAgICBkaWN0aW9uYXJ5LkxhbmcgPSBuZXcgU3RyaW5nKG9wdGlvbnMubGFuZyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbHQpIHtcbiAgICAgICAgZGljdGlvbmFyeS5BbHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmV4cGFuZGVkKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuRSA9IG5ldyBTdHJpbmcob3B0aW9ucy5leHBhbmRlZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hY3R1YWwpIHtcbiAgICAgICAgZGljdGlvbmFyeS5BY3R1YWxUZXh0ID0gbmV3IFN0cmluZyhvcHRpb25zLmFjdHVhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkQ29udGVudChgLyR7dGFnfSAke1BERk9iamVjdC5jb252ZXJ0KGRpY3Rpb25hcnkpfSBCRENgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWFya1N0cnVjdHVyZUNvbnRlbnQodGFnKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHBhZ2VTdHJ1Y3RQYXJlbnRzID0gdGhpcy5nZXRTdHJ1Y3RQYXJlbnRUcmVlKCkuZ2V0KHRoaXMucGFnZS5zdHJ1Y3RQYXJlbnRUcmVlS2V5KTtcbiAgICBjb25zdCBtY2lkID0gcGFnZVN0cnVjdFBhcmVudHMubGVuZ3RoO1xuICAgIHBhZ2VTdHJ1Y3RQYXJlbnRzLnB1c2gobnVsbCk7XG4gICAgdGhpcy5tYXJrQ29udGVudCh0YWcsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBtY2lkXG4gICAgfSk7XG4gICAgY29uc3Qgc3RydWN0Q29udGVudCA9IG5ldyBQREZTdHJ1Y3R1cmVDb250ZW50KHRoaXMucGFnZS5kaWN0aW9uYXJ5LCBtY2lkKTtcbiAgICB0aGlzLnBhZ2UubWFya2luZ3Muc2xpY2UoLTEpWzBdLnN0cnVjdENvbnRlbnQgPSBzdHJ1Y3RDb250ZW50O1xuICAgIHJldHVybiBzdHJ1Y3RDb250ZW50O1xuICB9LFxuICBlbmRNYXJrZWRDb250ZW50KCkge1xuICAgIHRoaXMucGFnZS5tYXJraW5ncy5wb3AoKTtcbiAgICB0aGlzLmFkZENvbnRlbnQoJ0VNQycpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdHJ1Y3QodHlwZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgY2hpbGRyZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZTdHJ1Y3R1cmVFbGVtZW50KHRoaXMsIHR5cGUsIG9wdGlvbnMsIGNoaWxkcmVuKTtcbiAgfSxcbiAgYWRkU3RydWN0dXJlKHN0cnVjdEVsZW0pIHtcbiAgICBjb25zdCBzdHJ1Y3RUcmVlUm9vdCA9IHRoaXMuZ2V0U3RydWN0VHJlZVJvb3QoKTtcbiAgICBzdHJ1Y3RFbGVtLnNldFBhcmVudChzdHJ1Y3RUcmVlUm9vdCk7XG4gICAgc3RydWN0RWxlbS5zZXRBdHRhY2hlZCgpO1xuICAgIHRoaXMuc3RydWN0Q2hpbGRyZW4ucHVzaChzdHJ1Y3RFbGVtKTtcbiAgICBpZiAoIXN0cnVjdFRyZWVSb290LmRhdGEuSykge1xuICAgICAgc3RydWN0VHJlZVJvb3QuZGF0YS5LID0gW107XG4gICAgfVxuICAgIHN0cnVjdFRyZWVSb290LmRhdGEuSy5wdXNoKHN0cnVjdEVsZW0uZGljdGlvbmFyeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGluaXRQYWdlTWFya2luZ3MocGFnZU1hcmtpbmdzKSB7XG4gICAgcGFnZU1hcmtpbmdzLmZvckVhY2gobWFya2luZyA9PiB7XG4gICAgICBpZiAobWFya2luZy5zdHJ1Y3RDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdENvbnRlbnQgPSBtYXJraW5nLnN0cnVjdENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IG5ld1N0cnVjdENvbnRlbnQgPSB0aGlzLm1hcmtTdHJ1Y3R1cmVDb250ZW50KG1hcmtpbmcudGFnLCBtYXJraW5nLm9wdGlvbnMpO1xuICAgICAgICBzdHJ1Y3RDb250ZW50LnB1c2gobmV3U3RydWN0Q29udGVudCk7XG4gICAgICAgIHRoaXMucGFnZS5tYXJraW5ncy5zbGljZSgtMSlbMF0uc3RydWN0Q29udGVudCA9IHN0cnVjdENvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hcmtDb250ZW50KG1hcmtpbmcudGFnLCBtYXJraW5nLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBlbmRQYWdlTWFya2luZ3MocGFnZSkge1xuICAgIGNvbnN0IHBhZ2VNYXJraW5ncyA9IHBhZ2UubWFya2luZ3M7XG4gICAgcGFnZU1hcmtpbmdzLmZvckVhY2goKCkgPT4gcGFnZS53cml0ZSgnRU1DJykpO1xuICAgIHBhZ2UubWFya2luZ3MgPSBbXTtcbiAgICByZXR1cm4gcGFnZU1hcmtpbmdzO1xuICB9LFxuICBnZXRNYXJrSW5mb0RpY3Rpb25hcnkoKSB7XG4gICAgaWYgKCF0aGlzLl9yb290LmRhdGEuTWFya0luZm8pIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbyA9IHRoaXMucmVmKHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbztcbiAgfSxcbiAgaGFzTWFya0luZm9EaWN0aW9uYXJ5KCkge1xuICAgIHJldHVybiAhIXRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbztcbiAgfSxcbiAgZ2V0U3RydWN0VHJlZVJvb3QoKSB7XG4gICAgaWYgKCF0aGlzLl9yb290LmRhdGEuU3RydWN0VHJlZVJvb3QpIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5TdHJ1Y3RUcmVlUm9vdCA9IHRoaXMucmVmKHtcbiAgICAgICAgVHlwZTogJ1N0cnVjdFRyZWVSb290JyxcbiAgICAgICAgUGFyZW50VHJlZTogbmV3IFBERk51bWJlclRyZWUoKSxcbiAgICAgICAgUGFyZW50VHJlZU5leHRLZXk6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdC5kYXRhLlN0cnVjdFRyZWVSb290O1xuICB9LFxuICBnZXRTdHJ1Y3RQYXJlbnRUcmVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0cnVjdFRyZWVSb290KCkuZGF0YS5QYXJlbnRUcmVlO1xuICB9LFxuICBjcmVhdGVTdHJ1Y3RQYXJlbnRUcmVlTmV4dEtleSgpIHtcbiAgICB0aGlzLmdldE1hcmtJbmZvRGljdGlvbmFyeSgpO1xuICAgIGNvbnN0IHN0cnVjdFRyZWVSb290ID0gdGhpcy5nZXRTdHJ1Y3RUcmVlUm9vdCgpO1xuICAgIGNvbnN0IGtleSA9IHN0cnVjdFRyZWVSb290LmRhdGEuUGFyZW50VHJlZU5leHRLZXkrKztcbiAgICBzdHJ1Y3RUcmVlUm9vdC5kYXRhLlBhcmVudFRyZWUuYWRkKGtleSwgW10pO1xuICAgIHJldHVybiBrZXk7XG4gIH0sXG4gIGVuZE1hcmtpbmdzKCkge1xuICAgIGNvbnN0IHN0cnVjdFRyZWVSb290ID0gdGhpcy5fcm9vdC5kYXRhLlN0cnVjdFRyZWVSb290O1xuICAgIGlmIChzdHJ1Y3RUcmVlUm9vdCkge1xuICAgICAgc3RydWN0VHJlZVJvb3QuZW5kKCk7XG4gICAgICB0aGlzLnN0cnVjdENoaWxkcmVuLmZvckVhY2goc3RydWN0RWxlbSA9PiBzdHJ1Y3RFbGVtLmVuZCgpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvLmVuZCgpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgRklFTERfRkxBR1MgPSB7XG4gIHJlYWRPbmx5OiAxLFxuICByZXF1aXJlZDogMixcbiAgbm9FeHBvcnQ6IDQsXG4gIG11bHRpbGluZTogMHgxMDAwLFxuICBwYXNzd29yZDogMHgyMDAwLFxuICB0b2dnbGVUb09mZkJ1dHRvbjogMHg0MDAwLFxuICByYWRpb0J1dHRvbjogMHg4MDAwLFxuICBwdXNoQnV0dG9uOiAweDEwMDAwLFxuICBjb21ibzogMHgyMDAwMCxcbiAgZWRpdDogMHg0MDAwMCxcbiAgc29ydDogMHg4MDAwMCxcbiAgbXVsdGlTZWxlY3Q6IDB4MjAwMDAwLFxuICBub1NwZWxsOiAweDQwMDAwMFxufTtcbmNvbnN0IEZJRUxEX0pVU1RJRlkgPSB7XG4gIGxlZnQ6IDAsXG4gIGNlbnRlcjogMSxcbiAgcmlnaHQ6IDJcbn07XG5jb25zdCBWQUxVRV9NQVAgPSB7XG4gIHZhbHVlOiAnVicsXG4gIGRlZmF1bHRWYWx1ZTogJ0RWJ1xufTtcbmNvbnN0IEZPUk1BVF9TUEVDSUFMID0ge1xuICB6aXA6ICcwJyxcbiAgemlwUGx1czQ6ICcxJyxcbiAgemlwNDogJzEnLFxuICBwaG9uZTogJzInLFxuICBzc246ICczJ1xufTtcbmNvbnN0IEZPUk1BVF9ERUZBVUxUID0ge1xuICBudW1iZXI6IHtcbiAgICBuRGVjOiAwLFxuICAgIHNlcENvbW1hOiBmYWxzZSxcbiAgICBuZWdTdHlsZTogJ01pbnVzQmxhY2snLFxuICAgIGN1cnJlbmN5OiAnJyxcbiAgICBjdXJyZW5jeVByZXBlbmQ6IHRydWVcbiAgfSxcbiAgcGVyY2VudDoge1xuICAgIG5EZWM6IDAsXG4gICAgc2VwQ29tbWE6IGZhbHNlXG4gIH1cbn07XG52YXIgQWNyb0Zvcm1NaXhpbiA9IHtcbiAgaW5pdEZvcm0oKSB7XG4gICAgaWYgKCF0aGlzLl9mb250KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc2V0IGEgZm9udCBiZWZvcmUgY2FsbGluZyBpbml0Rm9ybSBtZXRob2QnKTtcbiAgICB9XG4gICAgdGhpcy5fYWNyb2Zvcm0gPSB7XG4gICAgICBmb250czoge30sXG4gICAgICBkZWZhdWx0Rm9udDogdGhpcy5fZm9udC5uYW1lXG4gICAgfTtcbiAgICB0aGlzLl9hY3JvZm9ybS5mb250c1t0aGlzLl9mb250LmlkXSA9IHRoaXMuX2ZvbnQucmVmKCk7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICBGaWVsZHM6IFtdLFxuICAgICAgTmVlZEFwcGVhcmFuY2VzOiB0cnVlLFxuICAgICAgREE6IG5ldyBTdHJpbmcoYC8ke3RoaXMuX2ZvbnQuaWR9IDAgVGYgMCBnYCksXG4gICAgICBEUjoge1xuICAgICAgICBGb250OiB7fVxuICAgICAgfVxuICAgIH07XG4gICAgZGF0YS5EUi5Gb250W3RoaXMuX2ZvbnQuaWRdID0gdGhpcy5fZm9udC5yZWYoKTtcbiAgICBjb25zdCBBY3JvRm9ybSA9IHRoaXMucmVmKGRhdGEpO1xuICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybSA9IEFjcm9Gb3JtO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmRBY3JvRm9ybSgpIHtcbiAgICBpZiAodGhpcy5fcm9vdC5kYXRhLkFjcm9Gb3JtKSB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuX2Fjcm9mb3JtLmZvbnRzKS5sZW5ndGggJiYgIXRoaXMuX2Fjcm9mb3JtLmRlZmF1bHRGb250KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZm9udHMgc3BlY2lmaWVkIGZvciBQREYgZm9ybScpO1xuICAgICAgfVxuICAgICAgbGV0IGZvbnREaWN0ID0gdGhpcy5fcm9vdC5kYXRhLkFjcm9Gb3JtLmRhdGEuRFIuRm9udDtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2Fjcm9mb3JtLmZvbnRzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBmb250RGljdFtuYW1lXSA9IHRoaXMuX2Fjcm9mb3JtLmZvbnRzW25hbWVdO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0uZGF0YS5GaWVsZHMuZm9yRWFjaChmaWVsZFJlZiA9PiB7XG4gICAgICAgIHRoaXMuX2VuZENoaWxkKGZpZWxkUmVmKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLkFjcm9Gb3JtLmVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2VuZENoaWxkKHJlZikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZi5kYXRhLktpZHMpKSB7XG4gICAgICByZWYuZGF0YS5LaWRzLmZvckVhY2goY2hpbGRSZWYgPT4ge1xuICAgICAgICB0aGlzLl9lbmRDaGlsZChjaGlsZFJlZik7XG4gICAgICB9KTtcbiAgICAgIHJlZi5lbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZvcm1GaWVsZChuYW1lKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBmaWVsZERpY3QgPSB0aGlzLl9maWVsZERpY3QobmFtZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgbGV0IGZpZWxkUmVmID0gdGhpcy5yZWYoZmllbGREaWN0KTtcbiAgICB0aGlzLl9hZGRUb1BhcmVudChmaWVsZFJlZik7XG4gICAgcmV0dXJuIGZpZWxkUmVmO1xuICB9LFxuICBmb3JtQW5ub3RhdGlvbihuYW1lLCB0eXBlLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHt9O1xuICAgIGxldCBmaWVsZERpY3QgPSB0aGlzLl9maWVsZERpY3QobmFtZSwgdHlwZSwgb3B0aW9ucyk7XG4gICAgZmllbGREaWN0LlN1YnR5cGUgPSAnV2lkZ2V0JztcbiAgICBpZiAoZmllbGREaWN0LkYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmllbGREaWN0LkYgPSA0O1xuICAgIH1cbiAgICB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIGZpZWxkRGljdCk7XG4gICAgbGV0IGFubm90UmVmID0gdGhpcy5wYWdlLmFubm90YXRpb25zW3RoaXMucGFnZS5hbm5vdGF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gdGhpcy5fYWRkVG9QYXJlbnQoYW5ub3RSZWYpO1xuICB9LFxuICBmb3JtVGV4dChuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICd0ZXh0JywgeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGZvcm1QdXNoQnV0dG9uKG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZm9ybUFubm90YXRpb24obmFtZSwgJ3B1c2hCdXR0b24nLCB4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZm9ybUNvbWJvKG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZm9ybUFubm90YXRpb24obmFtZSwgJ2NvbWJvJywgeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGZvcm1MaXN0KG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZm9ybUFubm90YXRpb24obmFtZSwgJ2xpc3QnLCB4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZm9ybVJhZGlvQnV0dG9uKG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZm9ybUFubm90YXRpb24obmFtZSwgJ3JhZGlvQnV0dG9uJywgeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGZvcm1DaGVja2JveChuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdjaGVja2JveCcsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBfYWRkVG9QYXJlbnQoZmllbGRSZWYpIHtcbiAgICBsZXQgcGFyZW50ID0gZmllbGRSZWYuZGF0YS5QYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKCFwYXJlbnQuZGF0YS5LaWRzKSB7XG4gICAgICAgIHBhcmVudC5kYXRhLktpZHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5kYXRhLktpZHMucHVzaChmaWVsZFJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybS5kYXRhLkZpZWxkcy5wdXNoKGZpZWxkUmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9maWVsZERpY3QobmFtZSwgdHlwZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXRoaXMuX2Fjcm9mb3JtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGwgZG9jdW1lbnQuaW5pdEZvcm0oKSBtZXRob2QgYmVmb3JlIGFkZGluZyBmb3JtIGVsZW1lbnRzIHRvIGRvY3VtZW50Jyk7XG4gICAgfVxuICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlVHlwZSh0eXBlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVGbGFncyhvcHRzKTtcbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZUp1c3RpZnkob3B0cyk7XG4gICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVGb250KG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlU3RyaW5ncyhvcHRzKTtcbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZUNvbG9ycyhvcHRzKTtcbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZUZvcm1hdChvcHRzKTtcbiAgICBvcHRzLlQgPSBuZXcgU3RyaW5nKG5hbWUpO1xuICAgIGlmIChvcHRzLnBhcmVudCkge1xuICAgICAgb3B0cy5QYXJlbnQgPSBvcHRzLnBhcmVudDtcbiAgICAgIGRlbGV0ZSBvcHRzLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHM7XG4gIH0sXG4gIF9yZXNvbHZlVHlwZSh0eXBlLCBvcHRzKSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgb3B0cy5GVCA9ICdUeCc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncHVzaEJ1dHRvbicpIHtcbiAgICAgIG9wdHMuRlQgPSAnQnRuJztcbiAgICAgIG9wdHMucHVzaEJ1dHRvbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncmFkaW9CdXR0b24nKSB7XG4gICAgICBvcHRzLkZUID0gJ0J0bic7XG4gICAgICBvcHRzLnJhZGlvQnV0dG9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgIG9wdHMuRlQgPSAnQnRuJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb21ibycpIHtcbiAgICAgIG9wdHMuRlQgPSAnQ2gnO1xuICAgICAgb3B0cy5jb21ibyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGlzdCcpIHtcbiAgICAgIG9wdHMuRlQgPSAnQ2gnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9ybSBhbm5vdGF0aW9uIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBvcHRzO1xuICB9LFxuICBfcmVzb2x2ZUZvcm1hdChvcHRzKSB7XG4gICAgY29uc3QgZiA9IG9wdHMuZm9ybWF0O1xuICAgIGlmIChmICYmIGYudHlwZSkge1xuICAgICAgbGV0IGZuS2V5c3Ryb2tlO1xuICAgICAgbGV0IGZuRm9ybWF0O1xuICAgICAgbGV0IHBhcmFtcyA9ICcnO1xuICAgICAgaWYgKEZPUk1BVF9TUEVDSUFMW2YudHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmbktleXN0cm9rZSA9IGBBRlNwZWNpYWxfS2V5c3Ryb2tlYDtcbiAgICAgICAgZm5Gb3JtYXQgPSBgQUZTcGVjaWFsX0Zvcm1hdGA7XG4gICAgICAgIHBhcmFtcyA9IEZPUk1BVF9TUEVDSUFMW2YudHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZm9ybWF0ID0gZi50eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZi50eXBlLnNsaWNlKDEpO1xuICAgICAgICBmbktleXN0cm9rZSA9IGBBRiR7Zm9ybWF0fV9LZXlzdHJva2VgO1xuICAgICAgICBmbkZvcm1hdCA9IGBBRiR7Zm9ybWF0fV9Gb3JtYXRgO1xuICAgICAgICBpZiAoZi50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICBmbktleXN0cm9rZSArPSAnRXgnO1xuICAgICAgICAgIHBhcmFtcyA9IFN0cmluZyhmLnBhcmFtKTtcbiAgICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgIHBhcmFtcyA9IFN0cmluZyhmLnBhcmFtKTtcbiAgICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbGV0IHAgPSBPYmplY3QuYXNzaWduKHt9LCBGT1JNQVRfREVGQVVMVC5udW1iZXIsIGYpO1xuICAgICAgICAgIHBhcmFtcyA9IFN0cmluZyhbU3RyaW5nKHAubkRlYyksIHAuc2VwQ29tbWEgPyAnMCcgOiAnMScsICdcIicgKyBwLm5lZ1N0eWxlICsgJ1wiJywgJ251bGwnLCAnXCInICsgcC5jdXJyZW5jeSArICdcIicsIFN0cmluZyhwLmN1cnJlbmN5UHJlcGVuZCldLmpvaW4oJywnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSAncGVyY2VudCcpIHtcbiAgICAgICAgICBsZXQgcCA9IE9iamVjdC5hc3NpZ24oe30sIEZPUk1BVF9ERUZBVUxULnBlcmNlbnQsIGYpO1xuICAgICAgICAgIHBhcmFtcyA9IFN0cmluZyhbU3RyaW5nKHAubkRlYyksIHAuc2VwQ29tbWEgPyAnMCcgOiAnMSddLmpvaW4oJywnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdHMuQUEgPSBvcHRzLkFBID8gb3B0cy5BQSA6IHt9O1xuICAgICAgb3B0cy5BQS5LID0ge1xuICAgICAgICBTOiAnSmF2YVNjcmlwdCcsXG4gICAgICAgIEpTOiBuZXcgU3RyaW5nKGAke2ZuS2V5c3Ryb2tlfSgke3BhcmFtc30pO2ApXG4gICAgICB9O1xuICAgICAgb3B0cy5BQS5GID0ge1xuICAgICAgICBTOiAnSmF2YVNjcmlwdCcsXG4gICAgICAgIEpTOiBuZXcgU3RyaW5nKGAke2ZuRm9ybWF0fSgke3BhcmFtc30pO2ApXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWxldGUgb3B0cy5mb3JtYXQ7XG4gICAgcmV0dXJuIG9wdHM7XG4gIH0sXG4gIF9yZXNvbHZlQ29sb3JzKG9wdHMpIHtcbiAgICBsZXQgY29sb3IgPSB0aGlzLl9ub3JtYWxpemVDb2xvcihvcHRzLmJhY2tncm91bmRDb2xvcik7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBpZiAoIW9wdHMuTUspIHtcbiAgICAgICAgb3B0cy5NSyA9IHt9O1xuICAgICAgfVxuICAgICAgb3B0cy5NSy5CRyA9IGNvbG9yO1xuICAgIH1cbiAgICBjb2xvciA9IHRoaXMuX25vcm1hbGl6ZUNvbG9yKG9wdHMuYm9yZGVyQ29sb3IpO1xuICAgIGlmIChjb2xvcikge1xuICAgICAgaWYgKCFvcHRzLk1LKSB7XG4gICAgICAgIG9wdHMuTUsgPSB7fTtcbiAgICAgIH1cbiAgICAgIG9wdHMuTUsuQkMgPSBjb2xvcjtcbiAgICB9XG4gICAgZGVsZXRlIG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRlbGV0ZSBvcHRzLmJvcmRlckNvbG9yO1xuICAgIHJldHVybiBvcHRzO1xuICB9LFxuICBfcmVzb2x2ZUZsYWdzKG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoRklFTERfRkxBR1Nba2V5XSkge1xuICAgICAgICBpZiAob3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgcmVzdWx0IHw9IEZJRUxEX0ZMQUdTW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzdWx0ICE9PSAwKSB7XG4gICAgICBvcHRpb25zLkZmID0gb3B0aW9ucy5GZiA/IG9wdGlvbnMuRmYgOiAwO1xuICAgICAgb3B0aW9ucy5GZiB8PSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuICBfcmVzb2x2ZUp1c3RpZnkob3B0aW9ucykge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGlmIChvcHRpb25zLmFsaWduICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgRklFTERfSlVTVElGWVtvcHRpb25zLmFsaWduXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gRklFTERfSlVTVElGWVtvcHRpb25zLmFsaWduXTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvcHRpb25zLmFsaWduO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSAwKSB7XG4gICAgICBvcHRpb25zLlEgPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuICBfcmVzb2x2ZUZvbnQob3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9hY3JvZm9ybS5mb250c1t0aGlzLl9mb250LmlkXSA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9hY3JvZm9ybS5mb250c1t0aGlzLl9mb250LmlkXSA9IHRoaXMuX2ZvbnQucmVmKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hY3JvZm9ybS5kZWZhdWx0Rm9udCAhPT0gdGhpcy5fZm9udC5uYW1lKSB7XG4gICAgICBvcHRpb25zLkRSID0ge1xuICAgICAgICBGb250OiB7fVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCAwO1xuICAgICAgb3B0aW9ucy5EUi5Gb250W3RoaXMuX2ZvbnQuaWRdID0gdGhpcy5fZm9udC5yZWYoKTtcbiAgICAgIG9wdGlvbnMuREEgPSBuZXcgU3RyaW5nKGAvJHt0aGlzLl9mb250LmlkfSAke2ZvbnRTaXplfSBUZiAwIGdgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG4gIF9yZXNvbHZlU3RyaW5ncyhvcHRpb25zKSB7XG4gICAgbGV0IHNlbGVjdCA9IFtdO1xuICAgIGZ1bmN0aW9uIGFwcGVuZENob2ljZXMoYSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhW2lkeF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWxlY3QucHVzaChuZXcgU3RyaW5nKGFbaWR4XSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3QucHVzaChhW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmRDaG9pY2VzKG9wdGlvbnMuT3B0KTtcbiAgICBpZiAob3B0aW9ucy5zZWxlY3QpIHtcbiAgICAgIGFwcGVuZENob2ljZXMob3B0aW9ucy5zZWxlY3QpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuc2VsZWN0O1xuICAgIH1cbiAgICBpZiAoc2VsZWN0Lmxlbmd0aCkge1xuICAgICAgb3B0aW9ucy5PcHQgPSBzZWxlY3Q7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKFZBTFVFX01BUCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnNbVkFMVUVfTUFQW2tleV1dID0gb3B0aW9uc1trZXldO1xuICAgICAgICBkZWxldGUgb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFsnVicsICdEViddLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zW2tleV0gPSBuZXcgU3RyaW5nKG9wdGlvbnNba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuTUsgJiYgb3B0aW9ucy5NSy5DQSkge1xuICAgICAgb3B0aW9ucy5NSy5DQSA9IG5ldyBTdHJpbmcob3B0aW9ucy5NSy5DQSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhYmVsKSB7XG4gICAgICBvcHRpb25zLk1LID0gb3B0aW9ucy5NSyA/IG9wdGlvbnMuTUsgOiB7fTtcbiAgICAgIG9wdGlvbnMuTUsuQ0EgPSBuZXcgU3RyaW5nKG9wdGlvbnMubGFiZWwpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMubGFiZWw7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG59O1xuXG52YXIgQXR0YWNobWVudHNNaXhpbiA9IHtcbiAgZmlsZShzcmMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IHNyYztcbiAgICBvcHRpb25zLnJlbGF0aW9uc2hpcCA9IG9wdGlvbnMucmVsYXRpb25zaGlwIHx8ICdVbnNwZWNpZmllZCc7XG4gICAgY29uc3QgcmVmQm9keSA9IHtcbiAgICAgIFR5cGU6ICdFbWJlZGRlZEZpbGUnLFxuICAgICAgUGFyYW1zOiB7fVxuICAgIH07XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3JjIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNyYykpIHtcbiAgICAgIGRhdGEgPSBzcmM7XG4gICAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNyYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXRjaCA9IC9eZGF0YTooLio/KTtiYXNlNjQsKC4qKSQvLmV4ZWMoc3JjKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICByZWZCb2R5LlN1YnR5cGUgPSBtYXRjaFsxXS5yZXBsYWNlKCcvJywgJyMyRicpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShtYXRjaFsyXSwgJ2Jhc2U2NCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhzcmMpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZWFkIGNvbnRlbnRzIG9mIGZpbGUgYXQgZmlsZXBhdGggJHtzcmN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJpcnRodGltZSxcbiAgICAgICAgICBjdGltZVxuICAgICAgICB9ID0gZnMuc3RhdFN5bmMoc3JjKTtcbiAgICAgICAgcmVmQm9keS5QYXJhbXMuQ3JlYXRpb25EYXRlID0gYmlydGh0aW1lO1xuICAgICAgICByZWZCb2R5LlBhcmFtcy5Nb2REYXRlID0gY3RpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNyZWF0aW9uRGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJlZkJvZHkuUGFyYW1zLkNyZWF0aW9uRGF0ZSA9IG9wdGlvbnMuY3JlYXRpb25EYXRlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tb2RpZmllZERhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZWZCb2R5LlBhcmFtcy5Nb2REYXRlID0gb3B0aW9ucy5tb2RpZmllZERhdGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnR5cGUpIHtcbiAgICAgIHJlZkJvZHkuU3VidHlwZSA9IG9wdGlvbnMudHlwZS5yZXBsYWNlKCcvJywgJyMyRicpO1xuICAgIH1cbiAgICBjb25zdCBjaGVja3N1bSA9IENyeXB0b0pTLk1ENShDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgIHJlZkJvZHkuUGFyYW1zLkNoZWNrU3VtID0gbmV3IFN0cmluZyhjaGVja3N1bSk7XG4gICAgcmVmQm9keS5QYXJhbXMuU2l6ZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVmO1xuICAgIGlmICghdGhpcy5fZmlsZVJlZ2lzdHJ5KSB0aGlzLl9maWxlUmVnaXN0cnkgPSB7fTtcbiAgICBsZXQgZmlsZSA9IHRoaXMuX2ZpbGVSZWdpc3RyeVtvcHRpb25zLm5hbWVdO1xuICAgIGlmIChmaWxlICYmIGlzRXF1YWwocmVmQm9keSwgZmlsZSkpIHtcbiAgICAgIHJlZiA9IGZpbGUucmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB0aGlzLnJlZihyZWZCb2R5KTtcbiAgICAgIHJlZi5lbmQoZGF0YSk7XG4gICAgICB0aGlzLl9maWxlUmVnaXN0cnlbb3B0aW9ucy5uYW1lXSA9IHtcbiAgICAgICAgLi4ucmVmQm9keSxcbiAgICAgICAgcmVmXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBmaWxlU3BlY0JvZHkgPSB7XG4gICAgICBUeXBlOiAnRmlsZXNwZWMnLFxuICAgICAgQUZSZWxhdGlvbnNoaXA6IG9wdGlvbnMucmVsYXRpb25zaGlwLFxuICAgICAgRjogbmV3IFN0cmluZyhvcHRpb25zLm5hbWUpLFxuICAgICAgRUY6IHtcbiAgICAgICAgRjogcmVmXG4gICAgICB9LFxuICAgICAgVUY6IG5ldyBTdHJpbmcob3B0aW9ucy5uYW1lKVxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMuZGVzY3JpcHRpb24pIHtcbiAgICAgIGZpbGVTcGVjQm9keS5EZXNjID0gbmV3IFN0cmluZyhvcHRpb25zLmRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZXNwZWMgPSB0aGlzLnJlZihmaWxlU3BlY0JvZHkpO1xuICAgIGZpbGVzcGVjLmVuZCgpO1xuICAgIGlmICghb3B0aW9ucy5oaWRkZW4pIHtcbiAgICAgIHRoaXMuYWRkTmFtZWRFbWJlZGRlZEZpbGUob3B0aW9ucy5uYW1lLCBmaWxlc3BlYyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9yb290LmRhdGEuQUYpIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BRi5wdXNoKGZpbGVzcGVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLkFGID0gW2ZpbGVzcGVjXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzcGVjO1xuICB9XG59O1xuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLlN1YnR5cGUgPT09IGIuU3VidHlwZSAmJiBhLlBhcmFtcy5DaGVja1N1bS50b1N0cmluZygpID09PSBiLlBhcmFtcy5DaGVja1N1bS50b1N0cmluZygpICYmIGEuUGFyYW1zLlNpemUgPT09IGIuUGFyYW1zLlNpemUgJiYgYS5QYXJhbXMuQ3JlYXRpb25EYXRlLmdldFRpbWUoKSA9PT0gYi5QYXJhbXMuQ3JlYXRpb25EYXRlLmdldFRpbWUoKSAmJiAoYS5QYXJhbXMuTW9kRGF0ZSA9PT0gdW5kZWZpbmVkICYmIGIuUGFyYW1zLk1vZERhdGUgPT09IHVuZGVmaW5lZCB8fCBhLlBhcmFtcy5Nb2REYXRlLmdldFRpbWUoKSA9PT0gYi5QYXJhbXMuTW9kRGF0ZS5nZXRUaW1lKCkpO1xufVxuXG52YXIgUERGQSA9IHtcbiAgaW5pdFBERkEocFN1YnNldCkge1xuICAgIGlmIChwU3Vic2V0LmNoYXJBdChwU3Vic2V0Lmxlbmd0aCAtIDMpID09PSAnLScpIHtcbiAgICAgIHRoaXMuc3Vic2V0X2NvbmZvcm1hbmNlID0gcFN1YnNldC5jaGFyQXQocFN1YnNldC5sZW5ndGggLSAxKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdGhpcy5zdWJzZXQgPSBwYXJzZUludChwU3Vic2V0LmNoYXJBdChwU3Vic2V0Lmxlbmd0aCAtIDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdWJzZXRfY29uZm9ybWFuY2UgPSAnQic7XG4gICAgICB0aGlzLnN1YnNldCA9IHBhcnNlSW50KHBTdWJzZXQuY2hhckF0KHBTdWJzZXQubGVuZ3RoIC0gMSkpO1xuICAgIH1cbiAgfSxcbiAgZW5kU3Vic2V0KCkge1xuICAgIHRoaXMuX2FkZFBkZmFNZXRhZGF0YSgpO1xuICAgIHRoaXMuX2FkZENvbG9yT3V0cHV0SW50ZW50KCk7XG4gIH0sXG4gIF9hZGRDb2xvck91dHB1dEludGVudCgpIHtcbiAgICBjb25zdCBpY2NQcm9maWxlID0gZnMucmVhZEZpbGVTeW5jKGAke19fZGlybmFtZX0vZGF0YS9zUkdCX0lFQzYxOTY2XzJfMS5pY2NgKTtcbiAgICBjb25zdCBjb2xvclByb2ZpbGVSZWYgPSB0aGlzLnJlZih7XG4gICAgICBMZW5ndGg6IGljY1Byb2ZpbGUubGVuZ3RoLFxuICAgICAgTjogM1xuICAgIH0pO1xuICAgIGNvbG9yUHJvZmlsZVJlZi53cml0ZShpY2NQcm9maWxlKTtcbiAgICBjb2xvclByb2ZpbGVSZWYuZW5kKCk7XG4gICAgY29uc3QgaW50ZW50UmVmID0gdGhpcy5yZWYoe1xuICAgICAgVHlwZTogJ091dHB1dEludGVudCcsXG4gICAgICBTOiAnR1RTX1BERkExJyxcbiAgICAgIEluZm86IG5ldyBTdHJpbmcoJ3NSR0IgSUVDNjE5NjYtMi4xJyksXG4gICAgICBPdXRwdXRDb25kaXRpb25JZGVudGlmaWVyOiBuZXcgU3RyaW5nKCdzUkdCIElFQzYxOTY2LTIuMScpLFxuICAgICAgRGVzdE91dHB1dFByb2ZpbGU6IGNvbG9yUHJvZmlsZVJlZlxuICAgIH0pO1xuICAgIGludGVudFJlZi5lbmQoKTtcbiAgICB0aGlzLl9yb290LmRhdGEuT3V0cHV0SW50ZW50cyA9IFtpbnRlbnRSZWZdO1xuICB9LFxuICBfZ2V0UGRmYWlkKCkge1xuICAgIHJldHVybiBgXG4gICAgICAgIDxyZGY6RGVzY3JpcHRpb24geG1sbnM6cGRmYWlkPVwiaHR0cDovL3d3dy5haWltLm9yZy9wZGZhL25zL2lkL1wiIHJkZjphYm91dD1cIlwiPlxuICAgICAgICAgICAgPHBkZmFpZDpwYXJ0PiR7dGhpcy5zdWJzZXR9PC9wZGZhaWQ6cGFydD5cbiAgICAgICAgICAgIDxwZGZhaWQ6Y29uZm9ybWFuY2U+JHt0aGlzLnN1YnNldF9jb25mb3JtYW5jZX08L3BkZmFpZDpjb25mb3JtYW5jZT5cbiAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgIGA7XG4gIH0sXG4gIF9hZGRQZGZhTWV0YWRhdGEoKSB7XG4gICAgdGhpcy5hcHBlbmRYTUwodGhpcy5fZ2V0UGRmYWlkKCkpO1xuICB9XG59O1xuXG52YXIgUERGVUEgPSB7XG4gIGluaXRQREZVQSgpIHtcbiAgICB0aGlzLnN1YnNldCA9IDE7XG4gIH0sXG4gIGVuZFN1YnNldCgpIHtcbiAgICB0aGlzLl9hZGRQZGZ1YU1ldGFkYXRhKCk7XG4gIH0sXG4gIF9hZGRQZGZ1YU1ldGFkYXRhKCkge1xuICAgIHRoaXMuYXBwZW5kWE1MKHRoaXMuX2dldFBkZnVhaWQoKSk7XG4gIH0sXG4gIF9nZXRQZGZ1YWlkKCkge1xuICAgIHJldHVybiBgXG4gICAgICAgIDxyZGY6RGVzY3JpcHRpb24geG1sbnM6cGRmdWFpZD1cImh0dHA6Ly93d3cuYWlpbS5vcmcvcGRmdWEvbnMvaWQvXCIgcmRmOmFib3V0PVwiXCI+XG4gICAgICAgICAgICA8cGRmdWFpZDpwYXJ0PiR7dGhpcy5zdWJzZXR9PC9wZGZ1YWlkOnBhcnQ+XG4gICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxuICAgICAgICBgO1xuICB9XG59O1xuXG52YXIgU3Vic2V0TWl4aW4gPSB7XG4gIF9pbXBvcnRTdWJzZXQoc3Vic2V0KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzdWJzZXQpO1xuICB9LFxuICBpbml0U3Vic2V0KG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMuc3Vic2V0KSB7XG4gICAgICBjYXNlICdQREYvQS0xJzpcbiAgICAgIGNhc2UgJ1BERi9BLTFhJzpcbiAgICAgIGNhc2UgJ1BERi9BLTFiJzpcbiAgICAgIGNhc2UgJ1BERi9BLTInOlxuICAgICAgY2FzZSAnUERGL0EtMmEnOlxuICAgICAgY2FzZSAnUERGL0EtMmInOlxuICAgICAgY2FzZSAnUERGL0EtMyc6XG4gICAgICBjYXNlICdQREYvQS0zYSc6XG4gICAgICBjYXNlICdQREYvQS0zYic6XG4gICAgICAgIHRoaXMuX2ltcG9ydFN1YnNldChQREZBKTtcbiAgICAgICAgdGhpcy5pbml0UERGQShvcHRpb25zLnN1YnNldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUERGL1VBJzpcbiAgICAgICAgdGhpcy5faW1wb3J0U3Vic2V0KFBERlVBKTtcbiAgICAgICAgdGhpcy5pbml0UERGVUEoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBST1dfRklFTERTID0gWydoZWlnaHQnLCAnbWluSGVpZ2h0JywgJ21heEhlaWdodCddO1xuY29uc3QgQ09MVU1OX0ZJRUxEUyA9IFsnd2lkdGgnLCAnbWluV2lkdGgnLCAnbWF4V2lkdGgnXTtcbmZ1bmN0aW9uIG1lbW9pemUoZm4sIG1heFNpemUpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgIGlmICghY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIGNhY2hlLnNldChrZXksIGZuKC4uLmFyZ3VtZW50cykpO1xuICAgICAgaWYgKGNhY2hlLnNpemUgPiBtYXhTaXplKSBjYWNoZS5kZWxldGUoY2FjaGUua2V5cygpLm5leHQoKSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGl0ZW0pO1xufVxuZnVuY3Rpb24gZGVlcE1lcmdlKHRhcmdldCkge1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHJldHVybiB0YXJnZXQ7XG4gIHRhcmdldCA9IGRlZXBDbG9uZSh0YXJnZXQpO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgIGlmICghKGtleSBpbiB0YXJnZXQpKSB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgIHRhcmdldFtrZXldID0gZGVlcE1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gZGVlcENsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZGVlcENsb25lKG9iaikge1xuICBsZXQgcmVzdWx0ID0gb2JqO1xuICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcbiAgICByZXN1bHQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikgcmVzdWx0W2tleV0gPSBkZWVwQ2xvbmUob2JqW2tleV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZWREZWZhdWx0U3R5bGUoZGVmYXVsdFN0eWxlSW50ZXJuYWwpIHtcbiAgbGV0IGRlZmF1bHRTdHlsZSA9IGRlZmF1bHRTdHlsZUludGVybmFsO1xuICBpZiAodHlwZW9mIGRlZmF1bHRTdHlsZSAhPT0gJ29iamVjdCcpIGRlZmF1bHRTdHlsZSA9IHtcbiAgICB0ZXh0OiBkZWZhdWx0U3R5bGVcbiAgfTtcbiAgY29uc3QgZGVmYXVsdFJvd1N0eWxlID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGRlZmF1bHRTdHlsZSkuZmlsdGVyKF9yZWYgPT4ge1xuICAgIGxldCBba10gPSBfcmVmO1xuICAgIHJldHVybiBST1dfRklFTERTLmluY2x1ZGVzKGspO1xuICB9KSk7XG4gIGNvbnN0IGRlZmF1bHRDb2xTdHlsZSA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkZWZhdWx0U3R5bGUpLmZpbHRlcihfcmVmMiA9PiB7XG4gICAgbGV0IFtrXSA9IF9yZWYyO1xuICAgIHJldHVybiBDT0xVTU5fRklFTERTLmluY2x1ZGVzKGspO1xuICB9KSk7XG4gIGRlZmF1bHRTdHlsZS5wYWRkaW5nID0gbm9ybWFsaXplU2lkZXMoZGVmYXVsdFN0eWxlLnBhZGRpbmcpO1xuICBkZWZhdWx0U3R5bGUuYm9yZGVyID0gbm9ybWFsaXplU2lkZXMoZGVmYXVsdFN0eWxlLmJvcmRlcik7XG4gIGRlZmF1bHRTdHlsZS5ib3JkZXJDb2xvciA9IG5vcm1hbGl6ZVNpZGVzKGRlZmF1bHRTdHlsZS5ib3JkZXJDb2xvcik7XG4gIGRlZmF1bHRTdHlsZS5hbGlnbiA9IG5vcm1hbGl6ZUFsaWdubWVudChkZWZhdWx0U3R5bGUuYWxpZ24pO1xuICByZXR1cm4ge1xuICAgIGRlZmF1bHRTdHlsZSxcbiAgICBkZWZhdWx0Um93U3R5bGUsXG4gICAgZGVmYXVsdENvbFN0eWxlXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVkUm93U3R5bGUoZGVmYXVsdFJvd1N0eWxlLCByb3dTdHlsZUludGVybmFsLCBpKSB7XG4gIGxldCByb3dTdHlsZSA9IHJvd1N0eWxlSW50ZXJuYWwoaSk7XG4gIGlmIChyb3dTdHlsZSA9PSBudWxsIHx8IHR5cGVvZiByb3dTdHlsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByb3dTdHlsZSA9IHtcbiAgICAgIGhlaWdodDogcm93U3R5bGVcbiAgICB9O1xuICB9XG4gIHJvd1N0eWxlLnBhZGRpbmcgPSBub3JtYWxpemVTaWRlcyhyb3dTdHlsZS5wYWRkaW5nKTtcbiAgcm93U3R5bGUuYm9yZGVyID0gbm9ybWFsaXplU2lkZXMocm93U3R5bGUuYm9yZGVyKTtcbiAgcm93U3R5bGUuYm9yZGVyQ29sb3IgPSBub3JtYWxpemVTaWRlcyhyb3dTdHlsZS5ib3JkZXJDb2xvcik7XG4gIHJvd1N0eWxlLmFsaWduID0gbm9ybWFsaXplQWxpZ25tZW50KHJvd1N0eWxlLmFsaWduKTtcbiAgcm93U3R5bGUgPSBkZWVwTWVyZ2UoZGVmYXVsdFJvd1N0eWxlLCByb3dTdHlsZSk7XG4gIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcbiAgY29uc3QgcGFnZSA9IGRvY3VtZW50LnBhZ2U7XG4gIGNvbnN0IGNvbnRlbnRIZWlnaHQgPSBwYWdlLmNvbnRlbnRIZWlnaHQ7XG4gIGlmIChyb3dTdHlsZS5oZWlnaHQgPT0gbnVsbCB8fCByb3dTdHlsZS5oZWlnaHQgPT09ICdhdXRvJykge1xuICAgIHJvd1N0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgfSBlbHNlIHtcbiAgICByb3dTdHlsZS5oZWlnaHQgPSBkb2N1bWVudC5zaXplVG9Qb2ludChyb3dTdHlsZS5oZWlnaHQsIDAsIHBhZ2UsIGNvbnRlbnRIZWlnaHQpO1xuICB9XG4gIHJvd1N0eWxlLm1pbkhlaWdodCA9IGRvY3VtZW50LnNpemVUb1BvaW50KHJvd1N0eWxlLm1pbkhlaWdodCwgMCwgcGFnZSwgY29udGVudEhlaWdodCk7XG4gIHJvd1N0eWxlLm1heEhlaWdodCA9IGRvY3VtZW50LnNpemVUb1BvaW50KHJvd1N0eWxlLm1heEhlaWdodCwgMCwgcGFnZSwgY29udGVudEhlaWdodCk7XG4gIHJldHVybiByb3dTdHlsZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRDb2x1bW5TdHlsZShkZWZhdWx0Q29sU3R5bGUsIGNvbFN0eWxlSW50ZXJuYWwsIGkpIHtcbiAgbGV0IGNvbFN0eWxlID0gY29sU3R5bGVJbnRlcm5hbChpKTtcbiAgaWYgKGNvbFN0eWxlID09IG51bGwgfHwgdHlwZW9mIGNvbFN0eWxlICE9PSAnb2JqZWN0Jykge1xuICAgIGNvbFN0eWxlID0ge1xuICAgICAgd2lkdGg6IGNvbFN0eWxlXG4gICAgfTtcbiAgfVxuICBjb2xTdHlsZS5wYWRkaW5nID0gbm9ybWFsaXplU2lkZXMoY29sU3R5bGUucGFkZGluZyk7XG4gIGNvbFN0eWxlLmJvcmRlciA9IG5vcm1hbGl6ZVNpZGVzKGNvbFN0eWxlLmJvcmRlcik7XG4gIGNvbFN0eWxlLmJvcmRlckNvbG9yID0gbm9ybWFsaXplU2lkZXMoY29sU3R5bGUuYm9yZGVyQ29sb3IpO1xuICBjb2xTdHlsZS5hbGlnbiA9IG5vcm1hbGl6ZUFsaWdubWVudChjb2xTdHlsZS5hbGlnbik7XG4gIGNvbFN0eWxlID0gZGVlcE1lcmdlKGRlZmF1bHRDb2xTdHlsZSwgY29sU3R5bGUpO1xuICBpZiAoY29sU3R5bGUud2lkdGggPT0gbnVsbCB8fCBjb2xTdHlsZS53aWR0aCA9PT0gJyonKSB7XG4gICAgY29sU3R5bGUud2lkdGggPSAnKic7XG4gIH0gZWxzZSB7XG4gICAgY29sU3R5bGUud2lkdGggPSB0aGlzLmRvY3VtZW50LnNpemVUb1BvaW50KGNvbFN0eWxlLndpZHRoLCAwLCB0aGlzLmRvY3VtZW50LnBhZ2UsIHRoaXMuX21heFdpZHRoKTtcbiAgfVxuICBjb2xTdHlsZS5taW5XaWR0aCA9IHRoaXMuZG9jdW1lbnQuc2l6ZVRvUG9pbnQoY29sU3R5bGUubWluV2lkdGgsIDAsIHRoaXMuZG9jdW1lbnQucGFnZSwgdGhpcy5fbWF4V2lkdGgpO1xuICBjb2xTdHlsZS5tYXhXaWR0aCA9IHRoaXMuZG9jdW1lbnQuc2l6ZVRvUG9pbnQoY29sU3R5bGUubWF4V2lkdGgsIDAsIHRoaXMuZG9jdW1lbnQucGFnZSwgdGhpcy5fbWF4V2lkdGgpO1xuICByZXR1cm4gY29sU3R5bGU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbGlnbm1lbnQoYWxpZ24pIHtcbiAgcmV0dXJuIGFsaWduID09IG51bGwgfHwgdHlwZW9mIGFsaWduID09PSAnc3RyaW5nJyA/IHtcbiAgICB4OiBhbGlnbixcbiAgICB5OiBhbGlnblxuICB9IDogYWxpZ247XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhYmxlKCkge1xuICBjb25zdCBkb2MgPSB0aGlzLmRvY3VtZW50O1xuICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICBsZXQgaW5kZXggPSBkb2MuX3RhYmxlSW5kZXgrKztcbiAgdGhpcy5faWQgPSBuZXcgU3RyaW5nKG9wdHMuaWQgPz8gYHRhYmxlLSR7aW5kZXh9YCk7XG4gIHRoaXMuX3Bvc2l0aW9uID0ge1xuICAgIHg6IGRvYy5zaXplVG9Qb2ludChvcHRzLnBvc2l0aW9uPy54LCBkb2MueCksXG4gICAgeTogZG9jLnNpemVUb1BvaW50KG9wdHMucG9zaXRpb24/LnksIGRvYy55KVxuICB9O1xuICB0aGlzLl9tYXhXaWR0aCA9IGRvYy5zaXplVG9Qb2ludChvcHRzLm1heFdpZHRoLCBkb2MucGFnZS53aWR0aCAtIGRvYy5wYWdlLm1hcmdpbnMucmlnaHQgLSB0aGlzLl9wb3NpdGlvbi54KTtcbiAgY29uc3Qge1xuICAgIGRlZmF1bHRTdHlsZSxcbiAgICBkZWZhdWx0Q29sU3R5bGUsXG4gICAgZGVmYXVsdFJvd1N0eWxlXG4gIH0gPSBub3JtYWxpemVkRGVmYXVsdFN0eWxlKG9wdHMuZGVmYXVsdFN0eWxlKTtcbiAgdGhpcy5fZGVmYXVsdFN0eWxlID0gZGVmYXVsdFN0eWxlO1xuICBsZXQgY29sU3R5bGU7XG4gIGlmIChvcHRzLmNvbHVtblN0eWxlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMuY29sdW1uU3R5bGVzKSkge1xuICAgICAgY29sU3R5bGUgPSBpID0+IG9wdHMuY29sdW1uU3R5bGVzW2ldO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuY29sdW1uU3R5bGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb2xTdHlsZSA9IG1lbW9pemUoaSA9PiBvcHRzLmNvbHVtblN0eWxlcyhpKSwgSW5maW5pdHkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuY29sdW1uU3R5bGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgY29sU3R5bGUgPSAoKSA9PiBvcHRzLmNvbHVtblN0eWxlcztcbiAgICB9XG4gIH1cbiAgaWYgKCFjb2xTdHlsZSkgY29sU3R5bGUgPSAoKSA9PiAoe30pO1xuICB0aGlzLl9jb2xTdHlsZSA9IG5vcm1hbGl6ZWRDb2x1bW5TdHlsZS5iaW5kKHRoaXMsIGRlZmF1bHRDb2xTdHlsZSwgY29sU3R5bGUpO1xuICBsZXQgcm93U3R5bGU7XG4gIGlmIChvcHRzLnJvd1N0eWxlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMucm93U3R5bGVzKSkge1xuICAgICAgcm93U3R5bGUgPSBpID0+IG9wdHMucm93U3R5bGVzW2ldO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMucm93U3R5bGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByb3dTdHlsZSA9IG1lbW9pemUoaSA9PiBvcHRzLnJvd1N0eWxlcyhpKSwgMTApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMucm93U3R5bGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgcm93U3R5bGUgPSAoKSA9PiBvcHRzLnJvd1N0eWxlcztcbiAgICB9XG4gIH1cbiAgaWYgKCFyb3dTdHlsZSkgcm93U3R5bGUgPSAoKSA9PiAoe30pO1xuICB0aGlzLl9yb3dTdHlsZSA9IG5vcm1hbGl6ZWRSb3dTdHlsZS5iaW5kKHRoaXMsIGRlZmF1bHRSb3dTdHlsZSwgcm93U3R5bGUpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dCh0ZXh0KSB7XG4gIGlmICh0ZXh0ICE9IG51bGwpIHRleHQgPSBgJHt0ZXh0fWA7XG4gIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2VsbChjZWxsLCByb3dJbmRleCwgY29sSW5kZXgpIHtcbiAgY29uc3QgY29sU3R5bGUgPSB0aGlzLl9jb2xTdHlsZShjb2xJbmRleCk7XG4gIGxldCByb3dTdHlsZSA9IHRoaXMuX3Jvd1N0eWxlKHJvd0luZGV4KTtcbiAgY29uc3QgZm9udCA9IGRlZXBNZXJnZSh7fSwgY29sU3R5bGUuZm9udCwgcm93U3R5bGUuZm9udCwgY2VsbC5mb250KTtcbiAgY29uc3QgY3VzdG9tRm9udCA9IE9iamVjdC52YWx1ZXMoZm9udCkuZmlsdGVyKHYgPT4gdiAhPSBudWxsKS5sZW5ndGggPiAwO1xuICBjb25zdCBkb2MgPSB0aGlzLmRvY3VtZW50O1xuICBjb25zdCByb2xsYmFja0ZvbnQgPSBkb2MuX2ZvbnRTb3VyY2U7XG4gIGNvbnN0IHJvbGxiYWNrRm9udFNpemUgPSBkb2MuX2ZvbnRTaXplO1xuICBjb25zdCByb2xsYmFja0ZvbnRGYW1pbHkgPSBkb2MuX2ZvbnRGYW1pbHk7XG4gIGlmIChjdXN0b21Gb250KSB7XG4gICAgaWYgKGZvbnQuc3JjKSBkb2MuZm9udChmb250LnNyYywgZm9udC5mYW1pbHkpO1xuICAgIGlmIChmb250LnNpemUpIGRvYy5mb250U2l6ZShmb250LnNpemUpO1xuICAgIHJvd1N0eWxlID0gdGhpcy5fcm93U3R5bGUocm93SW5kZXgpO1xuICB9XG4gIGNlbGwucGFkZGluZyA9IG5vcm1hbGl6ZVNpZGVzKGNlbGwucGFkZGluZyk7XG4gIGNlbGwuYm9yZGVyID0gbm9ybWFsaXplU2lkZXMoY2VsbC5ib3JkZXIpO1xuICBjZWxsLmJvcmRlckNvbG9yID0gbm9ybWFsaXplU2lkZXMoY2VsbC5ib3JkZXJDb2xvcik7XG4gIGNvbnN0IGNvbmZpZyA9IGRlZXBNZXJnZSh0aGlzLl9kZWZhdWx0U3R5bGUsIGNvbFN0eWxlLCByb3dTdHlsZSwgY2VsbCk7XG4gIGNvbmZpZy5yb3dJbmRleCA9IHJvd0luZGV4O1xuICBjb25maWcuY29sSW5kZXggPSBjb2xJbmRleDtcbiAgY29uZmlnLmZvbnQgPSBmb250ID8/IHt9O1xuICBjb25maWcuY3VzdG9tRm9udCA9IGN1c3RvbUZvbnQ7XG4gIGNvbmZpZy50ZXh0ID0gbm9ybWFsaXplVGV4dChjb25maWcudGV4dCk7XG4gIGNvbmZpZy5yb3dTcGFuID0gY29uZmlnLnJvd1NwYW4gPz8gMTtcbiAgY29uZmlnLmNvbFNwYW4gPSBjb25maWcuY29sU3BhbiA/PyAxO1xuICBjb25maWcucGFkZGluZyA9IG5vcm1hbGl6ZVNpZGVzKGNvbmZpZy5wYWRkaW5nLCAnMC4yNWVtJywgeCA9PiBkb2Muc2l6ZVRvUG9pbnQoeCwgJzAuMjVlbScpKTtcbiAgY29uZmlnLmJvcmRlciA9IG5vcm1hbGl6ZVNpZGVzKGNvbmZpZy5ib3JkZXIsIDEsIHggPT4gZG9jLnNpemVUb1BvaW50KHgsIDEpKTtcbiAgY29uZmlnLmJvcmRlckNvbG9yID0gbm9ybWFsaXplU2lkZXMoY29uZmlnLmJvcmRlckNvbG9yLCAnYmxhY2snLCB4ID0+IHggPz8gJ2JsYWNrJyk7XG4gIGNvbmZpZy5hbGlnbiA9IG5vcm1hbGl6ZUFsaWdubWVudChjb25maWcuYWxpZ24pO1xuICBjb25maWcuYWxpZ24ueCA9IGNvbmZpZy5hbGlnbi54ID8/ICdsZWZ0JztcbiAgY29uZmlnLmFsaWduLnkgPSBjb25maWcuYWxpZ24ueSA/PyAndG9wJztcbiAgY29uZmlnLnRleHRTdHJva2UgPSBkb2Muc2l6ZVRvUG9pbnQoY29uZmlnLnRleHRTdHJva2UsIDApO1xuICBjb25maWcudGV4dFN0cm9rZUNvbG9yID0gY29uZmlnLnRleHRTdHJva2VDb2xvciA/PyAnYmxhY2snO1xuICBjb25maWcudGV4dENvbG9yID0gY29uZmlnLnRleHRDb2xvciA/PyAnYmxhY2snO1xuICBjb25maWcudGV4dE9wdGlvbnMgPSBjb25maWcudGV4dE9wdGlvbnMgPz8ge307XG4gIGNvbmZpZy5pZCA9IG5ldyBTdHJpbmcoY29uZmlnLmlkID8/IGAke3RoaXMuX2lkfS0ke3Jvd0luZGV4fS0ke2NvbEluZGV4fWApO1xuICBjb25maWcudHlwZSA9IGNvbmZpZy50eXBlPy50b1VwcGVyQ2FzZSgpID09PSAnVEgnID8gJ1RIJyA6ICdURCc7XG4gIGlmIChjb25maWcuc2NvcGUpIHtcbiAgICBjb25maWcuc2NvcGUgPSBjb25maWcuc2NvcGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoY29uZmlnLnNjb3BlID09PSAncm93JykgY29uZmlnLnNjb3BlID0gJ1Jvdyc7ZWxzZSBpZiAoY29uZmlnLnNjb3BlID09PSAnYm90aCcpIGNvbmZpZy5zY29wZSA9ICdCb3RoJztlbHNlIGlmIChjb25maWcuc2NvcGUgPT09ICdjb2x1bW4nKSBjb25maWcuc2NvcGUgPSAnQ29sdW1uJztcbiAgfVxuICBpZiAodHlwZW9mIHRoaXMub3B0cy5kZWJ1ZyA9PT0gJ2Jvb2xlYW4nKSBjb25maWcuZGVidWcgPSB0aGlzLm9wdHMuZGVidWc7XG4gIGlmIChjdXN0b21Gb250KSBkb2MuZm9udChyb2xsYmFja0ZvbnQsIHJvbGxiYWNrRm9udEZhbWlseSwgcm9sbGJhY2tGb250U2l6ZSk7XG4gIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBub3JtYWxpemVSb3cocm93LCByb3dJbmRleCkge1xuICBpZiAoIXRoaXMuX2NlbGxDbGFpbSkgdGhpcy5fY2VsbENsYWltID0gbmV3IFNldCgpO1xuICBsZXQgY29sSW5kZXggPSAwO1xuICByZXR1cm4gcm93Lm1hcChjZWxsID0+IHtcbiAgICBpZiAoY2VsbCA9PSBudWxsIHx8IHR5cGVvZiBjZWxsICE9PSAnb2JqZWN0JykgY2VsbCA9IHtcbiAgICAgIHRleHQ6IGNlbGxcbiAgICB9O1xuICAgIHdoaWxlICh0aGlzLl9jZWxsQ2xhaW0uaGFzKGAke3Jvd0luZGV4fSwke2NvbEluZGV4fWApKSB7XG4gICAgICBjb2xJbmRleCsrO1xuICAgIH1cbiAgICBjZWxsID0gbm9ybWFsaXplQ2VsbC5jYWxsKHRoaXMsIGNlbGwsIHJvd0luZGV4LCBjb2xJbmRleCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsLnJvd1NwYW47IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjZWxsLmNvbFNwYW47IGorKykge1xuICAgICAgICB0aGlzLl9jZWxsQ2xhaW0uYWRkKGAke3Jvd0luZGV4ICsgaX0sJHtjb2xJbmRleCArIGp9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbEluZGV4ICs9IGNlbGwuY29sU3BhbjtcbiAgICByZXR1cm4gY2VsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZShyb3cpIHtcbiAgdGhpcy5fY29sdW1uV2lkdGhzID0gW107XG4gIGVuc3VyZUNvbHVtbldpZHRocy5jYWxsKHRoaXMsIHJvdy5yZWR1Y2UoKGEsIGNlbGwpID0+IGEgKyBjZWxsLmNvbFNwYW4sIDApKTtcbiAgdGhpcy5fcm93SGVpZ2h0cyA9IFtdO1xuICB0aGlzLl9yb3dZUG9zID0gW3RoaXMuX3Bvc2l0aW9uLnldO1xuICB0aGlzLl9yb3dCdWZmZXIgPSBuZXcgU2V0KCk7XG59XG5mdW5jdGlvbiBlbnN1cmVDb2x1bW5XaWR0aHMobnVtQ29scykge1xuICBsZXQgc3RhckNvbHVtbkluZGV4ZXMgPSBbXTtcbiAgbGV0IHN0YXJNaW5BY2MgPSAwO1xuICBsZXQgdW5jbGFpbWVkV2lkdGggPSB0aGlzLl9tYXhXaWR0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2xzOyBpKyspIHtcbiAgICBsZXQgY29sID0gdGhpcy5fY29sU3R5bGUoaSk7XG4gICAgaWYgKGNvbC53aWR0aCA9PT0gJyonKSB7XG4gICAgICBzdGFyQ29sdW1uSW5kZXhlc1tpXSA9IGNvbDtcbiAgICAgIHN0YXJNaW5BY2MgKz0gY29sLm1pbldpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmNsYWltZWRXaWR0aCAtPSBjb2wud2lkdGg7XG4gICAgICB0aGlzLl9jb2x1bW5XaWR0aHNbaV0gPSBjb2wud2lkdGg7XG4gICAgfVxuICB9XG4gIGxldCBzdGFyQ29sQ291bnQgPSBzdGFyQ29sdW1uSW5kZXhlcy5yZWR1Y2UoeCA9PiB4ICsgMSwgMCk7XG4gIGlmIChzdGFyTWluQWNjID49IHVuY2xhaW1lZFdpZHRoKSB7XG4gICAgc3RhckNvbHVtbkluZGV4ZXMuZm9yRWFjaCgoY2VsbCwgaSkgPT4ge1xuICAgICAgdGhpcy5fY29sdW1uV2lkdGhzW2ldID0gY2VsbC5taW5XaWR0aDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzdGFyQ29sQ291bnQgPiAwKSB7XG4gICAgc3RhckNvbHVtbkluZGV4ZXMuZm9yRWFjaCgoY29sLCBpKSA9PiB7XG4gICAgICBsZXQgc3RhclNpemUgPSB1bmNsYWltZWRXaWR0aCAvIHN0YXJDb2xDb3VudDtcbiAgICAgIHRoaXMuX2NvbHVtbldpZHRoc1tpXSA9IE1hdGgubWF4KHN0YXJTaXplLCBjb2wubWluV2lkdGgpO1xuICAgICAgaWYgKGNvbC5tYXhXaWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fY29sdW1uV2lkdGhzW2ldID0gTWF0aC5taW4odGhpcy5fY29sdW1uV2lkdGhzW2ldLCBjb2wubWF4V2lkdGgpO1xuICAgICAgfVxuICAgICAgdW5jbGFpbWVkV2lkdGggLT0gdGhpcy5fY29sdW1uV2lkdGhzW2ldO1xuICAgICAgc3RhckNvbENvdW50LS07XG4gICAgfSk7XG4gIH1cbiAgbGV0IHRlbXBYID0gdGhpcy5fcG9zaXRpb24ueDtcbiAgdGhpcy5fY29sdW1uWFBvcyA9IEFycmF5LmZyb20odGhpcy5fY29sdW1uV2lkdGhzLCB2ID0+IHtcbiAgICBjb25zdCB0ID0gdGVtcFg7XG4gICAgdGVtcFggKz0gdjtcbiAgICByZXR1cm4gdDtcbiAgfSk7XG59XG5mdW5jdGlvbiBtZWFzdXJlKHJvdywgcm93SW5kZXgpIHtcbiAgcm93LmZvckVhY2goY2VsbCA9PiB0aGlzLl9yb3dCdWZmZXIuYWRkKGNlbGwpKTtcbiAgaWYgKHJvd0luZGV4ID4gMCkge1xuICAgIHRoaXMuX3Jvd1lQb3Nbcm93SW5kZXhdID0gdGhpcy5fcm93WVBvc1tyb3dJbmRleCAtIDFdICsgdGhpcy5fcm93SGVpZ2h0c1tyb3dJbmRleCAtIDFdO1xuICB9XG4gIGNvbnN0IHJvd1N0eWxlID0gdGhpcy5fcm93U3R5bGUocm93SW5kZXgpO1xuICBsZXQgdG9SZW5kZXIgPSBbXTtcbiAgdGhpcy5fcm93QnVmZmVyLmZvckVhY2goY2VsbCA9PiB7XG4gICAgaWYgKGNlbGwucm93SW5kZXggKyBjZWxsLnJvd1NwYW4gLSAxID09PSByb3dJbmRleCkge1xuICAgICAgdG9SZW5kZXIucHVzaChtZWFzdXJlQ2VsbC5jYWxsKHRoaXMsIGNlbGwsIHJvd1N0eWxlLmhlaWdodCkpO1xuICAgICAgdGhpcy5fcm93QnVmZmVyLmRlbGV0ZShjZWxsKTtcbiAgICB9XG4gIH0pO1xuICBsZXQgcm93SGVpZ2h0ID0gcm93U3R5bGUuaGVpZ2h0O1xuICBpZiAocm93SGVpZ2h0ID09PSAnYXV0bycpIHtcbiAgICByb3dIZWlnaHQgPSB0b1JlbmRlci5yZWR1Y2UoKGFjYywgY2VsbCkgPT4ge1xuICAgICAgbGV0IG1pbkhlaWdodCA9IGNlbGwudGV4dEJvdW5kcy5oZWlnaHQgKyBjZWxsLnBhZGRpbmcudG9wICsgY2VsbC5wYWRkaW5nLmJvdHRvbTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbC5yb3dTcGFuIC0gMTsgaSsrKSB7XG4gICAgICAgIG1pbkhlaWdodCAtPSB0aGlzLl9yb3dIZWlnaHRzW2NlbGwucm93SW5kZXggKyBpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLm1heChhY2MsIG1pbkhlaWdodCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgcm93SGVpZ2h0ID0gTWF0aC5tYXgocm93SGVpZ2h0LCByb3dTdHlsZS5taW5IZWlnaHQpO1xuICBpZiAocm93U3R5bGUubWF4SGVpZ2h0ID4gMCkge1xuICAgIHJvd0hlaWdodCA9IE1hdGgubWluKHJvd0hlaWdodCwgcm93U3R5bGUubWF4SGVpZ2h0KTtcbiAgfVxuICB0aGlzLl9yb3dIZWlnaHRzW3Jvd0luZGV4XSA9IHJvd0hlaWdodDtcbiAgbGV0IG5ld1BhZ2UgPSBmYWxzZTtcbiAgaWYgKHJvd0hlaWdodCA+IHRoaXMuZG9jdW1lbnQucGFnZS5jb250ZW50SGVpZ2h0KSB7XG4gICAgY29uc29sZS53YXJuKG5ldyBFcnJvcihgUm93ICR7cm93SW5kZXh9IHJlcXVlc3RlZCBtb3JlIHRoYW4gdGhlIHNhZmUgcGFnZSBoZWlnaHQsIHJvdyBoYXMgYmVlbiBjbGFtcGVkYCkuc3RhY2suc2xpY2UoNykpO1xuICAgIHRoaXMuX3Jvd0hlaWdodHNbcm93SW5kZXhdID0gdGhpcy5kb2N1bWVudC5wYWdlLm1heFkoKSAtIHRoaXMuX3Jvd1lQb3Nbcm93SW5kZXhdO1xuICB9IGVsc2UgaWYgKHRoaXMuX3Jvd1lQb3Nbcm93SW5kZXhdICsgcm93SGVpZ2h0ID49IHRoaXMuZG9jdW1lbnQucGFnZS5tYXhZKCkpIHtcbiAgICB0aGlzLl9yb3dZUG9zW3Jvd0luZGV4XSA9IHRoaXMuZG9jdW1lbnQucGFnZS5tYXJnaW5zLnRvcDtcbiAgICBuZXdQYWdlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5ld1BhZ2UsXG4gICAgdG9SZW5kZXI6IHRvUmVuZGVyLm1hcChjZWxsID0+IG1lYXN1cmVDZWxsLmNhbGwodGhpcywgY2VsbCwgcm93SGVpZ2h0KSlcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVDZWxsKGNlbGwsIHJvd0hlaWdodCkge1xuICBsZXQgY2VsbFdpZHRoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsLmNvbFNwYW47IGkrKykge1xuICAgIGNlbGxXaWR0aCArPSB0aGlzLl9jb2x1bW5XaWR0aHNbY2VsbC5jb2xJbmRleCArIGldO1xuICB9XG4gIGxldCBjZWxsSGVpZ2h0ID0gcm93SGVpZ2h0O1xuICBpZiAoY2VsbEhlaWdodCA9PT0gJ2F1dG8nKSB7XG4gICAgY2VsbEhlaWdodCA9IHRoaXMuZG9jdW1lbnQucGFnZS5jb250ZW50SGVpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbC5yb3dTcGFuIC0gMTsgaSsrKSB7XG4gICAgICBjZWxsSGVpZ2h0ICs9IHRoaXMuX3Jvd0hlaWdodHNbY2VsbC5yb3dJbmRleCArIGldO1xuICAgIH1cbiAgfVxuICBjb25zdCB0ZXh0QWxsb2NhdGVkV2lkdGggPSBjZWxsV2lkdGggLSBjZWxsLnBhZGRpbmcubGVmdCAtIGNlbGwucGFkZGluZy5yaWdodDtcbiAgY29uc3QgdGV4dEFsbG9jYXRlZEhlaWdodCA9IGNlbGxIZWlnaHQgLSBjZWxsLnBhZGRpbmcudG9wIC0gY2VsbC5wYWRkaW5nLmJvdHRvbTtcbiAgY29uc3Qgcm90YXRpb24gPSBjZWxsLnRleHRPcHRpb25zLnJvdGF0aW9uID8/IDA7XG4gIGNvbnN0IHtcbiAgICB3aWR0aDogdGV4dE1heFdpZHRoLFxuICAgIGhlaWdodDogdGV4dE1heEhlaWdodFxuICB9ID0gY29tcHV0ZUJvdW5kcyhyb3RhdGlvbiwgdGV4dEFsbG9jYXRlZFdpZHRoLCB0ZXh0QWxsb2NhdGVkSGVpZ2h0KTtcbiAgY29uc3QgdGV4dE9wdGlvbnMgPSB7XG4gICAgYWxpZ246IGNlbGwuYWxpZ24ueCxcbiAgICBlbGxpcHNpczogdHJ1ZSxcbiAgICBzdHJva2U6IGNlbGwudGV4dFN0cm9rZSA+IDAsXG4gICAgZmlsbDogdHJ1ZSxcbiAgICB3aWR0aDogdGV4dE1heFdpZHRoLFxuICAgIGhlaWdodDogdGV4dE1heEhlaWdodCxcbiAgICByb3RhdGlvbixcbiAgICAuLi5jZWxsLnRleHRPcHRpb25zXG4gIH07XG4gIGxldCB0ZXh0Qm91bmRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbiAgaWYgKGNlbGwudGV4dCkge1xuICAgIGNvbnN0IHJvbGxiYWNrRm9udCA9IHRoaXMuZG9jdW1lbnQuX2ZvbnRTb3VyY2U7XG4gICAgY29uc3Qgcm9sbGJhY2tGb250U2l6ZSA9IHRoaXMuZG9jdW1lbnQuX2ZvbnRTaXplO1xuICAgIGNvbnN0IHJvbGxiYWNrRm9udEZhbWlseSA9IHRoaXMuZG9jdW1lbnQuX2ZvbnRGYW1pbHk7XG4gICAgaWYgKGNlbGwuZm9udD8uc3JjKSB0aGlzLmRvY3VtZW50LmZvbnQoY2VsbC5mb250LnNyYywgY2VsbC5mb250Py5mYW1pbHkpO1xuICAgIGlmIChjZWxsLmZvbnQ/LnNpemUpIHRoaXMuZG9jdW1lbnQuZm9udFNpemUoY2VsbC5mb250LnNpemUpO1xuICAgIGNvbnN0IHVuUm90YXRlZFRleHRCb3VuZHMgPSB0aGlzLmRvY3VtZW50LmJvdW5kc09mU3RyaW5nKGNlbGwudGV4dCwgMCwgMCwge1xuICAgICAgLi4udGV4dE9wdGlvbnMsXG4gICAgICByb3RhdGlvbjogMFxuICAgIH0pO1xuICAgIHRleHRPcHRpb25zLndpZHRoID0gdW5Sb3RhdGVkVGV4dEJvdW5kcy53aWR0aDtcbiAgICB0ZXh0T3B0aW9ucy5oZWlnaHQgPSB1blJvdGF0ZWRUZXh0Qm91bmRzLmhlaWdodDtcbiAgICB0ZXh0Qm91bmRzID0gdGhpcy5kb2N1bWVudC5ib3VuZHNPZlN0cmluZyhjZWxsLnRleHQsIDAsIDAsIHRleHRPcHRpb25zKTtcbiAgICB0aGlzLmRvY3VtZW50LmZvbnQocm9sbGJhY2tGb250LCByb2xsYmFja0ZvbnRGYW1pbHksIHJvbGxiYWNrRm9udFNpemUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uY2VsbCxcbiAgICB0ZXh0T3B0aW9ucyxcbiAgICB4OiB0aGlzLl9jb2x1bW5YUG9zW2NlbGwuY29sSW5kZXhdLFxuICAgIHk6IHRoaXMuX3Jvd1lQb3NbY2VsbC5yb3dJbmRleF0sXG4gICAgdGV4dFg6IHRoaXMuX2NvbHVtblhQb3NbY2VsbC5jb2xJbmRleF0gKyBjZWxsLnBhZGRpbmcubGVmdCxcbiAgICB0ZXh0WTogdGhpcy5fcm93WVBvc1tjZWxsLnJvd0luZGV4XSArIGNlbGwucGFkZGluZy50b3AsXG4gICAgd2lkdGg6IGNlbGxXaWR0aCxcbiAgICBoZWlnaHQ6IGNlbGxIZWlnaHQsXG4gICAgdGV4dEFsbG9jYXRlZEhlaWdodCxcbiAgICB0ZXh0QWxsb2NhdGVkV2lkdGgsXG4gICAgdGV4dEJvdW5kc1xuICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kcyhyb3RhdGlvbiwgYWxsb2NXaWR0aCwgYWxsb2NIZWlnaHQpIHtcbiAgbGV0IHRleHRNYXhXaWR0aCwgdGV4dE1heEhlaWdodDtcbiAgY29uc3QgY29zID0gY29zaW5lKHJvdGF0aW9uKTtcbiAgY29uc3Qgc2luID0gc2luZShyb3RhdGlvbik7XG4gIGlmIChyb3RhdGlvbiA9PT0gMCB8fCByb3RhdGlvbiA9PT0gMTgwKSB7XG4gICAgdGV4dE1heFdpZHRoID0gYWxsb2NXaWR0aDtcbiAgICB0ZXh0TWF4SGVpZ2h0ID0gYWxsb2NIZWlnaHQ7XG4gIH0gZWxzZSBpZiAocm90YXRpb24gPT09IDkwIHx8IHJvdGF0aW9uID09PSAyNzApIHtcbiAgICB0ZXh0TWF4V2lkdGggPSBhbGxvY0hlaWdodDtcbiAgICB0ZXh0TWF4SGVpZ2h0ID0gYWxsb2NXaWR0aDtcbiAgfSBlbHNlIGlmIChyb3RhdGlvbiA8IDkwIHx8IHJvdGF0aW9uID4gMTgwICYmIHJvdGF0aW9uIDwgMjcwKSB7XG4gICAgdGV4dE1heFdpZHRoID0gYWxsb2NXaWR0aCAvICgyICogY29zKTtcbiAgICB0ZXh0TWF4SGVpZ2h0ID0gYWxsb2NXaWR0aCAvICgyICogc2luKTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0TWF4SGVpZ2h0ID0gYWxsb2NXaWR0aCAvICgyICogY29zKTtcbiAgICB0ZXh0TWF4V2lkdGggPSBhbGxvY1dpZHRoIC8gKDIgKiBzaW4pO1xuICB9XG4gIGNvbnN0IEVGID0gc2luICogdGV4dE1heFdpZHRoO1xuICBjb25zdCBGRyA9IGNvcyAqIHRleHRNYXhIZWlnaHQ7XG4gIGlmIChFRiArIEZHID4gYWxsb2NIZWlnaHQpIHtcbiAgICBjb25zdCBkZW5vbWluYXRvciA9IGNvcyAqIGNvcyAtIHNpbiAqIHNpbjtcbiAgICBpZiAocm90YXRpb24gPT09IDAgfHwgcm90YXRpb24gPT09IDE4MCkge1xuICAgICAgdGV4dE1heFdpZHRoID0gYWxsb2NXaWR0aDtcbiAgICAgIHRleHRNYXhIZWlnaHQgPSBhbGxvY0hlaWdodDtcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uID09PSA5MCB8fCByb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICB0ZXh0TWF4V2lkdGggPSBhbGxvY0hlaWdodDtcbiAgICAgIHRleHRNYXhIZWlnaHQgPSBhbGxvY1dpZHRoO1xuICAgIH0gZWxzZSBpZiAocm90YXRpb24gPCA5MCB8fCByb3RhdGlvbiA+IDE4MCAmJiByb3RhdGlvbiA8IDI3MCkge1xuICAgICAgdGV4dE1heFdpZHRoID0gKGFsbG9jV2lkdGggKiBjb3MgLSBhbGxvY0hlaWdodCAqIHNpbikgLyBkZW5vbWluYXRvcjtcbiAgICAgIHRleHRNYXhIZWlnaHQgPSAoYWxsb2NIZWlnaHQgKiBjb3MgLSBhbGxvY1dpZHRoICogc2luKSAvIGRlbm9taW5hdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0TWF4SGVpZ2h0ID0gKGFsbG9jV2lkdGggKiBjb3MgLSBhbGxvY0hlaWdodCAqIHNpbikgLyBkZW5vbWluYXRvcjtcbiAgICAgIHRleHRNYXhXaWR0aCA9IChhbGxvY0hlaWdodCAqIGNvcyAtIGFsbG9jV2lkdGggKiBzaW4pIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IE1hdGguYWJzKHRleHRNYXhXaWR0aCksXG4gICAgaGVpZ2h0OiBNYXRoLmFicyh0ZXh0TWF4SGVpZ2h0KVxuICB9O1xufVxuXG5mdW5jdGlvbiBhY2NvbW1vZGF0ZVRhYmxlKCkge1xuICBjb25zdCBzdHJ1Y3RQYXJlbnQgPSB0aGlzLm9wdHMuc3RydWN0UGFyZW50O1xuICBpZiAoc3RydWN0UGFyZW50KSB7XG4gICAgdGhpcy5fdGFibGVTdHJ1Y3QgPSB0aGlzLmRvY3VtZW50LnN0cnVjdCgnVGFibGUnKTtcbiAgICB0aGlzLl90YWJsZVN0cnVjdC5kaWN0aW9uYXJ5LmRhdGEuSUQgPSB0aGlzLl9pZDtcbiAgICBpZiAoc3RydWN0UGFyZW50IGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCkge1xuICAgICAgc3RydWN0UGFyZW50LmFkZCh0aGlzLl90YWJsZVN0cnVjdCk7XG4gICAgfSBlbHNlIGlmIChzdHJ1Y3RQYXJlbnQgaW5zdGFuY2VvZiBQREZEb2N1bWVudCkge1xuICAgICAgc3RydWN0UGFyZW50LmFkZFN0cnVjdHVyZSh0aGlzLl90YWJsZVN0cnVjdCk7XG4gICAgfVxuICAgIHRoaXMuX2hlYWRlclJvd0xvb2t1cCA9IHt9O1xuICAgIHRoaXMuX2hlYWRlckNvbHVtbkxvb2t1cCA9IHt9O1xuICB9XG59XG5mdW5jdGlvbiBhY2NvbW1vZGF0ZUNsZWFudXAoKSB7XG4gIGlmICh0aGlzLl90YWJsZVN0cnVjdCkgdGhpcy5fdGFibGVTdHJ1Y3QuZW5kKCk7XG59XG5mdW5jdGlvbiBhY2Nlc3NpYmxlUm93KHJvdywgcm93SW5kZXgsIHJlbmRlckNlbGwpIHtcbiAgY29uc3Qgcm93U3RydWN0ID0gdGhpcy5kb2N1bWVudC5zdHJ1Y3QoJ1RSJyk7XG4gIHJvd1N0cnVjdC5kaWN0aW9uYXJ5LmRhdGEuSUQgPSBuZXcgU3RyaW5nKGAke3RoaXMuX2lkfS0ke3Jvd0luZGV4fWApO1xuICB0aGlzLl90YWJsZVN0cnVjdC5hZGQocm93U3RydWN0KTtcbiAgcm93LmZvckVhY2goY2VsbCA9PiByZW5kZXJDZWxsKGNlbGwsIHJvd1N0cnVjdCkpO1xuICByb3dTdHJ1Y3QuZW5kKCk7XG59XG5mdW5jdGlvbiBhY2Nlc3NpYmxlQ2VsbChjZWxsLCByb3dTdHJ1Y3QsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGRvYyA9IHRoaXMuZG9jdW1lbnQ7XG4gIGNvbnN0IGNlbGxTdHJ1Y3QgPSBkb2Muc3RydWN0KGNlbGwudHlwZSwge1xuICAgIHRpdGxlOiBjZWxsLnRpdGxlXG4gIH0pO1xuICBjZWxsU3RydWN0LmRpY3Rpb25hcnkuZGF0YS5JRCA9IGNlbGwuaWQ7XG4gIHJvd1N0cnVjdC5hZGQoY2VsbFN0cnVjdCk7XG4gIGNvbnN0IHBhZGRpbmcgPSBjZWxsLnBhZGRpbmc7XG4gIGNvbnN0IGJvcmRlciA9IGNlbGwuYm9yZGVyO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIE86ICdUYWJsZScsXG4gICAgV2lkdGg6IGNlbGwud2lkdGgsXG4gICAgSGVpZ2h0OiBjZWxsLmhlaWdodCxcbiAgICBQYWRkaW5nOiBbcGFkZGluZy50b3AsIHBhZGRpbmcuYm90dG9tLCBwYWRkaW5nLmxlZnQsIHBhZGRpbmcucmlnaHRdLFxuICAgIFJvd1NwYW46IGNlbGwucm93U3BhbiA+IDEgPyBjZWxsLnJvd1NwYW4gOiB1bmRlZmluZWQsXG4gICAgQ29sU3BhbjogY2VsbC5jb2xTcGFuID4gMSA/IGNlbGwuY29sU3BhbiA6IHVuZGVmaW5lZCxcbiAgICBCb3JkZXJUaGlja25lc3M6IFtib3JkZXIudG9wLCBib3JkZXIuYm90dG9tLCBib3JkZXIubGVmdCwgYm9yZGVyLnJpZ2h0XVxuICB9O1xuICBpZiAoY2VsbC50eXBlID09PSAnVEgnKSB7XG4gICAgaWYgKGNlbGwuc2NvcGUgPT09ICdSb3cnIHx8IGNlbGwuc2NvcGUgPT09ICdCb3RoJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsLnJvd1NwYW47IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWRlclJvd0xvb2t1cFtjZWxsLnJvd0luZGV4ICsgaV0pIHtcbiAgICAgICAgICB0aGlzLl9oZWFkZXJSb3dMb29rdXBbY2VsbC5yb3dJbmRleCArIGldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZGVyUm93TG9va3VwW2NlbGwucm93SW5kZXggKyBpXS5wdXNoKGNlbGwuaWQpO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcy5TY29wZSA9IGNlbGwuc2NvcGU7XG4gICAgfVxuICAgIGlmIChjZWxsLnNjb3BlID09PSAnQ29sdW1uJyB8fCBjZWxsLnNjb3BlID09PSAnQm90aCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbC5jb2xTcGFuOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkZXJDb2x1bW5Mb29rdXBbY2VsbC5jb2xJbmRleCArIGldKSB7XG4gICAgICAgICAgdGhpcy5faGVhZGVyQ29sdW1uTG9va3VwW2NlbGwuY29sSW5kZXggKyBpXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWRlckNvbHVtbkxvb2t1cFtjZWxsLmNvbEluZGV4ICsgaV0ucHVzaChjZWxsLmlkKTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMuU2NvcGUgPSBjZWxsLnNjb3BlO1xuICAgIH1cbiAgfVxuICBjb25zdCBIZWFkZXJzID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBjZWxsLmNvbFNwYW5cbiAgfSwgKF8sIGkpID0+IHRoaXMuX2hlYWRlckNvbHVtbkxvb2t1cFtjZWxsLmNvbEluZGV4ICsgaV0pLmZsYXQoKSwgLi4uQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBjZWxsLnJvd1NwYW5cbiAgfSwgKF8sIGkpID0+IHRoaXMuX2hlYWRlclJvd0xvb2t1cFtjZWxsLnJvd0luZGV4ICsgaV0pLmZsYXQoKV0uZmlsdGVyKEJvb2xlYW4pKTtcbiAgaWYgKEhlYWRlcnMuc2l6ZSkgYXR0cmlidXRlcy5IZWFkZXJzID0gQXJyYXkuZnJvbShIZWFkZXJzKTtcbiAgY29uc3Qgbm9ybWFsaXplQ29sb3IgPSBkb2MuX25vcm1hbGl6ZUNvbG9yO1xuICBpZiAoY2VsbC5iYWNrZ3JvdW5kQ29sb3IgIT0gbnVsbCkge1xuICAgIGF0dHJpYnV0ZXMuQmFja2dyb3VuZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY2VsbC5iYWNrZ3JvdW5kQ29sb3IpO1xuICB9XG4gIGNvbnN0IGhhc0JvcmRlciA9IFtib3JkZXIudG9wLCBib3JkZXIuYm90dG9tLCBib3JkZXIubGVmdCwgYm9yZGVyLnJpZ2h0XTtcbiAgaWYgKGhhc0JvcmRlci5zb21lKHggPT4geCkpIHtcbiAgICBjb25zdCBib3JkZXJDb2xvciA9IGNlbGwuYm9yZGVyQ29sb3I7XG4gICAgYXR0cmlidXRlcy5Cb3JkZXJDb2xvciA9IFtoYXNCb3JkZXJbMF0gPyBub3JtYWxpemVDb2xvcihib3JkZXJDb2xvci50b3ApIDogbnVsbCwgaGFzQm9yZGVyWzFdID8gbm9ybWFsaXplQ29sb3IoYm9yZGVyQ29sb3IuYm90dG9tKSA6IG51bGwsIGhhc0JvcmRlclsyXSA/IG5vcm1hbGl6ZUNvbG9yKGJvcmRlckNvbG9yLmxlZnQpIDogbnVsbCwgaGFzQm9yZGVyWzNdID8gbm9ybWFsaXplQ29sb3IoYm9yZGVyQ29sb3IucmlnaHQpIDogbnVsbF07XG4gIH1cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChrZXkgPT4gYXR0cmlidXRlc1trZXldID09PSB1bmRlZmluZWQgJiYgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XSk7XG4gIGNlbGxTdHJ1Y3QuZGljdGlvbmFyeS5kYXRhLkEgPSBkb2MucmVmKGF0dHJpYnV0ZXMpO1xuICBjZWxsU3RydWN0LmFkZChjYWxsYmFjayk7XG4gIGNlbGxTdHJ1Y3QuZW5kKCk7XG4gIGNlbGxTdHJ1Y3QuZGljdGlvbmFyeS5kYXRhLkEuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvdyhyb3csIHJvd0luZGV4KSB7XG4gIGlmICh0aGlzLl90YWJsZVN0cnVjdCkge1xuICAgIGFjY2Vzc2libGVSb3cuY2FsbCh0aGlzLCByb3csIHJvd0luZGV4LCByZW5kZXJDZWxsLmJpbmQodGhpcykpO1xuICB9IGVsc2Uge1xuICAgIHJvdy5mb3JFYWNoKGNlbGwgPT4gcmVuZGVyQ2VsbC5jYWxsKHRoaXMsIGNlbGwpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fcm93WVBvc1tyb3dJbmRleF0gKyB0aGlzLl9yb3dIZWlnaHRzW3Jvd0luZGV4XTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNlbGwoY2VsbCwgcm93U3RydWN0KSB7XG4gIGNvbnN0IGNlbGxSZW5kZXJlciA9ICgpID0+IHtcbiAgICBpZiAoY2VsbC5iYWNrZ3JvdW5kQ29sb3IgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kb2N1bWVudC5zYXZlKCkucmVjdChjZWxsLngsIGNlbGwueSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQpLmZpbGwoY2VsbC5iYWNrZ3JvdW5kQ29sb3IpLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgcmVuZGVyQm9yZGVyLmNhbGwodGhpcywgY2VsbC5ib3JkZXIsIGNlbGwuYm9yZGVyQ29sb3IsIGNlbGwueCwgY2VsbC55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCk7XG4gICAgaWYgKGNlbGwuZGVidWcpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnQuc2F2ZSgpO1xuICAgICAgdGhpcy5kb2N1bWVudC5kYXNoKDEsIHtcbiAgICAgICAgc3BhY2U6IDFcbiAgICAgIH0pLmxpbmVXaWR0aCgxKS5zdHJva2VPcGFjaXR5KDAuMyk7XG4gICAgICB0aGlzLmRvY3VtZW50LnJlY3QoY2VsbC54LCBjZWxsLnksIGNlbGwud2lkdGgsIGNlbGwuaGVpZ2h0KS5zdHJva2UoJ2dyZWVuJyk7XG4gICAgICB0aGlzLmRvY3VtZW50LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGNlbGwudGV4dCkgcmVuZGVyQ2VsbFRleHQuY2FsbCh0aGlzLCBjZWxsKTtcbiAgfTtcbiAgaWYgKHJvd1N0cnVjdCkgYWNjZXNzaWJsZUNlbGwuY2FsbCh0aGlzLCBjZWxsLCByb3dTdHJ1Y3QsIGNlbGxSZW5kZXJlcik7ZWxzZSBjZWxsUmVuZGVyZXIoKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNlbGxUZXh0KGNlbGwpIHtcbiAgY29uc3QgZG9jID0gdGhpcy5kb2N1bWVudDtcbiAgY29uc3Qgcm9sbGJhY2tGb250ID0gZG9jLl9mb250U291cmNlO1xuICBjb25zdCByb2xsYmFja0ZvbnRTaXplID0gZG9jLl9mb250U2l6ZTtcbiAgY29uc3Qgcm9sbGJhY2tGb250RmFtaWx5ID0gZG9jLl9mb250RmFtaWx5O1xuICBpZiAoY2VsbC5jdXN0b21Gb250KSB7XG4gICAgaWYgKGNlbGwuZm9udC5zcmMpIGRvYy5mb250KGNlbGwuZm9udC5zcmMsIGNlbGwuZm9udC5mYW1pbHkpO1xuICAgIGlmIChjZWxsLmZvbnQuc2l6ZSkgZG9jLmZvbnRTaXplKGNlbGwuZm9udC5zaXplKTtcbiAgfVxuICBjb25zdCB4ID0gY2VsbC50ZXh0WDtcbiAgY29uc3QgeSA9IGNlbGwudGV4dFk7XG4gIGNvbnN0IEFoID0gY2VsbC50ZXh0QWxsb2NhdGVkSGVpZ2h0O1xuICBjb25zdCBBdyA9IGNlbGwudGV4dEFsbG9jYXRlZFdpZHRoO1xuICBjb25zdCBDdyA9IGNlbGwudGV4dEJvdW5kcy53aWR0aDtcbiAgY29uc3QgQ2ggPSBjZWxsLnRleHRCb3VuZHMuaGVpZ2h0O1xuICBjb25zdCBPeCA9IC1jZWxsLnRleHRCb3VuZHMueDtcbiAgY29uc3QgT3kgPSAtY2VsbC50ZXh0Qm91bmRzLnk7XG4gIGNvbnN0IFB4U2NhbGUgPSBjZWxsLmFsaWduLnggPT09ICdyaWdodCcgPyAxIDogY2VsbC5hbGlnbi54ID09PSAnY2VudGVyJyA/IDAuNSA6IDA7XG4gIGNvbnN0IFB4ID0gKEF3IC0gQ3cpICogUHhTY2FsZTtcbiAgY29uc3QgUHlTY2FsZSA9IGNlbGwuYWxpZ24ueSA9PT0gJ2JvdHRvbScgPyAxIDogY2VsbC5hbGlnbi55ID09PSAnY2VudGVyJyA/IDAuNSA6IDA7XG4gIGNvbnN0IFB5ID0gKEFoIC0gQ2gpICogUHlTY2FsZTtcbiAgY29uc3QgZHggPSBQeCArIE94O1xuICBjb25zdCBkeSA9IFB5ICsgT3k7XG4gIGlmIChjZWxsLmRlYnVnKSB7XG4gICAgZG9jLnNhdmUoKTtcbiAgICBkb2MuZGFzaCgxLCB7XG4gICAgICBzcGFjZTogMVxuICAgIH0pLmxpbmVXaWR0aCgxKS5zdHJva2VPcGFjaXR5KDAuMyk7XG4gICAgaWYgKGNlbGwudGV4dCkge1xuICAgICAgZG9jLm1vdmVUbyh4ICsgUHgsIHkpLmxpbmVUbyh4ICsgUHgsIHkgKyBBaCkubW92ZVRvKHggKyBQeCArIEN3LCB5KS5saW5lVG8oeCArIFB4ICsgQ3csIHkgKyBBaCkuc3Ryb2tlKCdibHVlJykubW92ZVRvKHgsIHkgKyBQeSkubGluZVRvKHggKyBBdywgeSArIFB5KS5tb3ZlVG8oeCwgeSArIFB5ICsgQ2gpLmxpbmVUbyh4ICsgQXcsIHkgKyBQeSArIENoKS5zdHJva2UoJ2dyZWVuJyk7XG4gICAgfVxuICAgIGRvYy5yZWN0KHgsIHksIEF3LCBBaCkuc3Ryb2tlKCdvcmFuZ2UnKTtcbiAgICBkb2MucmVzdG9yZSgpO1xuICB9XG4gIGRvYy5zYXZlKCkucmVjdCh4LCB5LCBBdywgQWgpLmNsaXAoKTtcbiAgZG9jLmZpbGxDb2xvcihjZWxsLnRleHRDb2xvcikuc3Ryb2tlQ29sb3IoY2VsbC50ZXh0U3Ryb2tlQ29sb3IpO1xuICBpZiAoY2VsbC50ZXh0U3Ryb2tlID4gMCkgZG9jLmxpbmVXaWR0aChjZWxsLnRleHRTdHJva2UpO1xuICBkb2MudGV4dChjZWxsLnRleHQsIHggKyBkeCwgeSArIGR5LCBjZWxsLnRleHRPcHRpb25zKTtcbiAgZG9jLnJlc3RvcmUoKTtcbiAgaWYgKGNlbGwuZm9udCkgZG9jLmZvbnQocm9sbGJhY2tGb250LCByb2xsYmFja0ZvbnRGYW1pbHksIHJvbGxiYWNrRm9udFNpemUpO1xufVxuZnVuY3Rpb24gcmVuZGVyQm9yZGVyKGJvcmRlciwgYm9yZGVyQ29sb3IsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1hc2spIHtcbiAgYm9yZGVyID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGJvcmRlcikubWFwKF9yZWYgPT4ge1xuICAgIGxldCBbaywgdl0gPSBfcmVmO1xuICAgIHJldHVybiBbaywgbWFzayAmJiAhbWFza1trXSA/IDAgOiB2XTtcbiAgfSkpO1xuICBjb25zdCBkb2MgPSB0aGlzLmRvY3VtZW50O1xuICBpZiAoW2JvcmRlci5yaWdodCwgYm9yZGVyLmJvdHRvbSwgYm9yZGVyLmxlZnRdLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IGJvcmRlci50b3ApKSB7XG4gICAgaWYgKGJvcmRlci50b3AgPiAwKSB7XG4gICAgICBkb2Muc2F2ZSgpLmxpbmVXaWR0aChib3JkZXIudG9wKS5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpLnN0cm9rZShib3JkZXJDb2xvci50b3ApLnJlc3RvcmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJvcmRlci50b3AgPiAwKSB7XG4gICAgICBkb2Muc2F2ZSgpLmxpbmVXaWR0aChib3JkZXIudG9wKS5tb3ZlVG8oeCwgeSkubGluZVRvKHggKyB3aWR0aCwgeSkuc3Ryb2tlKGJvcmRlckNvbG9yLnRvcCkucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyLnJpZ2h0ID4gMCkge1xuICAgICAgZG9jLnNhdmUoKS5saW5lV2lkdGgoYm9yZGVyLnJpZ2h0KS5tb3ZlVG8oeCArIHdpZHRoLCB5KS5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KS5zdHJva2UoYm9yZGVyQ29sb3IucmlnaHQpLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGJvcmRlci5ib3R0b20gPiAwKSB7XG4gICAgICBkb2Muc2F2ZSgpLmxpbmVXaWR0aChib3JkZXIuYm90dG9tKS5tb3ZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KS5saW5lVG8oeCwgeSArIGhlaWdodCkuc3Ryb2tlKGJvcmRlckNvbG9yLmJvdHRvbSkucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyLmxlZnQgPiAwKSB7XG4gICAgICBkb2Muc2F2ZSgpLmxpbmVXaWR0aChib3JkZXIubGVmdCkubW92ZVRvKHgsIHkgKyBoZWlnaHQpLmxpbmVUbyh4LCB5KS5zdHJva2UoYm9yZGVyQ29sb3IubGVmdCkucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBQREZUYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLm9wdHMgPSBPYmplY3QuZnJlZXplKG9wdHMpO1xuICAgIG5vcm1hbGl6ZVRhYmxlLmNhbGwodGhpcyk7XG4gICAgYWNjb21tb2RhdGVUYWJsZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX2N1cnJSb3dJbmRleCA9IDA7XG4gICAgdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBvcHRzLmRhdGEpIHRoaXMucm93KHJvdyk7XG4gICAgICByZXR1cm4gdGhpcy5lbmQoKTtcbiAgICB9XG4gIH1cbiAgcm93KHJvdykge1xuICAgIGxldCBsYXN0Um93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGFibGUgd2FzIG1hcmtlZCBhcyBlbmRlZCBvbiByb3cgJHt0aGlzLl9jdXJyUm93SW5kZXh9YCk7XG4gICAgfVxuICAgIHJvdyA9IEFycmF5LmZyb20ocm93KTtcbiAgICByb3cgPSBub3JtYWxpemVSb3cuY2FsbCh0aGlzLCByb3csIHRoaXMuX2N1cnJSb3dJbmRleCk7XG4gICAgaWYgKHRoaXMuX2N1cnJSb3dJbmRleCA9PT0gMCkgZW5zdXJlLmNhbGwodGhpcywgcm93KTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdQYWdlLFxuICAgICAgdG9SZW5kZXJcbiAgICB9ID0gbWVhc3VyZS5jYWxsKHRoaXMsIHJvdywgdGhpcy5fY3VyclJvd0luZGV4KTtcbiAgICBpZiAobmV3UGFnZSkgdGhpcy5kb2N1bWVudC5jb250aW51ZU9uTmV3UGFnZSgpO1xuICAgIGNvbnN0IHlQb3MgPSByZW5kZXJSb3cuY2FsbCh0aGlzLCB0b1JlbmRlciwgdGhpcy5fY3VyclJvd0luZGV4KTtcbiAgICB0aGlzLmRvY3VtZW50LnggPSB0aGlzLl9wb3NpdGlvbi54O1xuICAgIHRoaXMuZG9jdW1lbnQueSA9IHlQb3M7XG4gICAgaWYgKGxhc3RSb3cpIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIHRoaXMuX2N1cnJSb3dJbmRleCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuZCgpIHtcbiAgICB3aGlsZSAodGhpcy5fcm93QnVmZmVyPy5zaXplKSB0aGlzLnJvdyhbXSk7XG4gICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgIGFjY29tbW9kYXRlQ2xlYW51cC5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50O1xuICB9XG59XG5cbnZhciBUYWJsZU1peGluID0ge1xuICBpbml0VGFibGVzKCkge1xuICAgIHRoaXMuX3RhYmxlSW5kZXggPSAwO1xuICB9LFxuICB0YWJsZShvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBQREZUYWJsZSh0aGlzLCBvcHRzKTtcbiAgfVxufTtcblxuY2xhc3MgUERGTWV0YWRhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IGBcbiAgICAgICAgPD94cGFja2V0IGJlZ2luPVwiXFx1ZmVmZlwiIGlkPVwiVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkXCI/PlxuICAgICAgICAgICAgPHg6eG1wbWV0YSB4bWxuczp4PVwiYWRvYmU6bnM6bWV0YS9cIj5cbiAgICAgICAgICAgICAgICA8cmRmOlJERiB4bWxuczpyZGY9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCI+XG4gICAgICAgIGA7XG4gIH1cbiAgX2Nsb3NlVGFncygpIHtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IHRoaXMuX21ldGFkYXRhLmNvbmNhdChgXG4gICAgICAgICAgICAgICAgPC9yZGY6UkRGPlxuICAgICAgICAgICAgPC94OnhtcG1ldGE+XG4gICAgICAgIDw/eHBhY2tldCBlbmQ9XCJ3XCI/PlxuICAgICAgICBgKTtcbiAgfVxuICBhcHBlbmQoeG1sKSB7XG4gICAgbGV0IG5ld2xpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdGhpcy5fbWV0YWRhdGEgPSB0aGlzLl9tZXRhZGF0YS5jb25jYXQoeG1sKTtcbiAgICBpZiAobmV3bGluZSkgdGhpcy5fbWV0YWRhdGEgPSB0aGlzLl9tZXRhZGF0YS5jb25jYXQoJ1xcbicpO1xuICB9XG4gIGdldFhNTCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGE7XG4gIH1cbiAgZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YS5sZW5ndGg7XG4gIH1cbiAgZW5kKCkge1xuICAgIHRoaXMuX2Nsb3NlVGFncygpO1xuICAgIHRoaXMuX21ldGFkYXRhID0gdGhpcy5fbWV0YWRhdGEudHJpbSgpO1xuICB9XG59XG5cbnZhciBNZXRhZGF0YU1peGluID0ge1xuICBpbml0TWV0YWRhdGEoKSB7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBQREZNZXRhZGF0YSgpO1xuICB9LFxuICBhcHBlbmRYTUwoeG1sKSB7XG4gICAgbGV0IG5ld2xpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdGhpcy5tZXRhZGF0YS5hcHBlbmQoeG1sLCBuZXdsaW5lKTtcbiAgfSxcbiAgX2FkZEluZm8oKSB7XG4gICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cIlwiIHhtbG5zOnhtcD1cImh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9cIj5cbiAgICAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4ke3RoaXMuaW5mby5DcmVhdGlvbkRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnLicpWzBdICsgJ1onfTwveG1wOkNyZWF0ZURhdGU+XG4gICAgICAgICAgICA8eG1wOkNyZWF0b3JUb29sPiR7dGhpcy5pbmZvLkNyZWF0b3J9PC94bXA6Q3JlYXRvclRvb2w+XG4gICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxuICAgICAgICBgKTtcbiAgICBpZiAodGhpcy5pbmZvLlRpdGxlIHx8IHRoaXMuaW5mby5BdXRob3IgfHwgdGhpcy5pbmZvLlN1YmplY3QpIHtcbiAgICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PVwiXCIgeG1sbnM6ZGM9XCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1wiPlxuICAgICAgICAgICAgYCk7XG4gICAgICBpZiAodGhpcy5pbmZvLlRpdGxlKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgICAgICAgICA8ZGM6dGl0bGU+XG4gICAgICAgICAgICAgICAgICAgIDxyZGY6QWx0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSB4bWw6bGFuZz1cIngtZGVmYXVsdFwiPiR7dGhpcy5pbmZvLlRpdGxlfTwvcmRmOmxpPlxuICAgICAgICAgICAgICAgICAgICA8L3JkZjpBbHQ+XG4gICAgICAgICAgICAgICAgPC9kYzp0aXRsZT5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmluZm8uQXV0aG9yKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgICAgICAgICA8ZGM6Y3JlYXRvcj5cbiAgICAgICAgICAgICAgICAgICAgPHJkZjpTZXE+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpPiR7dGhpcy5pbmZvLkF1dGhvcn08L3JkZjpsaT5cbiAgICAgICAgICAgICAgICAgICAgPC9yZGY6U2VxPlxuICAgICAgICAgICAgICAgIDwvZGM6Y3JlYXRvcj5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmluZm8uU3ViamVjdCkge1xuICAgICAgICB0aGlzLmFwcGVuZFhNTChgXG4gICAgICAgICAgICAgICAgPGRjOmRlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8cmRmOkFsdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGkgeG1sOmxhbmc9XCJ4LWRlZmF1bHRcIj4ke3RoaXMuaW5mby5TdWJqZWN0fTwvcmRmOmxpPlxuICAgICAgICAgICAgICAgICAgICA8L3JkZjpBbHQ+XG4gICAgICAgICAgICAgICAgPC9kYzpkZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxuICAgICAgICAgICAgYCk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9XCJcIiB4bWxuczpwZGY9XCJodHRwOi8vbnMuYWRvYmUuY29tL3BkZi8xLjMvXCI+XG4gICAgICAgICAgICA8cGRmOlByb2R1Y2VyPiR7dGhpcy5pbmZvLkNyZWF0b3J9PC9wZGY6UHJvZHVjZXI+YCwgZmFsc2UpO1xuICAgIGlmICh0aGlzLmluZm8uS2V5d29yZHMpIHtcbiAgICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgICAgIDxwZGY6S2V5d29yZHM+JHt0aGlzLmluZm8uS2V5d29yZHN9PC9wZGY6S2V5d29yZHM+YCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZFhNTChgXG4gICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxuICAgICAgICBgKTtcbiAgfSxcbiAgZW5kTWV0YWRhdGEoKSB7XG4gICAgdGhpcy5fYWRkSW5mbygpO1xuICAgIHRoaXMubWV0YWRhdGEuZW5kKCk7XG4gICAgaWYgKHRoaXMudmVyc2lvbiAhPSAxLjMpIHtcbiAgICAgIHRoaXMubWV0YWRhdGFSZWYgPSB0aGlzLnJlZih7XG4gICAgICAgIGxlbmd0aDogdGhpcy5tZXRhZGF0YS5nZXRMZW5ndGgoKSxcbiAgICAgICAgVHlwZTogJ01ldGFkYXRhJyxcbiAgICAgICAgU3VidHlwZTogJ1hNTCdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tZXRhZGF0YVJlZi5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgdGhpcy5tZXRhZGF0YVJlZi53cml0ZShCdWZmZXIuZnJvbSh0aGlzLm1ldGFkYXRhLmdldFhNTCgpLCAndXRmLTgnKSk7XG4gICAgICB0aGlzLm1ldGFkYXRhUmVmLmVuZCgpO1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YVJlZjtcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFBERkRvY3VtZW50IGV4dGVuZHMgc3RyZWFtLlJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgc3dpdGNoIChvcHRpb25zLnBkZlZlcnNpb24pIHtcbiAgICAgIGNhc2UgJzEuNCc6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDEuNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcxLjUnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSAxLjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMS42JzpcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMS42O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEuNyc6XG4gICAgICBjYXNlICcxLjdleHQzJzpcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMS43O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDEuMztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuY29tcHJlc3MgPSB0aGlzLm9wdGlvbnMuY29tcHJlc3MgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5jb21wcmVzcyA6IHRydWU7XG4gICAgdGhpcy5fcGFnZUJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuX3BhZ2VCdWZmZXJTdGFydCA9IDA7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdO1xuICAgIHRoaXMuX3dhaXRpbmcgPSAwO1xuICAgIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBQYWdlcyA9IHRoaXMucmVmKHtcbiAgICAgIFR5cGU6ICdQYWdlcycsXG4gICAgICBDb3VudDogMCxcbiAgICAgIEtpZHM6IFtdXG4gICAgfSk7XG4gICAgY29uc3QgTmFtZXMgPSB0aGlzLnJlZih7XG4gICAgICBEZXN0czogbmV3IFBERk5hbWVUcmVlKClcbiAgICB9KTtcbiAgICB0aGlzLl9yb290ID0gdGhpcy5yZWYoe1xuICAgICAgVHlwZTogJ0NhdGFsb2cnLFxuICAgICAgUGFnZXMsXG4gICAgICBOYW1lc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubGFuZykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLkxhbmcgPSBuZXcgU3RyaW5nKHRoaXMub3B0aW9ucy5sYW5nKTtcbiAgICB9XG4gICAgdGhpcy5wYWdlID0gbnVsbDtcbiAgICB0aGlzLmluaXRNZXRhZGF0YSgpO1xuICAgIHRoaXMuaW5pdENvbG9yKCk7XG4gICAgdGhpcy5pbml0VmVjdG9yKCk7XG4gICAgdGhpcy5pbml0Rm9udHMob3B0aW9ucy5mb250KTtcbiAgICB0aGlzLmluaXRUZXh0KCk7XG4gICAgdGhpcy5pbml0SW1hZ2VzKCk7XG4gICAgdGhpcy5pbml0T3V0bGluZSgpO1xuICAgIHRoaXMuaW5pdE1hcmtpbmdzKG9wdGlvbnMpO1xuICAgIHRoaXMuaW5pdFRhYmxlcygpO1xuICAgIHRoaXMuaW5pdFN1YnNldChvcHRpb25zKTtcbiAgICB0aGlzLmluZm8gPSB7XG4gICAgICBQcm9kdWNlcjogJ1BERktpdCcsXG4gICAgICBDcmVhdG9yOiAnUERGS2l0JyxcbiAgICAgIENyZWF0aW9uRGF0ZTogbmV3IERhdGUoKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmZvKSB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5vcHRpb25zLmluZm8pIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5vcHRpb25zLmluZm9ba2V5XTtcbiAgICAgICAgdGhpcy5pbmZvW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheVRpdGxlKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuVmlld2VyUHJlZmVyZW5jZXMgPSB0aGlzLnJlZih7XG4gICAgICAgIERpc3BsYXlEb2NUaXRsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2lkID0gUERGU2VjdXJpdHkuZ2VuZXJhdGVGaWxlSUQodGhpcy5pbmZvKTtcbiAgICB0aGlzLl9zZWN1cml0eSA9IFBERlNlY3VyaXR5LmNyZWF0ZSh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl93cml0ZShgJVBERi0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICB0aGlzLl93cml0ZSgnJVxceEZGXFx4RkZcXHhGRlxceEZGJyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvRmlyc3RQYWdlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5hZGRQYWdlKCk7XG4gICAgfVxuICB9XG4gIGFkZFBhZ2Uob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICh7XG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSB0aGlzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYnVmZmVyUGFnZXMpIHtcbiAgICAgIHRoaXMuZmx1c2hQYWdlcygpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2UgPSBuZXcgUERGUGFnZSh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9wYWdlQnVmZmVyLnB1c2godGhpcy5wYWdlKTtcbiAgICBjb25zdCBwYWdlcyA9IHRoaXMuX3Jvb3QuZGF0YS5QYWdlcy5kYXRhO1xuICAgIHBhZ2VzLktpZHMucHVzaCh0aGlzLnBhZ2UuZGljdGlvbmFyeSk7XG4gICAgcGFnZXMuQ291bnQrKztcbiAgICB0aGlzLnggPSB0aGlzLnBhZ2UubWFyZ2lucy5sZWZ0O1xuICAgIHRoaXMueSA9IHRoaXMucGFnZS5tYXJnaW5zLnRvcDtcbiAgICB0aGlzLl9jdG0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgdGhpcy50cmFuc2Zvcm0oMSwgMCwgMCwgLTEsIDAsIHRoaXMucGFnZS5oZWlnaHQpO1xuICAgIHRoaXMuZW1pdCgncGFnZUFkZGVkJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29udGludWVPbk5ld1BhZ2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHBhZ2VNYXJraW5ncyA9IHRoaXMuZW5kUGFnZU1hcmtpbmdzKHRoaXMucGFnZSk7XG4gICAgdGhpcy5hZGRQYWdlKG9wdGlvbnMgPz8gdGhpcy5wYWdlLl9vcHRpb25zKTtcbiAgICB0aGlzLmluaXRQYWdlTWFya2luZ3MocGFnZU1hcmtpbmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBidWZmZXJlZFBhZ2VSYW5nZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuX3BhZ2VCdWZmZXJTdGFydCxcbiAgICAgIGNvdW50OiB0aGlzLl9wYWdlQnVmZmVyLmxlbmd0aFxuICAgIH07XG4gIH1cbiAgc3dpdGNoVG9QYWdlKG4pIHtcbiAgICBsZXQgcGFnZTtcbiAgICBpZiAoIShwYWdlID0gdGhpcy5fcGFnZUJ1ZmZlcltuIC0gdGhpcy5fcGFnZUJ1ZmZlclN0YXJ0XSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc3dpdGNoVG9QYWdlKCR7bn0pIG91dCBvZiBib3VuZHMsIGN1cnJlbnQgYnVmZmVyIGNvdmVycyBwYWdlcyAke3RoaXMuX3BhZ2VCdWZmZXJTdGFydH0gdG8gJHt0aGlzLl9wYWdlQnVmZmVyU3RhcnQgKyB0aGlzLl9wYWdlQnVmZmVyLmxlbmd0aCAtIDF9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhZ2UgPSBwYWdlO1xuICB9XG4gIGZsdXNoUGFnZXMoKSB7XG4gICAgY29uc3QgcGFnZXMgPSB0aGlzLl9wYWdlQnVmZmVyO1xuICAgIHRoaXMuX3BhZ2VCdWZmZXIgPSBbXTtcbiAgICB0aGlzLl9wYWdlQnVmZmVyU3RhcnQgKz0gcGFnZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IHBhZ2Ugb2YgcGFnZXMpIHtcbiAgICAgIHRoaXMuZW5kUGFnZU1hcmtpbmdzKHBhZ2UpO1xuICAgICAgcGFnZS5lbmQoKTtcbiAgICB9XG4gIH1cbiAgYWRkTmFtZWREZXN0aW5hdGlvbihuYW1lKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJncyA9IFsnWFlaJywgbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgfVxuICAgIGlmIChhcmdzWzBdID09PSAnWFlaJyAmJiBhcmdzWzJdICE9PSBudWxsKSB7XG4gICAgICBhcmdzWzJdID0gdGhpcy5wYWdlLmhlaWdodCAtIGFyZ3NbMl07XG4gICAgfVxuICAgIGFyZ3MudW5zaGlmdCh0aGlzLnBhZ2UuZGljdGlvbmFyeSk7XG4gICAgdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuRGVzdHMuYWRkKG5hbWUsIGFyZ3MpO1xuICB9XG4gIGFkZE5hbWVkRW1iZWRkZWRGaWxlKG5hbWUsIHJlZikge1xuICAgIGlmICghdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuRW1iZWRkZWRGaWxlcykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuRW1iZWRkZWRGaWxlcyA9IG5ldyBQREZOYW1lVHJlZSh7XG4gICAgICAgIGxpbWl0czogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5FbWJlZGRlZEZpbGVzLmFkZChuYW1lLCByZWYpO1xuICB9XG4gIGFkZE5hbWVkSmF2YVNjcmlwdChuYW1lLCBqcykge1xuICAgIGlmICghdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuSmF2YVNjcmlwdCkge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuSmF2YVNjcmlwdCA9IG5ldyBQREZOYW1lVHJlZSgpO1xuICAgIH1cbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIEpTOiBuZXcgU3RyaW5nKGpzKSxcbiAgICAgIFM6ICdKYXZhU2NyaXB0J1xuICAgIH07XG4gICAgdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuSmF2YVNjcmlwdC5hZGQobmFtZSwgZGF0YSk7XG4gIH1cbiAgcmVmKGRhdGEpIHtcbiAgICBjb25zdCByZWYgPSBuZXcgUERGUmVmZXJlbmNlKHRoaXMsIHRoaXMuX29mZnNldHMubGVuZ3RoICsgMSwgZGF0YSk7XG4gICAgdGhpcy5fb2Zmc2V0cy5wdXNoKG51bGwpO1xuICAgIHRoaXMuX3dhaXRpbmcrKztcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIF9yZWFkKCkge31cbiAgX3dyaXRlKGRhdGEpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEgKyAnXFxuJywgJ2JpbmFyeScpO1xuICAgIH1cbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgdGhpcy5fb2Zmc2V0ICs9IGRhdGEubGVuZ3RoO1xuICB9XG4gIGFkZENvbnRlbnQoZGF0YSkge1xuICAgIHRoaXMucGFnZS53cml0ZShkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfcmVmRW5kKHJlZikge1xuICAgIHRoaXMuX29mZnNldHNbcmVmLmlkIC0gMV0gPSByZWYub2Zmc2V0O1xuICAgIGlmICgtLXRoaXMuX3dhaXRpbmcgPT09IDAgJiYgdGhpcy5fZW5kZWQpIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplKCk7XG4gICAgICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbmQoKSB7XG4gICAgdGhpcy5mbHVzaFBhZ2VzKCk7XG4gICAgdGhpcy5faW5mbyA9IHRoaXMucmVmKCk7XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuaW5mbykge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuaW5mb1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbCA9IG5ldyBTdHJpbmcodmFsKTtcbiAgICAgIH1cbiAgICAgIGxldCBlbnRyeSA9IHRoaXMucmVmKHZhbCk7XG4gICAgICBlbnRyeS5lbmQoKTtcbiAgICAgIHRoaXMuX2luZm8uZGF0YVtrZXldID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMuX2luZm8uZW5kKCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLl9mb250RmFtaWxpZXMpIHtcbiAgICAgIGNvbnN0IGZvbnQgPSB0aGlzLl9mb250RmFtaWxpZXNbbmFtZV07XG4gICAgICBmb250LmZpbmFsaXplKCk7XG4gICAgfVxuICAgIHRoaXMuZW5kT3V0bGluZSgpO1xuICAgIHRoaXMuZW5kTWFya2luZ3MoKTtcbiAgICBpZiAodGhpcy5zdWJzZXQpIHtcbiAgICAgIHRoaXMuZW5kU3Vic2V0KCk7XG4gICAgfVxuICAgIHRoaXMuZW5kTWV0YWRhdGEoKTtcbiAgICB0aGlzLl9yb290LmVuZCgpO1xuICAgIHRoaXMuX3Jvb3QuZGF0YS5QYWdlcy5lbmQoKTtcbiAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZW5kKCk7XG4gICAgdGhpcy5lbmRBY3JvRm9ybSgpO1xuICAgIGlmICh0aGlzLl9yb290LmRhdGEuVmlld2VyUHJlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5WaWV3ZXJQcmVmZXJlbmNlcy5lbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NlY3VyaXR5KSB7XG4gICAgICB0aGlzLl9zZWN1cml0eS5lbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhaXRpbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VuZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgX2ZpbmFsaXplKCkge1xuICAgIGNvbnN0IHhSZWZPZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgdGhpcy5fd3JpdGUoJ3hyZWYnKTtcbiAgICB0aGlzLl93cml0ZShgMCAke3RoaXMuX29mZnNldHMubGVuZ3RoICsgMX1gKTtcbiAgICB0aGlzLl93cml0ZSgnMDAwMDAwMDAwMCA2NTUzNSBmICcpO1xuICAgIGZvciAobGV0IG9mZnNldCBvZiB0aGlzLl9vZmZzZXRzKSB7XG4gICAgICBvZmZzZXQgPSBgMDAwMDAwMDAwMCR7b2Zmc2V0fWAuc2xpY2UoLTEwKTtcbiAgICAgIHRoaXMuX3dyaXRlKG9mZnNldCArICcgMDAwMDAgbiAnKTtcbiAgICB9XG4gICAgY29uc3QgdHJhaWxlciA9IHtcbiAgICAgIFNpemU6IHRoaXMuX29mZnNldHMubGVuZ3RoICsgMSxcbiAgICAgIFJvb3Q6IHRoaXMuX3Jvb3QsXG4gICAgICBJbmZvOiB0aGlzLl9pbmZvLFxuICAgICAgSUQ6IFt0aGlzLl9pZCwgdGhpcy5faWRdXG4gICAgfTtcbiAgICBpZiAodGhpcy5fc2VjdXJpdHkpIHtcbiAgICAgIHRyYWlsZXIuRW5jcnlwdCA9IHRoaXMuX3NlY3VyaXR5LmRpY3Rpb25hcnk7XG4gICAgfVxuICAgIHRoaXMuX3dyaXRlKCd0cmFpbGVyJyk7XG4gICAgdGhpcy5fd3JpdGUoUERGT2JqZWN0LmNvbnZlcnQodHJhaWxlcikpO1xuICAgIHRoaXMuX3dyaXRlKCdzdGFydHhyZWYnKTtcbiAgICB0aGlzLl93cml0ZShgJHt4UmVmT2Zmc2V0fWApO1xuICAgIHRoaXMuX3dyaXRlKCclJUVPRicpO1xuICAgIHRoaXMucHVzaChudWxsKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgUERGRG9jdW1lbnRdJztcbiAgfVxufVxuY29uc3QgbWl4aW4gPSBtZXRob2RzID0+IHtcbiAgT2JqZWN0LmFzc2lnbihQREZEb2N1bWVudC5wcm90b3R5cGUsIG1ldGhvZHMpO1xufTtcbm1peGluKE1ldGFkYXRhTWl4aW4pO1xubWl4aW4oQ29sb3JNaXhpbik7XG5taXhpbihWZWN0b3JNaXhpbik7XG5taXhpbihGb250c01peGluKTtcbm1peGluKFRleHRNaXhpbik7XG5taXhpbihJbWFnZXNNaXhpbik7XG5taXhpbihBbm5vdGF0aW9uc01peGluKTtcbm1peGluKE91dGxpbmVNaXhpbik7XG5taXhpbihNYXJraW5nc01peGluKTtcbm1peGluKEFjcm9Gb3JtTWl4aW4pO1xubWl4aW4oQXR0YWNobWVudHNNaXhpbik7XG5taXhpbihTdWJzZXRNaXhpbik7XG5taXhpbihUYWJsZU1peGluKTtcblBERkRvY3VtZW50LkxpbmVXcmFwcGVyID0gTGluZVdyYXBwZXI7XG5cbmV4cG9ydCB7IFBERkRvY3VtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZmtpdC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/pdfkit@0.17.1/node_modules/pdfkit/js/pdfkit.es.js\n");

/***/ })

};
;